# Backy pre-stash diff snapshot
# Generated: 2026-02-28 09:50:27 +0530
# Scope: tracked file diff only (git diff -- .). Untracked/new files excluded by design.
# Commit this file before stashing if you want a stable checkpoint.

diff --git a/BACKY_HANDOFF.md b/BACKY_HANDOFF.md
index 783f573..7c042a0 100644
--- a/BACKY_HANDOFF.md
+++ b/BACKY_HANDOFF.md
@@ -1,75 +1,142 @@
 # Backy Continuation Handoff  
-**Date:** 2026-02-24  
+**Date:** 2026-02-27  
 **Path:** `/Users/devanshvarshney/Downloads/Scythian /backy`  
 
 ## 1) Current objective
-Continue implementation toward **Wix/WordPress/Canva-like CMS parity**, with strict priority on:
-1. Form submission flow
-2. Contact/share flow
-3. Comment moderation flow
+Continue implementation toward **Wix/WordPress/Canva-like CMS parity** with a headless-first design:
 
-Everything else is secondary until this is stable.
+1. Finish remaining Phase A gaps: contracts, auth, and persistence boundaries.
+2. Close remaining Phase A gaps: contracts, auth, and persistence boundaries.
+3. Finish remaining Phase C gaps: moderation ergonomics for large-scope workflows and anti-abuse operator tooling.
+4. Continue into D–J for full platform depth.
 
-## 2) Reference docs (read first every session)
+Core outcome: users can use `backy-admin`, or any custom frontend, against the same `backy-public` contracts.
+
+## 2) Master execution references (read first every session)
 - `specs/backy-cms-completion-spec.md`
 - `specs/backy-wix-canva-cms-v1-roadmap.md`
+- `specs/backy-full-parity-roadmap-spec.md`
+- `specs/phase-docs/backy-headless-cms-platform-phase-roadmap-v1.md` (authoritative phase roadmap)
+- `specs/phase-docs/backy-headless-cms-platform-phase-roadmap-v2.md` (detailed phased execution roadmap)
+- `specs/phase-docs/backy-phase-a-j-completion-spec.md` (A–J completion matrix)
+- `specs/phase-docs/backy-alpha-vs-numeric-phase-progress-2026-02-27.md` (numeric↔alpha mapping + completion evidence)
+- `specs/implementation-plans/phase-a-contract-persistence-auth-plan.md`
+- `specs/implementation-plans/phase-b-editor-action-wiring-plan.md`
+- `specs/implementation-plans/phase-c-form-engine-plan.md`
+- `specs/implementation-plans/phase-d-comment-moderation-plan.md`
+- `specs/implementation-plans/phase-e-core-cms-composition-plan.md`
+- `specs/implementation-plans/phase-f-public-api-first-plan.md`
+- `specs/implementation-plans/phase-g-versioning-deploy-plan.md`
+- `specs/implementation-plans/phase-h-media-seo-localization-plan.md`
+- `specs/implementation-plans/phase-i-analytics-audit-governance-plan.md`
+- `specs/implementation-plans/phase-j-extensibility-platform-plan.md`
+- `specs/four-day-fast-track-execution-plan.md`
+- `specs/stash.md`
+
+## 3) Current phase status
+- Canonical interpretation: alpha and numeric phase naming are independent taxonomies; mapping is approximate and one numeric phase can include multiple alpha phases. See `backy-alpha-vs-numeric-phase-progress-2026-02-27.md`.
+
+### Phase A (contracts + persistence + auth) — partial complete
+- Canonical types, auth bridge, and public API parsing hardening are in place.
+- In this pass:
+  - enforced `canEdit`/`canAdminister` action-level guards were added for active editor mutability paths and admin list-route delete/edit mutations (`sites`, `pages`, `blog`, `users`, `media`).
+  - root-level role gates now use selector-backed permissions (`canEdit`, `canAdminister`) so role-based redirection is session-consistent.
+  - non-admin users no longer see admin-only routes in the sidebar navigation.
+  - explicit `owner` role support in auth store remains in place for phase-A role matrix baseline.
+- Still incomplete:
+  - DB-backed route/read-write boundaries for key admin/public flows.
+  - middleware-level RBAC/session enforcement across backend boundaries.
+  - route-level permission matrix for owner/admin/editor/viewer in server-anchored persistence flows.
+  - session selector hardening is wired for admin route gating; full server-side enforcement still pending.
+
+### Phase B (editor action wiring) — partial (runtime follow-up in progress)
+- Selection safety, clipboard/tooling handlers, and route-level read-only enforcement are now in place.
+- In this pass:
+  - Added revision-aware save/reload safety in `pages.$pageId.edit.tsx`.
+  - Save now blocks overwrite on detected concurrent edit drift and requires explicit refresh/retry.
+  - Duplicate now inserts as a sibling near the selected node (instead of nested self-insertion) via deterministic parent-path insertion.
+  - Reload now refreshes local revision baseline and clears stale write errors.
+  - Save fallback canvas size now uses the current editor canvas size in page save flow.
+- Completed this pass:
+  - Interaction-bound history now commits on drag/resize/canvas-size end, while transient moves do not fill undo stack.
+  - Undo/redo replay remains deterministic for repeated move/resize cycles.
+  - Added interaction checkpoint flush for in-flight moves/sizes before save/undo/redo to keep persistence/reload edges deterministic.
+- Remaining:
+  - published/archived status lifecycle and page revision graph (tracked in Phase F).
+  - text single-tap/double-tap parity and full style-toggle history behavior (see `specs/stash.md`).
+
+### Phase C (forms/comments production module) — near-complete
+- Public and admin comment moderation APIs for block/report/export/analytics are in place.
+- Parser and JSX balance issues in moderation section were corrected.
+- `sites.$siteId.tsx` now enforces `canEdit` checks for all moderation/write paths.
+- Anti-abuse controls and strict policy validation are active.
+- Root auth timeout handling is now memoized by session expiry and only clears active sessions when auth is valid, reducing startup redirect churn risk.
+- Remaining:
+  - final operator ergonomics for very large bulk scopes,
+  - richer anti-abuse retention and operator telemetry surfaces.
+- Latest completion state: functional parity for moderation queue + policy + block/report/analytics + anti-abuse for most common workflows.
+
+### Phase C (forms/comments production module) — hardening complete for operator use
+- Public and admin comment moderation endpoints are now feature-complete enough for day-one operations.
+- Remaining follow-ups are intentionally scoped to scale/perf: identity lookup paging, anti-abuse retention policy tooling, and SOC telemetry export ergonomics.
 
-## 3) Current known breakages to stabilize first
-- Text elements and nested element selection became unreliable after recent editor changes.
-- Right property panel showed duplicated/conflicting formatting UX.
-- Some interactions lost (drag/editing behavior in canvas).
-- User reported inability to edit text, open color picker, use emoji/formatting UX consistently.
-- Existing reported parser warning:
-  - `apps/admin/src/components/editor/Canvas.tsx` Unicode-escape parse issue around `placeholder` strings.
-
-If these are not fully resolved, **stop all feature additions** and fix editor interaction first.
-
-## 4) Scope for future sessions
-### Phase A (required block before anything else)
-- Restore stable text editing in canvas:
-  - click-to-select should reliably target clicked element
-  - rich text should support inline edits
-  - styling/format controls should be usable and not duplicated
-  - drag/move/resize should still work after text edits
-- Keep responsive preview sanity in desktop/tablet/mobile.
-
-### Phase B (current roadmap)
-- Form block + submission: connect backend + validation + spam/duplicates + submit behaviors + admin submission view
-- Comment block + moderation: moderation state transitions, block/report actions, search/filter/export
-- Contact-share hooks: requestId correlation + telemetry + webhook/email pipeline
-
-### Phase C (next backlog)
-- Consolidate repeated editor logic and avoid duplicate state paths.
-- Improve UX quality of right panel and block palettes.
-- Keep continuing with the parity roadmap.
-
-## 5) Critical developer constraints (do not violate)
-- Use `apply_patch` for edits (no broad, destructive shell edits for this workflow).
-- Do **not** revert unrelated changes.
-- Do **not** perform large exploratory code reads.
-- Keep fixes minimal and non-repetitive.
-- Do not use tutorials as implementation content; apply product logic only.
-- Avoid running tests/builds unless explicitly requested.
-- One file read/edit pass policy applies: keep each file pass minimal and targeted.
+### Phase C (forms/comments production module) — in hardening-closeout
+- Public and admin comment moderation APIs for block/report/export/analytics are in place.
+- JSX structure in moderation section is now corrected to remove parser breakage.
+- Editor read-only mode now blocks accidental front-end mutations from comment-heavy admin pages.
+- In this pass: status filters flow through moderation analytics/export/policy APIs, and anti-abuse policy payload validation now enforces strict field constraints.
+- Remaining:
+  - final moderation-queue ergonomics for very large scope operations and identity list workflows.
+  - richer anti-abuse telemetry surfaces and retention controls (tracked in Phase I).
+- Latest pass: route-level write protection is now gated by `canEdit` in `sites.$siteId.tsx`; unauthorized roles can still view queues/analytics but cannot execute write or moderation actions.
+
+### Current working status after this pass
+- Phase A remains incomplete until DB/session middleware and true owner/admin/editor permission enforcement are moved from store-level mocks into admin/public boundaries.
+- Phase B is marked complete for single-select editor action wiring; remaining work is multi-select/action-stack parity in broader Phase B/F evolution.
+- Phase C operationally functional for moderation/export/anti-abuse after comment UI hardening and startup-loop hardening; remaining work is scale-oriented tuning in large-bulk operators and anti-abuse observability.
+- Startup stability: auth routing loop prevention now uses effect-driven redirects in `apps/admin/src/routes/__root.tsx` with memoized auth-path decisions; no render-time navigation.
+
+### Phase B/C/A short queue (execution priority)
+- Immediate next: verify startup loop is resolved after redirect hardening, then complete Phase A security/persistence.
+
+### Phase D–J
+- Composition primitives, public-first API hardening, versioning/deployability, SEO/media, analytics/audit, and plugin platform are still open by design and already queued in the roadmap.
+
+## 4) Scope for current and next sessions
+- If editor interaction regressions reappear, stop feature expansion and finish Phase A/B blockers first:
+  - stable undo/redo boundaries in multi-select and nested flows,
+  - clipboard-safe duplicate/delete commands,
+  - save/publish/reload persistence reliability.
+- Then complete:
+  1. **Phase B** regression closure (`specs/stash.md`) for text interaction and undo/redo determinism,
+  2. **Phase A** boundaries/auth completion (contract-to-store session and role enforcement),
+  3. final **Phase C** hardening (bulk scope ergonomics + anti-abuse retention/telemetry exports).
+
+## 5) Critical constraints
+- Do not revert unrelated edits.
+- Use `apply_patch` for all file edits.
+- Keep fixes minimal and bounded.
+- Do not run tests/builds unless explicitly requested.
 
 ## 6) Active working files likely to be touched next
-- `apps/admin/src/components/editor/Canvas.tsx`
-- `apps/admin/src/components/editor/PropertyPanel.tsx`
-- `apps/admin/src/components/editor/blocks/RichTextBlock.tsx`
-- `apps/admin/src/components/editor/CanvasEditor.tsx`
-- `apps/public/src/app/api/sites/[siteId]/forms/[formId]/submissions/route.ts`
-- `apps/public/src/lib/...` form/comment/contact related services
-
-## 7) Minimum acceptance before moving to next work
-- I can click and edit text without corruption.
-- Inline formatting controls apply predictably to selected text.
-- Right panel no longer shows repeated or conflicting formatting controls.
-- Drag/resize remains functional for text containers and nested elements.
-- Form and comment backend flows function end-to-end with admin/admin-review actions.
+- `apps/public/src/app/api/sites/[siteId]/comments/...`
+- `apps/public/src/lib/backyStore.ts`
+- `apps/admin/src/routes/sites.$siteId.tsx`
+- `specs/phase-docs/backy-headless-cms-platform-phase-roadmap-v1.md`
+- `specs/phase-docs/backy-headless-cms-platform-phase-roadmap-v2.md`
+- `specs/backy-full-parity-roadmap-spec.md`
+
+## 7) Phase acceptance baseline
+- I can complete editor text selection/editing without corruption.
+- Undo/redo and duplicate/delete paths no longer destabilize layer order.
+- Save and reload reflect persisted state transitions.
+- Comment moderation + export + event telemetry flow are end-to-end and deterministic.
+- Public comment read defaults to approved content unless explicitly querying moderation states.
+- A-B-C historical checkpoint is maintained in `specs/stash.md`.
 
 ## 8) Commit rule
-This is a continuity repo. Each meaningful fix should be committed with a message in this pattern:
-- `fix(editor): ...`
-- `feat(forms-comments): ...`
+- This is a continuity repo. Each meaningful fix should be committed separately with message prefixes such as:
+  - `fix(editor): ...`
+  - `feat(forms-comments): ...`
 
-Use this handoff file as the canonical context when deciding whether a change is in scope.
+Use this handoff as canonical scope context before deciding whether a change is in scope.
diff --git a/NEXT_CHAT_HANDOFF.md b/NEXT_CHAT_HANDOFF.md
index 7be5b9a..11bb1c1 100644
--- a/NEXT_CHAT_HANDOFF.md
+++ b/NEXT_CHAT_HANDOFF.md
@@ -1,23 +1,90 @@
-# Backy Handoff Notes (2026-02-24)
+# Backy Handoff Notes (2026-02-27)
 
-## Current active directory
-- Working repo is now: `/Users/devanshvarshney/Downloads/Scythian /backy`
-- This is the directory to continue from in future sessions.
+## Active directory
+- `/Users/devanshvarshney/Downloads/Scythian /backy`
 
-## What was completed in latest pass
-- Renamed branding references to the product/repo name `backy`.
-- README and setup docs now reference `backy` paths.
-- Removed old `backy-cms` duplicate/stale folder under `/Users/devanshvarshney/Downloads/Scythian `.
-- Project metadata aligned to `backy` in:
-  - `/Users/devanshvarshney/Downloads/Scythian /backy/package.json` (repo URL updated)
-  - `/Users/devanshvarshney/Downloads/Scythian /backy/package-lock.json` (root lockfile name updated)
+## Current working focus
+- This pass completed remaining **Phase B editor action wiring** edge-cases (single-select deterministic stack + save/publish/reload safety).
+- Phase C has been stabilized around admin moderation parity and parser correctness; this pass also added editor read-only action hardening.
+- The phase execution source of truth is now:
+- `specs/phase-docs/backy-headless-cms-platform-phase-roadmap-v1.md`
+- `specs/phase-docs/backy-headless-cms-platform-phase-roadmap-v2.md`
+- `specs/phase-docs/backy-phase-a-j-completion-spec.md`
+- `specs/backy-full-parity-roadmap-spec.md`
+- `specs/backy-cms-completion-spec.md`
+- `specs/phase-docs/backy-alpha-vs-numeric-phase-progress-2026-02-27.md`
+- `specs/stash.md`
 
-## Important note about remaining `backy-cms` strings
-- Strings in package names such as `@backy-cms/*` and files like `specs/backy-cms-completion-spec.md` are intentionally preserved for package scope and are not part of repo-folder naming.
-- Only stale folder/path references and README/path references were cleaned.
+## What is already in place
+- Core comment/form type contracts and public route compatibility exist.
+- Public comment moderation pipeline exists:
+  - `apps/public/src/app/api/sites/[siteId]/comments/` (list/status updates)
+  - `/comments/export`
+  - `/comments/analytics`
+  - `/comments/blocks`
+  - `/comments/{commentId}/report` and `/comments/report-reasons`
+- Anti-abuse and block telemetry exists in `apps/public/src/lib/backyStore.ts`:
+  - comment anti-abuse counters and request/user signals,
+  - block list storage and expiry,
+  - moderation analytics.
+- Admin-facing moderation and block ergonomics in `apps/admin/src/routes/sites.$siteId.tsx` include:
+  - bulk actions,
+  - block create/delete flows,
+  - filtered comment analytics loading,
+  - filtered comment export and event export.
+- Current pass added:
+  - status/thread/request/parent filters are parity-aligned across moderation list, export, analytics, and blocklist fetch.
+  - `comments/policy` now enforces strict anti-abuse field limits with actionable validation errors.
+  - JSX parser breakage in the comments section was fixed by balancing closing tags.
+  - `apps/admin/src/routes/sites.$siteId.tsx` now enforces `canEdit` checks for all comment/form/submission moderation writes, site save/delete, blocklist and anti-abuse controls.
+  - admin list-route mutating actions in `sites`, `pages`, `blog`, `users`, and `media` now require `canEdit`/`canAdminister` guards at handler execution time.
+  - `CanvasEditor` now has a read-only mode and page/blog editor routes pass `readOnly={!canEdit}`.
+- `__root.tsx` now memoizes session-timeout expiry and gates auto-sign-out on active authentication state, which should remove startup router-loop churn and unstable session timeout updates.
+- `__root.tsx` redirect logic is now effect-driven (`redirectTo` + `navigate`) to avoid render-time navigation loops.
 
-## Commit status
-- Initial commit is now being created from this exact directory state.
+## Remaining in this pass (order of execution)
+1. Finish Phase A: DB/store boundaries + RBAC/session enforcement.
+2. Re-check startup loop by hard refresh after root/session hardening.
+3. Return to Phase C throughput hardening only: bulk operators, anti-abuse retention exports, and alert/forensic signals.
 
-## Continue points
-- Next chat should proceed from this repo root and this handoff file first if context is needed.
+## Current phase note
+- Phase A now has route/session guard hardening completed for core admin surfaces (selector-driven root gates + nav-level role filtering), plus remaining work in DB-backed persistence boundaries.
+- Phase B now includes complete single-select editor action gating for read-only roles and deterministic interaction-bound history commits for move/resize/canvas-size operations; remaining work around multi-select is tracked separately for later.
+- `owner` role has been added in admin auth store and root session selection now uses authenticated-selector semantics for baseline role consistency.
+- `pages.$pageId.edit.tsx` now includes conflict-aware save guardrails and revised editor hydration baseline handling.
+- New completion matrix is available at `specs/phase-docs/backy-phase-a-j-completion-spec.md`.
+- Alpha↔numeric phase translation + expanded progress evidence is now documented in `specs/phase-docs/backy-alpha-vs-numeric-phase-progress-2026-02-27.md`.
+- Root auth redirect flow was rewritten in `__root.tsx` to use effect-driven redirect handling for deterministic startup transitions.
+
+## Phase A/B completion status now
+- A (contracts/auth) still has blockers for real persistence adapters and server-side RBAC checks.
+- B (editor action wiring) interaction stack is now stable for single-select flows with deterministic live-to-committed history transitions, and in-flight interaction checkpoint flush before save/undo/redo was added.
+- Latest this pass also adjusted duplicate placement to deterministic sibling insertion and save fallback sizing for page saves.
+
+## Phase C hardening priority (next in this queue)
+1. Finalize moderation queue operator ergonomics for large-scope bulk operations.
+2. Extend comment block/telemetry export ergonomics for anti-abuse investigation.
+3. Add anti-abuse retention export slices and policy drift alerts where useful for SOC workflows.
+4. Re-test startup loop after root redirect hardening and complete Phase A auth/session enforcement.
+
+## Reference docs for next session
+- `specs/implementation-plans/phase-a-contract-persistence-auth-plan.md`
+- `specs/implementation-plans/phase-b-editor-action-wiring-plan.md`
+- `specs/implementation-plans/phase-c-form-engine-plan.md`
+- `specs/implementation-plans/phase-d-comment-moderation-plan.md`
+- `specs/implementation-plans/phase-e-core-cms-composition-plan.md`
+- `specs/implementation-plans/phase-f-public-api-first-plan.md`
+- `specs/implementation-plans/phase-g-versioning-deploy-plan.md`
+- `specs/implementation-plans/phase-h-media-seo-localization-plan.md`
+- `specs/implementation-plans/phase-i-analytics-audit-governance-plan.md`
+- `specs/implementation-plans/phase-j-extensibility-platform-plan.md`
+- `specs/four-day-fast-track-execution-plan.md`
+- `specs/stash.md`
+- `specs/implementation-plans/phase-b-text-interaction-and-undo-redo-plan.md`
+
+## Minimum acceptance before moving on
+- Remaining Phase C flows work without manual intervention from public and admin paths:
+  - report endpoint returns standard reason taxonomy and status,
+  - export endpoint supports filters + analytics summary,
+  - block list and block analytics are queryable.
+- Anti-abuse controls can be tuned from comment block settings and reflected in analytics.
diff --git a/apps/admin/src/components/editor/ActiveEditorContext.tsx b/apps/admin/src/components/editor/ActiveEditorContext.tsx
index 62960b5..38dc5ca 100644
--- a/apps/admin/src/components/editor/ActiveEditorContext.tsx
+++ b/apps/admin/src/components/editor/ActiveEditorContext.tsx
@@ -327,6 +327,104 @@ export function ActiveEditorProvider({ children }: { children: React.ReactNode }
     return listTypes.length ? (listTypes[0] as 'ul' | 'ol' | null) : null;
   }, [getActiveEditor, getIsListNode]);
 
+  const getTextNodeAtPath = useCallback((editor: PlateEditor, path: number[]): Record<string, unknown> | null => {
+    try {
+      const [node] = Editor.node(editor as any, path);
+      if (Text.isText(node)) {
+        return node as Record<string, unknown>;
+      }
+    } catch {
+      // Cursor path can become stale during selection churn
+    }
+
+    return null;
+  }, []);
+
+  const getTextNodesForSelection = useCallback((editor: PlateEditor, selection: Range): Record<string, unknown>[] => {
+    const textNodes = Array.from(
+      Editor.nodes(editor, {
+        at: selection,
+        match: (node) => Text.isText(node),
+        mode: 'all',
+      })
+    ).map((entry) => entry[0] as Record<string, unknown>);
+
+    if (textNodes.length > 0) {
+      return textNodes;
+    }
+
+    const anchorTextNode = getTextNodeAtPath(editor, selection.anchor.path);
+    const focusTextNode = getTextNodeAtPath(editor, selection.focus.path);
+
+    if (anchorTextNode && focusTextNode && anchorTextNode !== focusTextNode) {
+      return [anchorTextNode, focusTextNode];
+    }
+
+    if (anchorTextNode) {
+      return [anchorTextNode];
+    }
+
+    if (focusTextNode) {
+      return [focusTextNode];
+    }
+
+    return [];
+  }, [getTextNodeAtPath]);
+
+  const getMarkStateForSelection = useCallback((editor: PlateEditor, format: string): boolean | null => {
+    const selection = editor.selection;
+    if (!selection || !Range.isRange(selection)) {
+      return null;
+    }
+
+    const isCollapsedSelection = Range.isCollapsed(selection);
+    if (isCollapsedSelection) {
+      const [activeTextNode] = getTextNodesForSelection(editor, selection);
+      if (activeTextNode && Object.prototype.hasOwnProperty.call(activeTextNode, format)) {
+        return !!activeTextNode[format];
+      }
+
+      const marks = Editor.marks(editor as any) as Record<string, any> | null;
+      if (marks && Object.prototype.hasOwnProperty.call(marks, format)) {
+        return !!marks[format];
+      }
+    }
+
+    const textNodes = getTextNodesForSelection(editor, selection);
+    if (!textNodes.length) {
+      const marks = Editor.marks(editor as any) as Record<string, any> | null;
+      if (marks && Object.prototype.hasOwnProperty.call(marks, format)) {
+        return !!marks[format];
+      }
+      return null;
+    }
+
+    const firstNode = textNodes[0] as Record<string, unknown>;
+    const hasFirst = Object.prototype.hasOwnProperty.call(firstNode, format);
+    if (!hasFirst) {
+      const marks = Editor.marks(editor as any) as Record<string, any> | null;
+      if (marks && Object.prototype.hasOwnProperty.call(marks, format)) {
+        return !!marks[format];
+      }
+
+      return false;
+    }
+
+    const firstValue = firstNode[format];
+    for (let i = 1; i < textNodes.length; i += 1) {
+      const node = textNodes[i];
+      if (!Object.prototype.hasOwnProperty.call(node, format)) {
+        return false;
+      }
+
+      if (node[format] !== firstValue) {
+        return false;
+      }
+    }
+
+    return !!firstValue;
+  }, [getTextNodesForSelection]);
+
   const applyListIndent = useCallback((step: number) => {
     const editor = getActiveEditor();
     if (!editor) return;
@@ -375,36 +473,18 @@ export function ActiveEditorProvider({ children }: { children: React.ReactNode }
         return false;
       }
 
-      if (Range.isCollapsed(selection)) {
-        const marks = Editor.marks(editor as any) as Record<string, any> | null;
-        return marks ? !!marks[format] : false;
-      }
-
-      const textNodes = Array.from(
-        Editor.nodes(editor, {
-          at: selection,
-          match: (node) => Text.isText(node),
-          mode: 'all',
-        })
-      );
-
-      if (!textNodes.length) {
-        const marks = Editor.marks(editor as any) as Record<string, any> | null;
-        return marks ? !!marks[format] : false;
-      }
-
-      for (const [node] of textNodes) {
-        if (!(node as any)[format]) {
-          return false;
-        }
+      const markState = getMarkStateForSelection(editor, format);
+      if (markState !== null) {
+        return markState;
       }
 
-      return true;
+      const marks = Editor.marks(editor as any) as Record<string, any> | null;
+      return marks ? !!marks[format] : false;
     } catch (e) {
       console.error('isMarkActive failed:', e);
       return false;
     }
-  }, [getActiveEditor]);
+  }, [getActiveEditor, getMarkStateForSelection]);
 
   const hasRangeSelection = useCallback(() => {
     const editor = getActiveEditor();
diff --git a/apps/admin/src/components/editor/Canvas.tsx b/apps/admin/src/components/editor/Canvas.tsx
index 14daa25..d94e022 100644
--- a/apps/admin/src/components/editor/Canvas.tsx
+++ b/apps/admin/src/components/editor/Canvas.tsx
@@ -59,6 +59,18 @@ const sanitizeText = (value: unknown): string => {
   return '';
 };
 
+const areValuesEquivalent = (left: unknown, right: unknown): boolean => {
+  if (left === right) {
+    return true;
+  }
+
+  try {
+    return JSON.stringify(left) === JSON.stringify(right);
+  } catch {
+    return false;
+  }
+};
+
 interface TreeUpdateResult {
   elements: CanvasElement[];
   updated: boolean;
@@ -299,6 +311,22 @@ const normalizeMapUrl = (addressOrUrl: unknown): string => {
   return `https://www.google.com/maps?q=${encodeURIComponent(source)}&output=embed`;
 };
 
+const cloneNodePayload = (value: unknown): unknown => {
+  if (value === null || value === undefined) {
+    return value;
+  }
+
+  if (typeof value !== 'object') {
+    return value;
+  }
+
+  try {
+    return JSON.parse(JSON.stringify(value));
+  } catch {
+    return value;
+  }
+};
+
 const parseFormOptions = (value: unknown): string[] => {
   if (!Array.isArray(value) && typeof value !== 'string') {
     return [];
@@ -481,6 +509,12 @@ interface CanvasProps {
   elements: CanvasElement[];
   /** Callback when elements change */
   onElementsChange: (elements: CanvasElement[]) => void;
+  /** Callback when a target element receives a full-tree update */
+  onElementUpdate?: (elementId: string, elements: CanvasElement[]) => void;
+  /** Callback when element drag/resize interaction ends */
+  onElementsMutationCommit?: (elements: CanvasElement[], selectedId?: string | null) => void;
+  /** Callback for live drag/resize preview updates */
+  onElementsInFlightChange?: (elements: CanvasElement[], selectedId?: string | null) => void;
   /** Currently selected element ID */
   selectedId: string | null;
   /** Callback when element is selected */
@@ -489,11 +523,22 @@ interface CanvasProps {
   size: CanvasSize;
   /** Callback when canvas size changes */
   onSizeChange?: (newSize: CanvasSize) => void;
+  /** Callback when canvas resize interaction ends */
+  onSizeCommit?: (newSize: CanvasSize) => void;
   /** Whether canvas is in preview mode */
   isPreview?: boolean;
 }
 
 const EDITOR_ACTIVATION_EVENT = 'backy-open-text-editor';
+const TEXT_DRAG_START_THRESHOLD = 5;
+
+interface PendingTextDragState {
+  elementId: string;
+  startX: number;
+  startY: number;
+  initialX: number;
+  initialY: number;
+}
 
 // ============================================
 // COMPONENT
@@ -513,17 +558,21 @@ const EDITOR_ACTIVATION_EVENT = 'backy-open-text-editor';
 export function Canvas({
   elements,
   onElementsChange,
+  onElementUpdate,
+  onElementsMutationCommit,
+  onElementsInFlightChange,
   selectedId,
   onSelect,
   size,
   onSizeChange,
+  onSizeCommit,
   isPreview = false,
 }: CanvasProps) {
   const canvasRef = useRef<HTMLDivElement>(null);
+  const elementsRef = useRef<CanvasElement[]>(elements);
+  const liveElementsRef = useRef<CanvasElement[]>(elements);
   const [editingId, setEditingId] = useState<string | null>(null);
-  const debugTextInteraction = useCallback((..._args: unknown[]) => {
-  }, []);
-
+  const textEditCommitTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
   const getTargetElement = useCallback((target: EventTarget | null) => {
     if (!target) return null;
     if (target instanceof Element) return target;
@@ -533,6 +582,38 @@ export function Canvas({
     return null;
   }, []);
 
+  const getInteractionPath = useCallback((target: EventTarget | null): Element[] => {
+    const startElement = getTargetElement(target);
+    if (!startElement) {
+      return [];
+    }
+
+    const path = startElement as Element;
+    const nodes: Element[] = [];
+    let current: Element | null = path;
+
+    while (current) {
+      nodes.push(current);
+      current = current.parentElement;
+    }
+
+    return nodes;
+  }, [getTargetElement]);
+
+  const hasClosestInInteractionPath = useCallback((nodes: Element[], selector: string): boolean => {
+    for (const node of nodes) {
+      if (node.matches(selector)) {
+        return true;
+      }
+
+      if (node.closest(selector)) {
+        return true;
+      }
+    }
+
+    return false;
+  }, []);
+
   useEffect(() => {
     if (isPreview) {
       setEditingId(null);
@@ -544,24 +625,141 @@ export function Canvas({
     }
   }, [isPreview, selectedId]);
 
-  const isInteractiveHandle = useCallback((target: EventTarget | null) => {
-    const element = getTargetElement(target);
-    if (!element) return false;
-    return !!element.closest('[data-role="canvas-resize-handle"]');
-  }, [getTargetElement]);
+  useEffect(() => {
+    if (!selectedId) {
+      if (editingId !== null) {
+        setEditingId(null);
+      }
+      return;
+    }
+
+    if (!findElementById(elementsRef.current, selectedId)) {
+      setEditingId(null);
+      return;
+    }
+
+    if (!editingId || editingId === selectedId) {
+      return;
+    }
+
+    if (!findElementById(elementsRef.current, editingId)) {
+      setEditingId(null);
+      return;
+    }
 
-  const isTextEditorInteraction = useCallback((target: EventTarget | null) => {
-    const element = getTargetElement(target);
-    if (!element) return false;
+    setEditingId(null);
+  }, [editingId, isPreview, selectedId]);
+
+  useEffect(() => {
+    elementsRef.current = elements;
+    liveElementsRef.current = elements;
+  }, [elements]);
 
-    const editorHost = element.closest('[data-backy-text-editor]');
-    if (!editorHost) {
+  const isInteractiveHandle = useCallback((target: EventTarget | null) => {
+    const nodes = getInteractionPath(target);
+    return nodes.some((node) => node.matches('[data-role="canvas-resize-handle"]') || node.closest('[data-role="canvas-resize-handle"]'));
+  }, [getInteractionPath]);
+
+  const isTextEditorSurface = useCallback((target: EventTarget | null) => {
+    const nodes = getInteractionPath(target);
+    return nodes.some((node) => hasClosestInInteractionPath([node], '[data-backy-text-editor], [role="textbox"], [data-slate-editor], [data-plate-editor], [contenteditable="true"]'));
+  }, [getInteractionPath, hasClosestInInteractionPath]);
+
+  const isCanvasInteractionTarget = useCallback((target: EventTarget | null) => {
+    const targetElement = getTargetElement(target);
+    if (!targetElement) {
       return false;
     }
 
-    return editorHost.getAttribute('data-backy-text-editor-editable') === 'true';
+    return Boolean(
+      targetElement.closest('[data-element-id]')
+      || targetElement.closest('[data-backy-text-editor]')
+      || targetElement.closest('[role="textbox"]')
+      || targetElement.closest('[contenteditable="true"]')
+      || targetElement.closest('[data-slate-editor]')
+      || targetElement.closest('[data-plate-editor]')
+      || targetElement.closest('[data-role="canvas-resize-handle"]'),
+    );
   }, [getTargetElement]);
 
+  const hasPendingTextEditRef = useRef(false);
+  const pendingTextEditElementIdRef = useRef<string | null>(null);
+
+  const clearTextEditCommitTimer = useCallback(() => {
+    if (textEditCommitTimeoutRef.current !== null) {
+      window.clearTimeout(textEditCommitTimeoutRef.current);
+      textEditCommitTimeoutRef.current = null;
+    }
+  }, []);
+
+  const finalizeTextEditDraft = useCallback(() => {
+    if (!hasPendingTextEditRef.current) {
+      return;
+    }
+
+    hasPendingTextEditRef.current = false;
+    const committedElementId = pendingTextEditElementIdRef.current;
+    pendingTextEditElementIdRef.current = null;
+    if (!onElementsMutationCommit) {
+      return;
+    }
+
+    onElementsMutationCommit(elementsRef.current, committedElementId);
+  }, [onElementsMutationCommit]);
+
+  const queueTextEditCommit = useCallback(() => {
+    clearTextEditCommitTimer();
+    textEditCommitTimeoutRef.current = window.setTimeout(() => {
+      textEditCommitTimeoutRef.current = null;
+      finalizeTextEditDraft();
+    }, 450);
+  }, [clearTextEditCommitTimer, finalizeTextEditDraft]);
+
+  const debugTextInteraction = useCallback((..._args: unknown[]) => {
+  }, []);
+
+  const handleTextElementChange = useCallback((elementId: string, updates: { [key: string]: unknown }) => {
+    const targetElement = findElementById(elementsRef.current, elementId);
+    if (!targetElement) {
+      return;
+    }
+
+    const hasChanges = Object.entries(updates).some(
+      ([key, value]) => !areValuesEquivalent(targetElement.props?.[key], value),
+    );
+    if (!hasChanges) {
+      return;
+    }
+
+    const next = updateElementById(elementsRef.current, elementId, (element) => ({
+      ...element,
+      props: {
+        ...element.props,
+        ...updates,
+      },
+    }));
+
+    if (!next.updated) {
+      return;
+    }
+
+    hasPendingTextEditRef.current = true;
+    pendingTextEditElementIdRef.current = elementId;
+    liveElementsRef.current = next.elements;
+    onElementsInFlightChange?.(next.elements, elementId);
+    queueTextEditCommit();
+  }, [onElementsInFlightChange, queueTextEditCommit]);
+
+  const handleTextElementBlur = useCallback((elementId: string) => {
+    clearTextEditCommitTimer();
+    finalizeTextEditDraft();
+  }, [clearTextEditCommitTimer, finalizeTextEditDraft]);
+
+  useEffect(() => () => {
+    clearTextEditCommitTimer();
+    finalizeTextEditDraft();
+  }, [clearTextEditCommitTimer, finalizeTextEditDraft]);
+
   const requestEditForElement = useCallback((elementId: string | null) => {
     if (!elementId || isPreview) {
       debugTextInteraction('requestEditForElement blocked', {
@@ -571,7 +769,7 @@ export function Canvas({
       return;
     }
 
-    const element = findElementById(elements, elementId);
+    const element = findElementById(elementsRef.current, elementId);
     if (!element) {
       debugTextInteraction('requestEditForElement element-missing', { elementId });
       return;
@@ -592,6 +790,10 @@ export function Canvas({
       previousEditingId: editingId,
     });
 
+    if (editingId && editingId !== elementId) {
+      finalizeTextEditDraft();
+    }
+
     onSelect(elementId);
     setEditingId((current) => (current === elementId ? current : elementId));
 
@@ -632,7 +834,7 @@ export function Canvas({
     };
 
     focusEditable();
-  }, [debugTextInteraction, elements, editingId, isPreview, onSelect]);
+  }, [debugTextInteraction, editingId, finalizeTextEditDraft, isPreview, onSelect]);
 
   const handleExternalEditRequest = useCallback((event: Event) => {
     const elementId = (event as CustomEvent<{ elementId?: string }>)?.detail?.elementId;
@@ -649,6 +851,8 @@ export function Canvas({
     initialY: number;
   } | null>(null);
 
+  const [pendingTextDrag, setPendingTextDrag] = useState<PendingTextDragState | null>(null);
+
   // Resize state for resizing elements
   const [resizeState, setResizeState] = useState<{
     elementId: string;
@@ -667,6 +871,8 @@ export function Canvas({
     initialHeight: number;
   } | null>(null);
 
+  const hasInteractiveMutationRef = useRef(false);
+
   /**
    * Handle mouse down on an element
    */
@@ -674,14 +880,16 @@ export function Canvas({
     (e: React.MouseEvent | React.PointerEvent, elementId: string) => {
       if (isPreview) return;
       if ('button' in e && e.button !== 0) return;
-
-      if (isTextEditorInteraction(e.target)) {
-        debugTextInteraction('handleMouseDown ignored for text editor interaction', {
-          elementId,
-          target: (e.target as Element | null)?.tagName,
-        });
+      if ((e as React.MouseEvent).detail >= 2) {
+        setPendingTextDrag(null);
+        setDragState(null);
+        setResizeState(null);
         return;
       }
+      if (editingId && editingId !== elementId) {
+        finalizeTextEditDraft();
+        setEditingId(null);
+      }
 
       const eventTarget = getTargetElement(e.target);
       const hitElementId = eventTarget?.closest?.('[data-element-id]')?.getAttribute('data-element-id');
@@ -691,13 +899,35 @@ export function Canvas({
         return;
       }
 
-      const clickedElement = findElementById(elements, elementId);
+      const clickedElement = findElementById(elementsRef.current, elementId);
       if (!clickedElement) return;
 
       if (isInteractiveHandle(e.target)) return;
+
+      const isTextElement = isTextEditableElement(clickedElement.type);
+      if (isTextElement) {
+        debugTextInteraction('handleMouseDown preparing text interaction', {
+          elementId,
+          x: e.clientX,
+          y: e.clientY,
+        });
+        onSelect(elementId);
+        setPendingTextDrag({
+          elementId,
+          startX: e.clientX,
+          startY: e.clientY,
+          initialX: clickedElement.x,
+          initialY: clickedElement.y,
+        });
+        hasInteractiveMutationRef.current = false;
+        setDragState(null);
+        return;
+      }
+
       debugTextInteraction('handleMouseDown started drag', { elementId, x: e.clientX, y: e.clientY });
 
       onSelect(elementId);
+      hasInteractiveMutationRef.current = false;
 
       if (editingId) {
         setEditingId(null);
@@ -711,7 +941,14 @@ export function Canvas({
         initialY: clickedElement.y,
       });
     },
-    [elements, editingId, isInteractiveHandle, isTextEditorInteraction, isPreview, onSelect]
+    [
+      editingId,
+      finalizeTextEditDraft,
+      isInteractiveHandle,
+      isTextEditableElement,
+      isPreview,
+      requestEditForElement,
+    ]
   );
 
   /**
@@ -724,9 +961,10 @@ export function Canvas({
       e.stopPropagation();
       e.preventDefault();
 
-      const element = findElementById(elements, elementId);
+      const element = findElementById(elementsRef.current, elementId);
       if (!element) return;
 
+      hasInteractiveMutationRef.current = false;
       setResizeState({
         elementId,
         handle,
@@ -738,7 +976,7 @@ export function Canvas({
         initialHeight: element.height,
       });
     },
-    [elements, isPreview]
+    [isPreview]
   );
 
   /**
@@ -747,6 +985,8 @@ export function Canvas({
   const handleMouseMove = useCallback(
     (e: React.MouseEvent) => {
       if (isPreview) return;
+      const currentElements = elementsRef.current;
+      const emitMutation = onElementsInFlightChange || onElementsChange;
 
       // Handle resize
       if (resizeState) {
@@ -788,15 +1028,30 @@ export function Canvas({
         newWidth = Math.round(newWidth / 10) * 10;
         newHeight = Math.round(newHeight / 10) * 10;
 
-        onElementsChange(
-          updateElementById(elements, resizeState.elementId, (element) => ({
-            ...element,
-            x: newX,
-            y: newY,
-            width: newWidth,
-            height: newHeight,
-          })).elements
-        );
+        const targetElement = findElementById(currentElements, resizeState.elementId);
+        if (!targetElement) {
+          return;
+        }
+
+        const hasChange =
+          targetElement.x !== newX
+          || targetElement.y !== newY
+          || targetElement.width !== newWidth
+          || targetElement.height !== newHeight;
+        if (!hasChange) {
+          return;
+        }
+
+        hasInteractiveMutationRef.current = true;
+        const nextElements = updateElementById(currentElements, resizeState.elementId, (element) => ({
+          ...element,
+          x: newX,
+          y: newY,
+          width: newWidth,
+          height: newHeight,
+        })).elements;
+        liveElementsRef.current = nextElements;
+        emitMutation(nextElements);
         return;
       }
 
@@ -812,16 +1067,73 @@ export function Canvas({
         const snappedX = Math.round(newX / 10) * 10;
         const snappedY = Math.round(newY / 10) * 10;
 
-        onElementsChange(
-          updateElementById(elements, dragState.elementId, (element) => ({
-            ...element,
-            x: snappedX,
-            y: snappedY,
-          })).elements
-        );
+        const targetElement = findElementById(currentElements, dragState.elementId);
+        if (!targetElement) {
+          return;
+        }
+
+        if (targetElement.x === snappedX && targetElement.y === snappedY) {
+          return;
+        }
+
+        hasInteractiveMutationRef.current = true;
+        const nextElements = updateElementById(currentElements, dragState.elementId, (element) => ({
+          ...element,
+          x: snappedX,
+          y: snappedY,
+        })).elements;
+        liveElementsRef.current = nextElements;
+        emitMutation(nextElements);
+
+        return;
+      }
+
+      if (!pendingTextDrag) {
+        return;
+      }
+
+      const deltaX = e.clientX - pendingTextDrag.startX;
+      const deltaY = e.clientY - pendingTextDrag.startY;
+      const shouldStartDrag = Math.abs(deltaX) >= TEXT_DRAG_START_THRESHOLD
+        || Math.abs(deltaY) >= TEXT_DRAG_START_THRESHOLD;
+      if (!shouldStartDrag) {
+        return;
+      }
+
+      const nextX = pendingTextDrag.initialX + deltaX;
+      const nextY = pendingTextDrag.initialY + deltaY;
+      const snappedX = Math.round(nextX / 10) * 10;
+      const snappedY = Math.round(nextY / 10) * 10;
+
+      const targetElement = findElementById(currentElements, pendingTextDrag.elementId);
+      if (!targetElement) {
+        setPendingTextDrag(null);
+        return;
       }
+
+      if (targetElement.x === snappedX && targetElement.y === snappedY) {
+        return;
+      }
+
+      hasInteractiveMutationRef.current = true;
+      const nextElements = updateElementById(currentElements, pendingTextDrag.elementId, (element) => ({
+        ...element,
+        x: snappedX,
+        y: snappedY,
+      })).elements;
+      liveElementsRef.current = nextElements;
+      emitMutation(nextElements);
+
+      setDragState({
+        elementId: pendingTextDrag.elementId,
+        startX: e.clientX,
+        startY: e.clientY,
+        initialX: pendingTextDrag.initialX,
+        initialY: pendingTextDrag.initialY,
+      });
+      setPendingTextDrag(null);
     },
-    [dragState, resizeState, elements, isPreview, onElementsChange]
+    [dragState, findElementById, isPreview, onElementsChange, onElementsInFlightChange, pendingTextDrag, resizeState]
   );
 
   const handleCanvasElementDrop = useCallback(
@@ -838,7 +1150,7 @@ export function Canvas({
         const toNumber = (value: number) => Math.round(Math.max(0, value / 10) * 10);
 
         if (forcedParentId) {
-          const parent = findElementById(elements, forcedParentId);
+          const parent = findElementById(elementsRef.current, forcedParentId);
           const isDropTarget = parent && canAcceptNestedDrop(parent.type);
 
           const dropHost = canvasRef.current?.querySelector<HTMLElement>(
@@ -852,7 +1164,7 @@ export function Canvas({
               toNumber(event.clientX - hostRect.left),
               toNumber(event.clientY - hostRect.top),
             );
-            const withChild = insertElementAsChild(elements, forcedParentId, child);
+            const withChild = insertElementAsChild(elementsRef.current, forcedParentId, child);
 
             if (withChild.updated) {
               onElementsChange(withChild.elements);
@@ -869,27 +1181,44 @@ export function Canvas({
           toNumber(parsedY)
         );
 
-        onElementsChange([...elements, rootElement]);
+        onElementsChange([...elementsRef.current, rootElement]);
         onSelect(rootElement.id);
       } catch (error) {
         console.error('Failed to drop element:', error);
       }
     },
-    [elements, onElementsChange, onSelect]
+    [onElementsChange, onSelect]
   );
 
   const handleElementPropsUpdate = useCallback(
     (elementId: string, updates: { [key: string]: unknown }) => {
-      const next = updateElementById(elements, elementId, (element) => ({
+      const targetElement = findElementById(elementsRef.current, elementId);
+      if (!targetElement) {
+        return;
+      }
+
+      const hasChanges = Object.entries(updates).some(
+        ([key, value]) => !areValuesEquivalent(targetElement.props?.[key], value),
+      );
+      if (!hasChanges) {
+        return;
+      }
+
+      const next = updateElementById(elementsRef.current, elementId, (element) => ({
         ...element,
         props: { ...element.props, ...updates },
       }));
 
       if (next.updated) {
+        if (onElementUpdate) {
+          onElementUpdate(elementId, next.elements);
+          return;
+        }
+
         onElementsChange(next.elements);
       }
     },
-    [elements, onElementsChange]
+    [onElementUpdate, onElementsChange]
   );
 
   /**
@@ -922,10 +1251,14 @@ export function Canvas({
   }, [canvasResizeState, onSizeChange, size]);
 
   const handleGlobalMouseUp = useCallback(() => {
+    const resized = Boolean(canvasResizeState);
     if (canvasResizeState) {
       setCanvasResizeState(null);
+      if (resized) {
+        onSizeCommit?.(size);
+      }
     }
-  }, [canvasResizeState]);
+  }, [canvasResizeState, onSizeCommit, size]);
 
   useEffect(() => {
     if (canvasResizeState) {
@@ -942,52 +1275,42 @@ export function Canvas({
    * Handle mouse up to end dragging/resizing
    */
   const handleMouseUp = useCallback(() => {
+    const didMutateInteraction = hasInteractiveMutationRef.current;
+    const isInteractiveSession = Boolean(dragState || resizeState);
     setDragState(null);
     setResizeState(null);
-  }, []);
-
-  /**
-   * Handle canvas click to deselect
-   */
-  const handleCanvasClick = useCallback((event: React.MouseEvent) => {
-    const eventTarget = getTargetElement(event.target);
-    if (isTextEditorInteraction(eventTarget)) {
-      debugTextInteraction('handleCanvasClick skipped in text editor', {
-        targetTag: (eventTarget as Element | null)?.tagName,
-      });
-      return;
-    }
-
-    if (!isPreview) {
-      onSelect(null);
-      setEditingId(null);
+    setPendingTextDrag(null);
+    hasInteractiveMutationRef.current = false;
+    if (isInteractiveSession && didMutateInteraction) {
+      onElementsMutationCommit?.(
+        liveElementsRef.current,
+        dragState?.elementId || resizeState?.elementId || pendingTextEditElementIdRef.current,
+      );
     }
-  }, [isPreview, isTextEditorInteraction, onSelect]);
+  }, [dragState, onElementsMutationCommit, pendingTextEditElementIdRef, resizeState]);
 
-  const handleCanvasDoubleClick = useCallback((event: React.MouseEvent) => {
-    const eventTarget = getTargetElement(event.target);
-    if (!eventTarget) {
+  const handleCanvasMouseDown = useCallback((event: React.MouseEvent) => {
+    if (isPreview) {
       return;
     }
 
-    const clickedId = eventTarget.closest?.('[data-element-id]')?.getAttribute('data-element-id');
-    debugTextInteraction('handleCanvasDoubleClick', { clickedId });
-    requestEditForElement(clickedId || null);
-  }, [getTargetElement, requestEditForElement]);
+    const isCanvasBackgroundClick = event.target === event.currentTarget;
+    const isCanvasElement = isCanvasInteractionTarget(event.target);
 
-  const handleDoubleClick = useCallback((elementId: string) => {
-    if (isPreview) {
-      return;
+    if (!isCanvasElement && isCanvasBackgroundClick) {
+      finalizeTextEditDraft();
+      setPendingTextDrag(null);
+      onSelect(null);
+      setEditingId(null);
     }
-
-    requestEditForElement(elementId);
-  }, [isPreview, requestEditForElement]);
+  }, [finalizeTextEditDraft, isCanvasInteractionTarget, isPreview, onSelect]);
 
   const handleCanvasKeyDown = useCallback((event: KeyboardEvent) => {
     if (event.key === 'Escape') {
+      finalizeTextEditDraft();
       setEditingId((current) => (current ? null : current));
     }
-  }, []);
+  }, [finalizeTextEditDraft]);
 
   useEffect(() => {
     window.addEventListener(EDITOR_ACTIVATION_EVENT, handleExternalEditRequest);
@@ -1023,8 +1346,7 @@ export function Canvas({
       onMouseMove={handleMouseMove}
       onMouseUp={handleMouseUp}
       onMouseLeave={handleMouseUp}
-      onClick={handleCanvasClick}
-      onDoubleClick={handleCanvasDoubleClick}
+      onMouseDown={handleCanvasMouseDown}
     >
       {/* Grid Background */}
       {!isPreview && (
@@ -1056,15 +1378,16 @@ export function Canvas({
                 elementId: element.id,
                 elementType: element.type,
               });
-              onSelect(element.id);
+        onSelect(element.id);
             }}
             onSelectElement={onSelect}
-            onUpdate={(updates) => handleElementPropsUpdate(element.id, updates)}
-            onUpdateElement={handleElementPropsUpdate}
-            onDrop={(event) => handleCanvasElementDrop(event, element.id)}
-            isEditing={editingId === element.id}
-            onStopEditing={() => setEditingId(null)}
-            onDoubleClick={() => handleDoubleClick(element.id)}
+      onUpdate={(updates) => handleElementPropsUpdate(element.id, updates)}
+      onUpdateElement={handleElementPropsUpdate}
+      onDrop={(event) => handleCanvasElementDrop(event, element.id)}
+      isEditing={editingId === element.id}
+      activeEditingId={editingId}
+      onStopEditing={() => setEditingId(null)}
+      onRequestEdit={requestEditForElement}
         />
       ))}
 
@@ -1096,6 +1419,7 @@ interface CanvasElementComponentProps {
   isSelected: boolean;
   selectedId: string | null;
   isPreview: boolean;
+  activeEditingId: string | null;
   onPointerDown: (e: React.PointerEvent, elementId?: string) => void;
   onResizeStart: (e: React.MouseEvent, handle: 'nw' | 'ne' | 'sw' | 'se') => void;
   onClick: (e: React.MouseEvent) => void;
@@ -1103,8 +1427,8 @@ interface CanvasElementComponentProps {
   onUpdate: (updates: { [key: string]: unknown }) => void;
   onUpdateElement: (elementId: string, updates: { [key: string]: unknown }) => void;
   onDrop?: (e: React.DragEvent, forcedParentId?: string) => void;
+  onRequestEdit: (elementId: string) => void;
   isEditing: boolean;
-  onDoubleClick: () => void;
   onStopEditing?: () => void;
 }
 
@@ -1120,9 +1444,10 @@ function CanvasElementComponent({
   onUpdate,
   onUpdateElement,
   onDrop,
+  onRequestEdit,
   isEditing,
-  onDoubleClick,
   onStopEditing,
+  activeEditingId,
   }: CanvasElementComponentProps) {
   const p = element.props as Record<string, any>;
   const sharedStyle = buildSharedElementStyle(element);
@@ -1138,17 +1463,18 @@ function CanvasElementComponent({
           isSelected={child.id === resolvedSelectedId}
           selectedId={resolvedSelectedId}
           isPreview={isPreview}
+          activeEditingId={activeEditingId}
           onPointerDown={(event) => onPointerDown(event, child.id)}
           onResizeStart={(event, handle) => onResizeStart(event, child.id, handle)}
           onClick={(event) => {
             event.stopPropagation();
             onSelectElement(child.id);
           }}
+          onRequestEdit={onRequestEdit}
           onUpdate={(updates) => onUpdateElement(child.id, updates)}
           onUpdateElement={onUpdateElement}
           onDrop={(event, forcedParentId) => onDrop?.(event, forcedParentId)}
-          isEditing={false}
-          onDoubleClick={() => onDoubleClick(child.id)}
+          isEditing={child.id === activeEditingId}
           onStopEditing={onStopEditing}
         />
       ))}
@@ -1175,26 +1501,30 @@ function CanvasElementComponent({
 
     switch (resolvedType) {
       case 'text':
+      case 'paragraph': {
         // V2 Hybrid: If editing, show Tiptap. Else show Preview.
         // We use Tiptap for both states to ensure WYSIWYG consistency if possible,
         // but for performance "Preview" might just be a read-only Tiptap.
+        const isParagraphType = resolvedType === 'paragraph';
 
       return (
         <div
           style={{ ...sharedStyle, width: '100%', height: '100%' }}
-          onDoubleClick={onDoubleClick}
+          onDoubleClick={() => onRequestEdit(element.id)}
           onMouseDown={(e) => {
             if (isEditing) e.stopPropagation();
-          }}
-        >
+            }}
+            >
             <RichTextBlock
               key={`text-${element.id}`}
               elementId={element.id}
               content={p.content}
-              onChange={(val) => onUpdate({ content: val })}
+              onChange={(val) => handleTextElementChange(element.id, { content: cloneNodePayload(val) })}
+              onBlur={() => handleTextElementBlur(element.id)}
               isEditable={isEditing && !isPreview}
               className="w-full h-full"
-              placeholder="Type '/' for commands..."
+              defaultType={isParagraphType ? 'p' : undefined}
+              placeholder={isParagraphType ? 'Paragraph...' : "Type '/' for commands..."}
               style={{
                 ...sharedStyle,
                 fontFamily: p.fontFamily || sharedStyle.fontFamily || 'inherit',
@@ -1207,12 +1537,13 @@ function CanvasElementComponent({
             />
           </div>
         );
+      }
 
       case 'heading':
       return (
         <div
           style={{ ...sharedStyle, width: '100%', height: '100%' }}
-          onDoubleClick={onDoubleClick}
+          onDoubleClick={() => onRequestEdit(element.id)}
           onMouseDown={(e) => {
             if (isEditing) e.stopPropagation();
           }}
@@ -1221,7 +1552,8 @@ function CanvasElementComponent({
             key={`heading-${element.id}`}
             elementId={element.id}
             content={p.content}
-            onChange={(val) => onUpdate({ content: val })}
+            onChange={(val) => handleTextElementChange(element.id, { content: cloneNodePayload(val) })}
+            onBlur={() => handleTextElementBlur(element.id)}
               isEditable={isEditing && !isPreview}
               className="w-full h-full"
               defaultType={p.level || 'h2'}
@@ -1568,8 +1900,8 @@ function CanvasElementComponent({
                 }}
               >
                 {selectOptions.length ? (
-                  selectOptions.map((option) => (
-                    <option key={option} value={option}>
+                  selectOptions.map((option, optionIndex) => (
+                    <option key={`${element.id}-${optionIndex}-${option}`} value={option}>
                       {option}
                     </option>
                   ))
@@ -1729,7 +2061,7 @@ function CanvasElementComponent({
         return (
           <div
             style={{ ...sharedStyle, width: '100%', height: '100%' }}
-            onDoubleClick={onDoubleClick}
+            onDoubleClick={() => onRequestEdit(element.id)}
             onMouseDown={(e) => {
               if (isEditing) e.stopPropagation();
             }}
@@ -1738,13 +2070,12 @@ function CanvasElementComponent({
               key={`list-${element.id}`}
               elementId={element.id}
               content={listValue}
-              onChange={(val) =>
-                onUpdate({
-                  content: val,
-                  items: extractListItemsFromSlate(val),
-                  listType: listType || getListTypeFromSlate(val),
-                })
-              }
+              onChange={(val) => handleTextElementChange(element.id, {
+                content: cloneNodePayload(val),
+                items: extractListItemsFromSlate(val),
+                listType: listType || getListTypeFromSlate(val),
+              })}
+              onBlur={() => handleTextElementBlur(element.id)}
               isEditable={isEditing && !isPreview}
               className="w-full h-full"
               defaultType={listType === 'number' ? 'ol' : 'ul'}
@@ -1772,7 +2103,7 @@ function CanvasElementComponent({
         return (
         <div
             style={{ ...sharedStyle, width: '100%', height: '100%' }}
-            onDoubleClick={onDoubleClick}
+            onDoubleClick={() => onRequestEdit(element.id)}
             onMouseDown={(e) => {
               if (isEditing) e.stopPropagation();
             }}
@@ -1781,7 +2112,8 @@ function CanvasElementComponent({
               key={`quote-${element.id}`}
               elementId={element.id}
               content={p.content}
-              onChange={(val) => onUpdate({ content: val })}
+              onChange={(val) => handleTextElementChange(element.id, { content: cloneNodePayload(val) })}
+              onBlur={() => handleTextElementBlur(element.id)}
               isEditable={isEditing && !isPreview}
               className="w-full h-full"
               defaultType="blockquote"
@@ -2101,37 +2433,6 @@ function CanvasElementComponent({
         );
       }
 
-      case 'paragraph':
-      return (
-        <div
-          style={{ ...sharedStyle, width: '100%', height: '100%' }}
-          onDoubleClick={onDoubleClick}
-          onMouseDown={(e) => {
-            if (isEditing) e.stopPropagation();
-          }}
-        >
-            <RichTextBlock
-              key={`paragraph-${element.id}`}
-              elementId={element.id}
-              content={p.content}
-              onChange={(val) => onUpdate({ content: val })}
-              isEditable={isEditing && !isPreview}
-              className="w-full h-full"
-              defaultType="p"
-              style={{
-                ...sharedStyle,
-                fontFamily: p.fontFamily || sharedStyle.fontFamily || 'inherit',
-                fontSize: p.fontSize ?? sharedStyle.fontSize ?? 16,
-                fontWeight: p.fontWeight ?? sharedStyle.fontWeight ?? 'normal',
-                color: p.color ?? sharedStyle.color ?? '#374151',
-                lineHeight: p.lineHeight ?? sharedStyle.lineHeight ?? 1.6,
-                textAlign: p.textAlign || sharedStyle.textAlign || 'left',
-              }}
-              placeholder="Paragraph..."
-            />
-          </div>
-        );
-
       case 'icon':
         return (
           <div
@@ -2252,10 +2553,10 @@ function CanvasElementComponent({
 
   return (
       <div
-      className={cn(
-        'absolute',
-        !isPreview && !isEditing && 'cursor-move select-none',
-        isSelected && !isPreview && 'ring-2 ring-primary ring-offset-2'
+        className={cn(
+          'absolute',
+          !isPreview && !isEditing && 'cursor-move select-none',
+          isSelected && !isPreview && 'ring-2 ring-primary ring-offset-2'
       )}
       data-element-id={element.id}
       data-backy-text-editor={isTextElement ? 'true' : undefined}
@@ -2272,13 +2573,21 @@ function CanvasElementComponent({
         opacity: sharedStyle.opacity ?? 1,
       }}
       onPointerDownCapture={(event) => {
-        if (isEditing && isTextElement) {
+        if (isEditing && isTextElement && isTextEditorSurface(event.target)) {
           return;
         }
         onPointerDown(event, element.id);
       }}
+      onDoubleClick={(event) => {
+        if (!isPreview && isTextElement) {
+          if (isEditing) {
+            return;
+          }
+          event.stopPropagation();
+          onRequestEdit(element.id);
+        }
+      }}
       onClick={onClick}
-      onDoubleClick={onDoubleClick}
     >
       {renderContent()}
 
diff --git a/apps/admin/src/components/editor/CanvasEditor.tsx b/apps/admin/src/components/editor/CanvasEditor.tsx
index c60c242..be4cc70 100644
--- a/apps/admin/src/components/editor/CanvasEditor.tsx
+++ b/apps/admin/src/components/editor/CanvasEditor.tsx
@@ -76,6 +76,22 @@ const KNOWN_CANVAS_ELEMENT_TYPES: CanvasElement['type'][] = [
   'comment',
 ];
 
+const MAX_HISTORY_LENGTH = 50;
+const TEXT_ELEMENT_TYPES: CanvasElement['type'][] = ['text', 'heading', 'paragraph', 'quote', 'list'];
+const ROOT_ELEMENT_KEYS: ReadonlySet<keyof CanvasElement | 'styles' | 'props'> = new Set([
+  'id',
+  'type',
+  'x',
+  'y',
+  'width',
+  'height',
+  'rotation',
+  'zIndex',
+  'children',
+  'styles',
+  'props',
+]);
+
 export interface CanvasEditorProps {
   initialElements: CanvasElement[];
   initialSettings: PageSettings;
@@ -84,7 +100,7 @@ export interface CanvasEditorProps {
     elements: CanvasElement[],
     settings: PageSettings,
     size?: CanvasSize
-  ) => Promise<void> | void;
+  ) => Promise<boolean | void> | boolean | void;
   onBack?: () => void;
   className?: string;
   hideNavigation?: boolean;
@@ -97,13 +113,29 @@ export interface CanvasEditorProps {
     settings: PageSettings,
     size?: CanvasSize
   ) => void;
+  onReload?: () => Promise<void> | void;
+  readOnly?: boolean;
+}
+
+interface CanvasHistoryState {
+  elements: CanvasElement[];
+  selectedId: string | null;
+  size: CanvasSize;
+  pageSettings: PageSettings;
+}
+
+interface RemoveElementResult {
+  elements: CanvasElement[];
+  updated: boolean;
+  removedParentId?: string | null;
+  nextSelectedId?: string | null;
 }
 
 const normalizeTypeToken = (value: string): string => {
   return typeof value === 'string' ? value.trim().toLowerCase().replace(/[^a-z0-9]+/g, '') : '';
 };
 
-const normalizeElementType = (value: string): CanvasElement['type'] => {
+  const normalizeElementType = (value: string): CanvasElement['type'] => {
   const normalized = normalizeTypeToken(value);
 
   if (!normalized) {
@@ -183,6 +215,33 @@ const normalizeElementType = (value: string): CanvasElement['type'] => {
     : 'text';
 };
 
+const normalizeForComparison = (value: unknown): unknown => {
+  if (value === null || value === undefined) {
+    return value;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map((item) => normalizeForComparison(item));
+  }
+
+  if (typeof value === 'object') {
+    const record = value as Record<string, unknown>;
+    const keys = Object.keys(record).sort();
+    return keys.reduce<Record<string, unknown>>((acc, key) => {
+      acc[key] = normalizeForComparison(record[key]);
+      return acc;
+    }, {});
+  }
+
+  return value;
+};
+
+const stableStringify = (value: unknown): string => JSON.stringify(normalizeForComparison(value));
+
+const areValuesEquivalent = (left: unknown, right: unknown): boolean => (
+  stableStringify(left) === stableStringify(right)
+);
+
 // ============================================
 // COMPONENT
 // ============================================
@@ -200,6 +259,8 @@ export function CanvasEditor({
   initialSize,
   mediaContext,
   onChange,
+  onReload,
+  readOnly = false,
 }: CanvasEditorProps) {
   const media = useStore((state) => state.media);
   const fontOptions = useMemo(() => getFontFamilyOptions(media), [media]);
@@ -238,23 +299,46 @@ export function CanvasEditor({
   // Canvas state
   const [elements, setElements] = useState<CanvasElement[]>(initialElements);
   const [selectedId, setSelectedId] = useState<string | null>(null);
+  const selectedIdRef = useRef<string | null>(null);
+  const elementsRef = useRef<CanvasElement[]>(elements);
+  const getActiveSelectedId = useCallback(() => selectedIdRef.current, []);
+
+  const setCurrentSelection = useCallback((nextSelectedId: string | null) => {
+    if (selectedIdRef.current === nextSelectedId) {
+      return;
+    }
+
+    selectedIdRef.current = nextSelectedId;
+    setSelectedId(nextSelectedId);
+  }, []);
+
   const [size, setSize] = useState<CanvasSize>(initialSize || DEFAULT_CANVAS_SIZE);
+  const sizeRef = useRef<CanvasSize>(size);
   const [breakpoint, setBreakpoint] = useState<'desktop' | 'tablet' | 'mobile'>('desktop');
   const [isPreview, setIsPreview] = useState(false);
   const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
   const [isSaving, setIsSaving] = useState(false);
   const autosaveTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
   const changeSequenceRef = useRef(0);
+  const persistedHistoryIndexRef = useRef(0);
+  const historyIndexRef = useRef(0);
 
   // Undo/Redo State
-  const [history, setHistory] = useState<Array<{ elements: CanvasElement[]; selectedId: string | null }>>([
-    { elements: initialElements, selectedId: null },
+  const [history, setHistory] = useState<CanvasHistoryState[]>([
+    {
+      elements: initialElements,
+      selectedId: null,
+      size: initialSize || DEFAULT_CANVAS_SIZE,
+      pageSettings: initialSettings,
+    },
   ]);
   const [historyIndex, setHistoryIndex] = useState(0);
+  const historyRef = useRef<CanvasHistoryState[]>(history);
 
   // Settings State
   const [isSettingsOpen, setIsSettingsOpen] = useState(false);
   const [pageSettings, setPageSettings] = useState<PageSettings>(initialSettings);
+  const pageSettingsRef = useRef<PageSettings>(initialSettings);
 
   // Clipboard State
   const [clipboardElement, setClipboardElement] = useState<CanvasElement | null>(
@@ -262,6 +346,13 @@ export function CanvasEditor({
   );
   const [canvasScale, setCanvasScale] = useState(1);
   const canvasViewportRef = useRef<HTMLDivElement>(null);
+  const isReadOnly = Boolean(readOnly);
+  const isMutating = isReadOnly;
+  const [hasUncommittedInteraction, setHasUncommittedInteraction] = useState(false);
+  const hasPendingElementMutationRef = useRef(false);
+  const hasPendingCanvasResizeRef = useRef(false);
+  const hasInFlightMutationRef = useRef(false);
+  const pendingElementsRef = useRef<CanvasElement[]>(elements);
 
   const canAcceptNestedDrop = (elementType: CanvasElement['type']): boolean => {
     const normalizedType = normalizeElementType(elementType);
@@ -280,11 +371,83 @@ export function CanvasEditor({
     JSON.parse(JSON.stringify(nodes)) as CanvasElement[]
   ), []);
 
+  const cloneNodeWithNewIds = useCallback((node: CanvasElement, offsetX = 0, offsetY = 0): CanvasElement => {
+    const next = cloneElements([node])[0];
+    const remapNode = (item: CanvasElement, isRoot: boolean): CanvasElement => {
+      const remapped: CanvasElement = {
+        ...item,
+        id: generateId(),
+        type: normalizeElementType(item.type),
+        children: item.children?.map((child) => remapNode(child, false)),
+        x: isRoot ? item.x + offsetX : item.x,
+        y: isRoot ? item.y + offsetY : item.y,
+      };
+
+      return remapped;
+    };
+
+    return remapNode(next, true);
+  }, [cloneElements]);
+
+  const clonePageSettings = useCallback((settings: PageSettings): PageSettings => (
+    JSON.parse(JSON.stringify(settings)) as PageSettings
+  ), []);
+
+  const createHistoryState = useCallback((
+    snapshotElements: CanvasElement[],
+    snapshotSize: CanvasSize,
+    snapshotSettings: PageSettings,
+    snapshotSelectedId: string | null = null,
+  ): CanvasHistoryState => ({
+    elements: cloneElements(snapshotElements),
+    size: { ...snapshotSize },
+    pageSettings: clonePageSettings(snapshotSettings),
+    selectedId: snapshotSelectedId,
+  }), [cloneElements, clonePageSettings]);
+
   const getInitialElements = useCallback(() => cloneElements(initialElements), [cloneElements, initialElements]);
 
-  const getInitialSettings = useCallback(() => (
-    JSON.parse(JSON.stringify(initialSettings)) as PageSettings
-  ), [initialSettings]);
+  const getInitialSettings = useCallback(() => clonePageSettings(initialSettings), [clonePageSettings, initialSettings]);
+  const getInitialSize = useCallback(() => ({ ...(initialSize || DEFAULT_CANVAS_SIZE) }), [initialSize]);
+
+  const areHistoryStatesEquivalent = useCallback((
+    left: CanvasHistoryState,
+    right: CanvasHistoryState,
+  ): boolean => (
+    left.size.width === right.size.width
+    && left.size.height === right.size.height
+    && stableStringify(left.pageSettings) === stableStringify(right.pageSettings)
+    && stableStringify(left.elements) === stableStringify(right.elements)
+  ), []);
+
+  const areCanvasElementsEquivalent = useCallback((
+    left: CanvasElement[],
+    right: CanvasElement[],
+  ): boolean => stableStringify(left) === stableStringify(right), []);
+
+  const setDirtyStateFromHistoryIndex = useCallback((nextIndex: number) => {
+    setHasUnsavedChanges(nextIndex !== persistedHistoryIndexRef.current);
+  }, []);
+
+  const initialStateFingerprintRef = useRef('');
+
+  const buildInitialFingerprint = useCallback(() => {
+    const nextElements = getInitialElements();
+    const nextSettings = getInitialSettings();
+    const nextSize = getInitialSize();
+
+    return stableStringify({
+      elements: nextElements,
+      settings: nextSettings,
+      size: nextSize,
+    });
+  }, [getInitialElements, getInitialSettings, getInitialSize]);
+
+  const buildCurrentFingerprint = useCallback(() => stableStringify({
+    elements,
+    settings: pageSettings,
+    size,
+  }), [elements, pageSettings, size]);
 
   const markChanges = useCallback(() => {
     changeSequenceRef.current += 1;
@@ -315,6 +478,120 @@ export function CanvasEditor({
     return null;
   }, []);
 
+  const resolveSelectionForExactMatch = useCallback((
+    nodes: CanvasElement[],
+    selectedSnapshot: string | null,
+  ): string | null => (
+    selectedSnapshot && findElementById(nodes, selectedSnapshot)
+      ? selectedSnapshot
+      : null
+  ), [findElementById]);
+
+  const resolveSelectionWithHistoryFallback = useCallback((
+    nodes: CanvasElement[],
+    preferredSelectedId: string | null,
+  ): string | null => {
+    const exact = resolveSelectionForExactMatch(nodes, preferredSelectedId);
+    if (exact) {
+      return exact;
+    }
+
+    const currentHistoryIndex = Math.min(
+      Math.max(historyIndexRef.current, 0),
+      Math.max(historyRef.current.length - 1, 0),
+    );
+    const historySelectedId = historyRef.current[currentHistoryIndex]?.selectedId || null;
+    return resolveSelectionForExactMatch(nodes, historySelectedId);
+  }, [historyRef, historyIndexRef, resolveSelectionForExactMatch]);
+
+  const resolveSelectionForUpdate = useCallback((
+    nodes: CanvasElement[],
+    preferredSelectedId: string | null,
+  ): string | null => {
+    const exactMatch = resolveSelectionForExactMatch(nodes, preferredSelectedId);
+    if (exactMatch) {
+      return exactMatch;
+    }
+
+    if (selectedIdRef.current === null) {
+      return null;
+    }
+
+    return resolveSelectionForExactMatch(nodes, selectedIdRef.current);
+  }, [resolveSelectionForExactMatch, selectedIdRef]);
+
+  const resolveSelectionForLiveMutation = useCallback((
+    nodes: CanvasElement[],
+    preferredSelectedId: string | null,
+  ): string | null => {
+    const exactMatch = resolveSelectionForExactMatch(nodes, preferredSelectedId);
+    if (exactMatch) {
+      return exactMatch;
+    }
+
+    return resolveSelectionForExactMatch(nodes, selectedIdRef.current);
+  }, [resolveSelectionForExactMatch, selectedIdRef]);
+
+  const resolveSelectionOrFallback = useCallback((
+    nodes: CanvasElement[],
+    preferredSelectedId: string | null,
+  ): string | null => (
+    resolveSelectionForExactMatch(nodes, preferredSelectedId)
+  ), [resolveSelectionForExactMatch]);
+
+  const insertElementAfterId = useCallback((nodes: CanvasElement[], targetId: string, node: CanvasElement): {
+    elements: CanvasElement[];
+    updated: boolean;
+  } => {
+    const walk = (items: CanvasElement[]): {
+      elements: CanvasElement[];
+      updated: boolean;
+    } => {
+      const next: CanvasElement[] = [];
+
+      for (let index = 0; index < items.length; index += 1) {
+        const current = items[index];
+        if (current.id === targetId) {
+          next.push(current);
+          next.push(node);
+          next.push(...items.slice(index + 1));
+          return {
+            elements: next,
+            updated: true,
+          };
+        }
+
+        if (!current.children?.length) {
+          next.push(current);
+          continue;
+        }
+
+        const childResult = walk(current.children);
+        if (!childResult.updated) {
+          next.push(current);
+          continue;
+        }
+
+        next.push({
+          ...current,
+          children: childResult.elements,
+        });
+        next.push(...items.slice(index + 1));
+        return {
+          elements: next,
+          updated: true,
+        };
+      }
+
+      return {
+        elements: items,
+        updated: false,
+      };
+    };
+
+    return walk(nodes);
+  }, []);
+
   const updateElementById = (
     items: CanvasElement[],
     targetId: string,
@@ -385,19 +662,22 @@ export function CanvasEditor({
   const removeElementById = (
     items: CanvasElement[],
     targetId: string,
-  ): { elements: CanvasElement[]; updated: boolean; removedParentId?: string | null } => {
+  ): RemoveElementResult => {
     const walk = (nodes: CanvasElement[], parentId: string | null): {
       elements: CanvasElement[];
       updated: boolean;
       removedParentId?: string | null;
+      nextSelectedId?: string | null;
     } => {
       let updated = false;
       let removedParentId: string | null | undefined;
+      let nextSelectedId: string | null | undefined;
 
-      const next = nodes.reduce<CanvasElement[]>((acc, item) => {
+      const next = nodes.reduce<CanvasElement[]>((acc, item, index) => {
         if (item.id === targetId) {
           updated = true;
           removedParentId = parentId;
+          nextSelectedId = nodes[index + 1]?.id || nodes[index - 1]?.id || parentId || null;
           return acc;
         }
 
@@ -413,7 +693,8 @@ export function CanvasEditor({
         }
 
         updated = true;
-        removedParentId = childResult.removedParentId ?? parentId;
+        removedParentId = childResult.removedParentId ?? removedParentId;
+        nextSelectedId = childResult.nextSelectedId ?? nextSelectedId ?? item.id;
         acc.push({
           ...item,
           children: childResult.elements,
@@ -421,20 +702,165 @@ export function CanvasEditor({
         return acc;
       }, []);
 
-      return { elements: next, updated, removedParentId };
+      return {
+        elements: next,
+        updated,
+        removedParentId,
+        nextSelectedId,
+      };
     };
 
     const removed = walk(items, null);
     if (!removed.updated) {
-      return { ...removed, removedParentId: undefined };
+      return {
+        elements: removed.elements,
+        updated: false,
+        removedParentId: removed.removedParentId,
+        nextSelectedId: removed.nextSelectedId,
+      };
     }
 
     return {
-      ...removed,
-      removedParentId: removed.removedParentId === null ? null : removed.removedParentId,
+      elements: removed.elements,
+      updated: true,
+      removedParentId: removed.removedParentId === undefined ? null : removed.removedParentId,
+      nextSelectedId: removed.nextSelectedId === undefined ? null : removed.nextSelectedId,
     };
   };
 
+  const resetFromInitialState = useCallback(() => {
+    if (hasUnsavedChanges) {
+      return;
+    }
+
+    const nextElements = getInitialElements();
+    const nextSettings = getInitialSettings();
+    const nextSize = getInitialSize();
+    const nextFingerprint = buildInitialFingerprint();
+
+    if (nextFingerprint === buildCurrentFingerprint()) {
+      initialStateFingerprintRef.current = nextFingerprint;
+      return;
+    }
+
+    if (initialStateFingerprintRef.current === nextFingerprint) {
+      return;
+    }
+    initialStateFingerprintRef.current = nextFingerprint;
+    const nextSelectedId = resolveSelectionOrFallback(
+      nextElements,
+      selectedIdRef.current,
+    );
+    const nextHistoryState = createHistoryState(
+      nextElements,
+      nextSize,
+      nextSettings,
+      nextSelectedId,
+    );
+    const targetHistoryIndex = Math.min(
+      Math.max(historyIndexRef.current, 0),
+      Math.max(historyRef.current.length - 1, 0),
+    );
+    const currentHistoryState = historyRef.current[targetHistoryIndex];
+    if (
+      currentHistoryState
+      && areHistoryStatesEquivalent(currentHistoryState, nextHistoryState)
+      && currentHistoryState.selectedId === nextHistoryState.selectedId
+    ) {
+      setElements(nextElements);
+      setPageSettings(nextSettings);
+      setSize(nextSize);
+      setCurrentSelection(nextSelectedId);
+      setClipboardElement(null);
+      setHistoryIndex(targetHistoryIndex);
+      historyIndexRef.current = targetHistoryIndex;
+      persistedHistoryIndexRef.current = targetHistoryIndex;
+      setDirtyStateFromHistoryIndex(targetHistoryIndex);
+      hasPendingElementMutationRef.current = false;
+      hasPendingCanvasResizeRef.current = false;
+      hasInFlightMutationRef.current = false;
+      setHasUncommittedInteraction(false);
+      setHasUnsavedChanges(false);
+      setIsSaving(false);
+      return;
+    }
+
+    setElements(nextElements);
+    setPageSettings(nextSettings);
+    setSize(nextSize);
+    setBreakpoint('desktop');
+    setCurrentSelection(nextSelectedId);
+    setClipboardElement(null);
+    setHistory((prev) => {
+      if (prev.length === 0) {
+        return [nextHistoryState];
+      }
+
+      if (targetHistoryIndex >= prev.length) {
+        return [...prev, nextHistoryState];
+      }
+
+      const nextHistory = prev.slice(0, targetHistoryIndex + 1);
+      const existing = nextHistory[targetHistoryIndex];
+      if (
+        existing
+        && areHistoryStatesEquivalent(existing, nextHistoryState)
+        && existing.selectedId === nextHistoryState.selectedId
+      ) {
+        nextHistory[targetHistoryIndex] = nextHistoryState;
+        return nextHistory;
+      }
+
+      nextHistory[targetHistoryIndex] = nextHistoryState;
+      return nextHistory;
+    });
+    setHistoryIndex(targetHistoryIndex);
+    historyIndexRef.current = targetHistoryIndex;
+    persistedHistoryIndexRef.current = targetHistoryIndex;
+    setDirtyStateFromHistoryIndex(targetHistoryIndex);
+    hasPendingElementMutationRef.current = false;
+    hasPendingCanvasResizeRef.current = false;
+    hasInFlightMutationRef.current = false;
+    setHasUnsavedChanges(false);
+    setIsSaving(false);
+  }, [
+    buildInitialFingerprint,
+    buildCurrentFingerprint,
+    createHistoryState,
+    hasUnsavedChanges,
+    historyIndexRef,
+    areHistoryStatesEquivalent,
+    setCurrentSelection,
+    setDirtyStateFromHistoryIndex,
+    resolveSelectionOrFallback,
+    selectedIdRef,
+  ]);
+
+  useEffect(() => {
+    resetFromInitialState();
+  }, [resetFromInitialState]);
+
+  useEffect(() => {
+    historyIndexRef.current = historyIndex;
+  }, [historyIndex]);
+
+  useEffect(() => {
+    historyRef.current = history;
+  }, [history]);
+
+  useEffect(() => {
+    elementsRef.current = elements;
+    pendingElementsRef.current = elements;
+  }, [elements]);
+
+  useEffect(() => {
+    sizeRef.current = size;
+  }, [size]);
+
+  useEffect(() => {
+    pageSettingsRef.current = pageSettings;
+  }, [pageSettings]);
+
   // Sync changes to parent
   useEffect(() => {
     if (onChange) {
@@ -442,6 +868,10 @@ export function CanvasEditor({
     }
   }, [elements, pageSettings, onChange, size]);
 
+  useEffect(() => {
+    selectedIdRef.current = selectedId;
+  }, [selectedId]);
+
   useEffect(() => {
     if (!hasUnsavedChanges) {
       return;
@@ -462,177 +892,482 @@ export function CanvasEditor({
       return;
     }
 
-    if (!findElementById(elements, selectedId)) {
-      setSelectedId(null);
+    const nextSelectedId = resolveSelectionOrFallback(elements, selectedId);
+    if (nextSelectedId !== selectedId) {
+      setCurrentSelection(nextSelectedId);
     }
-  }, [elements, selectedId, findElementById]);
+  }, [elements, resolveSelectionOrFallback, selectedId, setCurrentSelection]);
 
   /**
    * Add current state to history
    */
-  const addToHistory = useCallback((newElements: CanvasElement[], selectedSnapshot: string | null = selectedId) => {
-    const newHistory = history.slice(0, historyIndex + 1);
-    newHistory.push({
-      elements: newElements,
-      selectedId: selectedSnapshot,
-    });
+  const addToHistory = useCallback((
+    newElements: CanvasElement[],
+    selectedSnapshot: string | null | undefined = undefined,
+    nextSize: CanvasSize = sizeRef.current,
+    nextSettings: PageSettings = pageSettingsRef.current,
+  ): boolean => {
+    const nextSelectedSnapshot = selectedSnapshot === undefined
+      ? getActiveSelectedId()
+      : selectedSnapshot;
+    const normalizedSelectedId = resolveSelectionForExactMatch(newElements, nextSelectedSnapshot);
+    const nextState = createHistoryState(
+      newElements,
+      nextSize,
+      nextSettings,
+      normalizedSelectedId,
+    );
+
+    const prevHistory = historyRef.current;
+    const baseIndex = Math.min(Math.max(historyIndexRef.current, 0), prevHistory.length - 1);
+    const nextHistory = prevHistory.slice(0, baseIndex + 1);
+    const previousState = nextHistory[baseIndex];
+
+    if (previousState && areHistoryStatesEquivalent(previousState, nextState)) {
+      return false;
+    }
 
-    // Limit history size to 50
-    if (newHistory.length > 50) {
-      newHistory.shift();
+    const isBranchNavigation = baseIndex < prevHistory.length - 1;
+    const hasPersistedHistory = persistedHistoryIndexRef.current >= 0;
+    if (isBranchNavigation && hasPersistedHistory && persistedHistoryIndexRef.current > baseIndex) {
+      persistedHistoryIndexRef.current = -1;
     }
 
-    setHistory(newHistory);
-    // Since we just sliced and pushed, the index is the last one
-    setHistoryIndex(newHistory.length - 1);
-  }, [history, historyIndex, selectedId]);
+    nextHistory.push(nextState);
+
+    if (nextHistory.length > MAX_HISTORY_LENGTH) {
+      nextHistory.shift();
+      if (persistedHistoryIndexRef.current > 0) {
+        persistedHistoryIndexRef.current -= 1;
+      }
+    }
+
+    const nextIndex = nextHistory.length - 1;
+    historyRef.current = nextHistory;
+    historyIndexRef.current = nextIndex;
+    setHistory(nextHistory);
+    setHistoryIndex(nextIndex);
+    setHasUnsavedChanges(nextIndex !== persistedHistoryIndexRef.current);
+
+    return true;
+  }, [areHistoryStatesEquivalent, createHistoryState, getActiveSelectedId, resolveSelectionForExactMatch]);
+
+  const applyHistoryState = useCallback((nextIndex: number) => {
+    const targetState = historyRef.current[nextIndex];
+    if (!targetState) {
+      return;
+    }
+
+    setElements(targetState.elements);
+    setSize(targetState.size);
+    setPageSettings(targetState.pageSettings);
+    const nextSelectedId = resolveSelectionOrFallback(
+      targetState.elements,
+      targetState.selectedId,
+    );
+    setCurrentSelection(nextSelectedId);
+    hasPendingElementMutationRef.current = false;
+    hasPendingCanvasResizeRef.current = false;
+    hasInFlightMutationRef.current = false;
+    setHasUncommittedInteraction(false);
+    setHistoryIndex(nextIndex);
+    historyIndexRef.current = nextIndex;
+    setDirtyStateFromHistoryIndex(nextIndex);
+  }, [resolveSelectionOrFallback, setCurrentSelection, setDirtyStateFromHistoryIndex]);
+
+  const flushPendingInteractionHistory = useCallback(() => {
+    if (!hasPendingElementMutationRef.current && !hasPendingCanvasResizeRef.current) {
+      return false;
+    }
+
+    const resolvedSelectedId = resolveSelectionWithHistoryFallback(
+      pendingElementsRef.current,
+      getActiveSelectedId(),
+    );
+    const didPushHistory = addToHistory(
+      pendingElementsRef.current,
+      resolvedSelectedId,
+      sizeRef.current,
+      pageSettingsRef.current,
+    );
+    if (didPushHistory) {
+      markChanges();
+    }
+
+    hasPendingElementMutationRef.current = false;
+    hasPendingCanvasResizeRef.current = false;
+    setHasUncommittedInteraction(false);
+
+    if (!didPushHistory) {
+      setDirtyStateFromHistoryIndex(historyIndexRef.current);
+    }
+
+    return didPushHistory;
+  }, [addToHistory, getActiveSelectedId, markChanges, resolveSelectionWithHistoryFallback, setDirtyStateFromHistoryIndex]);
 
   /**
    * Undo
    */
   const handleUndo = useCallback(() => {
-    if (historyIndex > 0) {
-      const newIndex = historyIndex - 1;
-      const targetState = history[newIndex];
-      setHistoryIndex(newIndex);
-      setElements(targetState.elements);
-      setSelectedId(
-        targetState.selectedId && findElementById(targetState.elements, targetState.selectedId)
-          ? targetState.selectedId
-          : null
-      );
-      markChanges();
+    if (isMutating) {
+      return;
     }
-  }, [findElementById, history, historyIndex, markChanges]);
+
+    flushPendingInteractionHistory();
+    const targetIndex = historyIndexRef.current - 1;
+    if (targetIndex < 0) {
+      return;
+    }
+
+    applyHistoryState(targetIndex);
+  }, [applyHistoryState, flushPendingInteractionHistory, isMutating]);
 
   /**
    * Redo
    */
   const handleRedo = useCallback(() => {
-    if (historyIndex < history.length - 1) {
-      const newIndex = historyIndex + 1;
-      const targetState = history[newIndex];
-      setHistoryIndex(newIndex);
-      setElements(targetState.elements);
-      setSelectedId(
-        targetState.selectedId && findElementById(targetState.elements, targetState.selectedId)
-          ? targetState.selectedId
-          : null
-      );
-      markChanges();
+    if (isMutating) {
+      return;
+    }
+
+    flushPendingInteractionHistory();
+    const targetIndex = historyIndexRef.current + 1;
+    const maxIndex = historyRef.current.length - 1;
+    if (targetIndex > maxIndex) {
+      return;
     }
-  }, [findElementById, history, historyIndex, markChanges]);
+
+    applyHistoryState(targetIndex);
+  }, [applyHistoryState, flushPendingInteractionHistory, isMutating]);
 
   /**
    * Wrapper for updating elements with history
    */
-  const updateElementsWithHistory = useCallback((newElements: CanvasElement[], selectedSnapshot: string | null = selectedId) => {
+  const updateElementsWithHistory = useCallback((
+    newElements: CanvasElement[],
+    selectedSnapshot?: string | null,
+    forceSelectionId?: string | null,
+    forceHistory = false,
+  ) => {
+    if (isMutating) {
+      return;
+    }
+
+    if (hasPendingElementMutationRef.current || hasPendingCanvasResizeRef.current) {
+      flushPendingInteractionHistory();
+    }
+
+    const nextSelectionCandidate = forceSelectionId !== undefined
+      ? forceSelectionId
+      : selectedSnapshot;
+    const normalizedSelection = nextSelectionCandidate === undefined
+      ? getActiveSelectedId()
+      : nextSelectionCandidate;
+    const resolvedSelection = resolveSelectionForUpdate(newElements, normalizedSelection);
+
+    if (!forceHistory && areCanvasElementsEquivalent(elementsRef.current, newElements)) {
+      if (resolvedSelection !== selectedIdRef.current) {
+        setCurrentSelection(resolvedSelection);
+      }
+      return;
+    }
+
+    if (resolvedSelection !== selectedIdRef.current) {
+      setCurrentSelection(resolvedSelection);
+    }
+
     setElements(newElements);
-    addToHistory(newElements, selectedSnapshot);
-    markChanges();
-  }, [addToHistory, markChanges, selectedId]);
+    const didPushHistory = addToHistory(newElements, resolvedSelection, sizeRef.current, pageSettingsRef.current);
+    if (didPushHistory) {
+      setHasUncommittedInteraction(false);
+    }
+    if (didPushHistory) {
+      markChanges();
+    }
+  }, [
+    addToHistory,
+    areCanvasElementsEquivalent,
+    flushPendingInteractionHistory,
+    getActiveSelectedId,
+    isMutating,
+    markChanges,
+    setCurrentSelection,
+    resolveSelectionForUpdate,
+  ]);
+
+  const handleElementsMutationCommit = useCallback((nextElements: CanvasElement[], preferredSelectedId?: string | null) => {
+    if (isMutating) {
+      return;
+    }
+
+    const committedElements = areCanvasElementsEquivalent(nextElements, pendingElementsRef.current)
+      ? pendingElementsRef.current
+      : nextElements;
+    const hasPendingCommit = hasPendingElementMutationRef.current || hasPendingCanvasResizeRef.current;
+
+    if (!hasPendingCommit && areCanvasElementsEquivalent(elementsRef.current, committedElements)) {
+      hasPendingElementMutationRef.current = false;
+      hasInFlightMutationRef.current = false;
+      hasPendingCanvasResizeRef.current = false;
+      setHasUncommittedInteraction(false);
+      setDirtyStateFromHistoryIndex(historyIndexRef.current);
+      return;
+    }
+
+    hasInFlightMutationRef.current = false;
+    setHasUncommittedInteraction(false);
+    const preferredSelection = preferredSelectedId === undefined
+      ? getActiveSelectedId()
+      : preferredSelectedId;
+    updateElementsWithHistory(committedElements, preferredSelection, undefined, true);
+  }, [
+    areCanvasElementsEquivalent,
+    getActiveSelectedId,
+    isMutating,
+    setDirtyStateFromHistoryIndex,
+    updateElementsWithHistory,
+  ]);
+
+  const cloneElementForClipboard = useCallback((node: CanvasElement): CanvasElement => (
+    cloneElements([node])[0]
+  ), [cloneElements]);
 
   /**
    * Copy
    */
   const handleCopy = useCallback(() => {
-    if (selectedId) {
-      const el = findElementById(elements, selectedId);
+    if (isMutating) {
+      return;
+    }
+
+    const targetId = getActiveSelectedId();
+    if (targetId) {
+      const el = findElementById(elementsRef.current, targetId);
       if (el) {
-        setClipboardElement(el);
+        setClipboardElement(cloneElementForClipboard(el));
         // Optional: Show toast or feedback
       }
     }
-  }, [selectedId, elements]);
+  }, [cloneElementForClipboard, findElementById, getActiveSelectedId, isMutating]);
 
   const normalizePastedElement = useCallback(
     (sourceElement: CanvasElement, x = 20, y = 20): CanvasElement => {
-      const clone = JSON.parse(JSON.stringify(sourceElement)) as CanvasElement;
-      const highestZ = Math.max(walkTreeMaxZ(elements), 0);
+      const clone = cloneNodeWithNewIds(sourceElement, x, y);
+      const highestZ = Math.max(walkTreeMaxZ(elementsRef.current), 0);
 
       return {
         ...clone,
         id: generateId(),
-        type: normalizeElementType(clone.type),
-        x: sourceElement.x + x,
-        y: sourceElement.y + y,
+        x: clone.x,
+        y: clone.y,
         zIndex: highestZ + 1,
       };
     },
-    [elements]
+    [cloneNodeWithNewIds]
   );
 
   /**
    * Paste
    */
   const handlePaste = useCallback(() => {
+    if (isMutating) {
+      return;
+    }
+
     if (clipboardElement) {
       const newElement = normalizePastedElement(clipboardElement);
-      const selectedElement = selectedId ? findElementById(elements, selectedId) : null;
+      const activeSelection = getActiveSelectedId();
+      const selectedElement = activeSelection
+        ? findElementById(elementsRef.current, activeSelection)
+        : null;
       const canNest = selectedElement && canAcceptNestedDrop(selectedElement.type);
       const newElements = canNest
-        ? insertElementAsChild(elements, selectedElement.id, newElement)
-        : { elements: [...elements, newElement], updated: false };
+        ? insertElementAsChild(elementsRef.current, selectedElement.id, newElement)
+        : { elements: [...elementsRef.current, newElement], updated: false };
 
       const nextElements = canNest && newElements.updated ? newElements.elements : newElements.elements;
 
       updateElementsWithHistory(nextElements, newElement.id);
     }
-  }, [clipboardElement, elements, normalizePastedElement, selectedId, updateElementsWithHistory]);
+  }, [clipboardElement, getActiveSelectedId, isMutating, normalizePastedElement, updateElementsWithHistory]);
 
   const handleDuplicate = useCallback(() => {
-    if (!selectedId) return;
-    const selectedElement = findElementById(elements, selectedId);
+    if (isMutating) {
+      return;
+    }
+
+    const activeSelection = getActiveSelectedId();
+    const selectedElement = activeSelection
+      ? findElementById(elementsRef.current, activeSelection)
+      : null;
     if (!selectedElement) return;
 
     const duplicate = normalizePastedElement(selectedElement);
-    const canNest = canAcceptNestedDrop(selectedElement.type);
-    const duplicated = canNest
-      ? insertElementAsChild(elements, selectedElement.id, duplicate)
-      : { elements: [...elements, duplicate], updated: false };
-    const nextElements = duplicated.updated || !canNest
+    const duplicated = insertElementAfterId(elementsRef.current, selectedElement.id, duplicate);
+    const nextElements = duplicated.updated
       ? duplicated.elements
-      : [...elements, duplicate];
+      : [...elementsRef.current, duplicate];
 
     updateElementsWithHistory(nextElements, duplicate.id);
-  }, [elements, normalizePastedElement, selectedId, updateElementsWithHistory]);
+  }, [findElementById, getActiveSelectedId, insertElementAfterId, isMutating, normalizePastedElement, updateElementsWithHistory]);
 
   // Get selected element
-  const selectedElement = selectedId ? findElementById(elements, selectedId) : null;
+  const activeSelection = getActiveSelectedId();
+  const selectedElement = activeSelection
+    ? findElementById(elements, activeSelection)
+    : null;
 
   /**
    * Handle element selection
    */
   const handleSelect = useCallback((id: string | null) => {
-    setSelectedId(id);
-  }, []);
+    if (id === selectedIdRef.current) {
+      return;
+    }
+
+    setCurrentSelection(id);
+  }, [setCurrentSelection]);
 
   /**
    * Handle elements change
    */
   const handleElementsChange = useCallback((newElements: CanvasElement[]) => {
-    updateElementsWithHistory(newElements);
-  }, [updateElementsWithHistory]);
+    if (isMutating) {
+      return;
+    }
+
+    updateElementsWithHistory(newElements, getActiveSelectedId());
+  }, [getActiveSelectedId, isMutating, updateElementsWithHistory]);
+
+  const handleElementTreeUpdate = useCallback((elementId: string, nextElements: CanvasElement[]) => {
+    if (isMutating) {
+      return;
+    }
+
+    const nextSelection = resolveSelectionForUpdate(nextElements, elementId);
+    updateElementsWithHistory(nextElements, nextSelection);
+  }, [isMutating, resolveSelectionForUpdate, updateElementsWithHistory]);
+
+  /**
+   * Handle in-flight element mutation updates (drag/resize preview)
+   */
+  const handleElementsInFlightChange = useCallback((
+    newElements: CanvasElement[],
+    preferredSelectedId?: string | null,
+  ) => {
+    if (isMutating) {
+      return;
+    }
+
+    const selectionCandidate = preferredSelectedId !== undefined
+      ? preferredSelectedId
+      : getActiveSelectedId();
+    const resolvedSelection = resolveSelectionForLiveMutation(newElements, selectionCandidate);
+    if (
+      hasPendingElementMutationRef.current
+      && areCanvasElementsEquivalent(pendingElementsRef.current, newElements)
+    ) {
+      return;
+    }
+
+    const didChange = !areCanvasElementsEquivalent(elementsRef.current, newElements);
+    if (didChange) {
+      hasPendingElementMutationRef.current = true;
+      hasInFlightMutationRef.current = true;
+      pendingElementsRef.current = cloneElements(newElements);
+      setHasUncommittedInteraction(true);
+      setHasUnsavedChanges(true);
+      if (
+        resolvedSelection !== null
+        && resolvedSelection !== selectedIdRef.current
+      ) {
+        setCurrentSelection(resolvedSelection);
+      }
+      setElements(newElements);
+    }
+  }, [
+    getActiveSelectedId,
+    isMutating,
+    cloneElements,
+    setCurrentSelection,
+    resolveSelectionForLiveMutation,
+    areCanvasElementsEquivalent,
+  ]);
 
   /**
    * Handle element update from property panel
    */
   const handleElementUpdate = useCallback(
     (updates: { [key: string]: unknown }) => {
-      if (!selectedId) return;
+      if (isMutating) {
+        return;
+      }
+
+      const targetId = getActiveSelectedId();
+      if (!targetId) return;
+      const selectedElement = findElementById(elementsRef.current, targetId);
+      if (!selectedElement) return;
+
+      const rootUpdates: Partial<CanvasElement> = {};
+      const propUpdates: Record<string, unknown> = {};
+      const typedUpdates = updates as Record<string, unknown>;
+
+      if (Object.prototype.hasOwnProperty.call(typedUpdates, 'props')) {
+        const nestedProps = typedUpdates.props;
+        if (
+          nestedProps
+          && typeof nestedProps === 'object'
+          && !Array.isArray(nestedProps)
+        ) {
+          Object.assign(propUpdates, nestedProps as Record<string, unknown>);
+        }
+      }
+
+      Object.entries(typedUpdates).forEach(([key, value]) => {
+        if (key === 'props') {
+          return;
+        }
 
-      const result = updateElementById(elements, selectedId, (element) => ({
-        ...element,
-        ...updates,
-      }));
+        if (ROOT_ELEMENT_KEYS.has(key as keyof CanvasElement)) {
+          (rootUpdates as Record<string, unknown>)[key] = value;
+          return;
+        }
+
+        propUpdates[key] = value;
+      });
+
+      const hasChanges = Object.entries(rootUpdates).some(([key, value]) => (
+        !areValuesEquivalent(
+          (selectedElement as Record<string, unknown>)[key],
+          value,
+        )
+      )) || Object.entries(propUpdates).some(([key, value]) => (
+        !areValuesEquivalent(selectedElement.props?.[key], value)
+      ));
+      if (!hasChanges) {
+        return;
+      }
+
+      const result = updateElementById(elementsRef.current, targetId, (element) => {
+        const nextElement: CanvasElement = {
+          ...element,
+          ...rootUpdates,
+          props: {
+            ...element.props,
+            ...propUpdates,
+          },
+        };
+
+        return nextElement;
+      });
 
       if (!result.updated) {
         return;
       }
 
-      updateElementsWithHistory(result.elements);
+      updateElementsWithHistory(result.elements, targetId);
     },
-    [selectedId, elements, updateElementsWithHistory]
+    [findElementById, getActiveSelectedId, isMutating, updateElementsWithHistory]
   );
 
   /**
@@ -647,6 +1382,10 @@ export function CanvasEditor({
    */
   const handleCanvasDrop = useCallback(
     (e: React.DragEvent) => {
+      if (isMutating) {
+        return;
+      }
+
       e.preventDefault();
 
       try {
@@ -662,70 +1401,117 @@ export function CanvasEditor({
 
         // Create new element
         const newElement = createCanvasElement(normalizedType, x, y);
-        const selectedElement = selectedId ? findElementById(elements, selectedId) : null;
+        const activeSelection = getActiveSelectedId();
+        const selectedElement = activeSelection
+          ? findElementById(elementsRef.current, activeSelection)
+          : null;
         const isNested = selectedElement && canAcceptNestedDrop(selectedElement.type);
         const normalized = normalizePastedElement(newElement);
         const result = isNested
-          ? insertElementAsChild(elements, selectedElement.id, normalized)
-          : { elements: [...elements, normalized], updated: false };
+          ? insertElementAsChild(elementsRef.current, selectedElement.id, normalized)
+          : { elements: [...elementsRef.current, normalized], updated: false };
 
         const newElements = result.updated || !isNested
           ? result.elements
-          : [...elements, normalized];
+          : [...elementsRef.current, normalized];
 
         updateElementsWithHistory(newElements, normalized.id);
       } catch (err) {
         console.error('Failed to drop element:', err);
       }
     },
-    [elements, selectedId, updateElementsWithHistory]
+    [getActiveSelectedId, isMutating, updateElementsWithHistory]
   );
 
   /**
    * Delete selected element
    */
   const deleteElement = useCallback(() => {
-    if (!selectedId) return;
-    const result = removeElementById(elements, selectedId);
+    if (isMutating) {
+      return;
+    }
+
+    const activeSelection = getActiveSelectedId();
+    const targetId = activeSelection
+      ? findElementById(elementsRef.current, activeSelection)?.id
+      : null;
+    if (!targetId) return;
+
+    const result = removeElementById(elementsRef.current, targetId);
     if (!result.updated) return;
 
-    updateElementsWithHistory(result.elements, result.removedParentId || null);
-  }, [selectedId, elements, updateElementsWithHistory]);
+    updateElementsWithHistory(result.elements, result.nextSelectedId ?? null);
+  }, [findElementById, getActiveSelectedId, isMutating, updateElementsWithHistory]);
 
   const handleCut = useCallback(() => {
-    if (!selectedId) return;
+    if (isMutating) {
+      return;
+    }
 
-    const selectedElement = findElementById(elements, selectedId);
+    const activeSelection = getActiveSelectedId();
+    const selectedElement = activeSelection
+      ? findElementById(elementsRef.current, activeSelection)
+      : null;
     if (!selectedElement) return;
 
-    setClipboardElement(selectedElement);
+    setClipboardElement(cloneElementForClipboard(selectedElement));
 
-    const result = removeElementById(elements, selectedId);
+    const result = removeElementById(elementsRef.current, selectedElement.id);
     if (!result.updated) {
       return;
     }
 
-    const parentSelection = result.removedParentId || null;
-    setSelectedId(parentSelection);
-    updateElementsWithHistory(result.elements, parentSelection);
-  }, [elements, findElementById, selectedId, updateElementsWithHistory]);
+    updateElementsWithHistory(result.elements, result.nextSelectedId ?? null);
+  }, [cloneElementForClipboard, findElementById, getActiveSelectedId, isMutating, updateElementsWithHistory]);
 
   /**
    * Handle save
    */
-  const handleSaveWrapper = useCallback(async (settingsOverride?: PageSettings, silent = false) => {
+  const handleSaveWrapper = useCallback(async (settingsOverride?: PageSettings, silent = false): Promise<boolean> => {
+    if (isReadOnly) {
+      return false;
+    }
+
     if (isSaving) {
-      return;
+      return false;
     }
 
+    flushPendingInteractionHistory();
     const saveSequence = changeSequenceRef.current;
+    const saveHistoryIndex = historyIndexRef.current;
     setIsSaving(true);
     try {
-      const nextSettings = settingsOverride ?? pageSettings;
-      await Promise.resolve(onSave(elements, nextSettings, size));
-      if (changeSequenceRef.current === saveSequence) {
+      const nextSettings = settingsOverride ?? pageSettingsRef.current;
+      const saveResult = await Promise.resolve(onSave(
+        elementsRef.current,
+        nextSettings,
+        sizeRef.current,
+      ));
+      if (saveResult === false) {
+        return false;
+      }
+      setPageSettings((currentSettings) => (
+        JSON.stringify(currentSettings) === JSON.stringify(nextSettings)
+          ? currentSettings
+          : clonePageSettings(nextSettings)
+      ));
+      if (changeSequenceRef.current === saveSequence && historyIndexRef.current === saveHistoryIndex) {
+        setHistory((prev) => {
+          const next = [...prev];
+          const targetIndex = historyIndexRef.current;
+          if (next[targetIndex]) {
+            next[targetIndex] = {
+              ...next[targetIndex],
+              pageSettings: clonePageSettings(nextSettings),
+            };
+          }
+          return next;
+        });
         setHasUnsavedChanges(false);
+        persistedHistoryIndexRef.current = historyIndexRef.current;
+        setDirtyStateFromHistoryIndex(historyIndexRef.current);
       }
+      return true;
     } catch {
       setHasUnsavedChanges(true);
       if (!silent) {
@@ -733,22 +1519,35 @@ export function CanvasEditor({
       } else {
         console.error('Auto-save failed');
       }
+      return false;
     } finally {
       setIsSaving(false);
     }
-  }, [elements, isSaving, onSave, pageSettings, size]);
+  }, [
+    clonePageSettings,
+    flushPendingInteractionHistory,
+    setDirtyStateFromHistoryIndex,
+    isReadOnly,
+    isSaving,
+    onSave,
+  ]);
 
   const handleTogglePublish = useCallback(async () => {
+    if (isReadOnly || isSaving) {
+      return;
+    }
+
     const nextSettings: PageSettings = {
-      ...pageSettings,
-      status: pageSettings.status === 'published' ? 'draft' : 'published',
+      ...pageSettingsRef.current,
+      status: pageSettingsRef.current.status === 'published' ? 'draft' : 'published',
     };
-    setPageSettings(nextSettings);
-    markChanges();
-    await handleSaveWrapper(nextSettings, true);
-  }, [handleSaveWrapper, pageSettings, markChanges]);
+    const saved = await handleSaveWrapper(nextSettings, true);
+    if (!saved) {
+      return;
+    }
+  }, [handleSaveWrapper, isReadOnly, isSaving]);
 
-  const handleReload = useCallback(() => {
+  const handleReload = useCallback(async () => {
     if (isSaving) {
       return;
     }
@@ -762,46 +1561,93 @@ export function CanvasEditor({
       }
     }
 
-    const nextElements = getInitialElements();
-    const nextSettings = getInitialSettings();
-
-    setElements(nextElements);
-    setPageSettings(nextSettings);
-    setSize(initialSize || DEFAULT_CANVAS_SIZE);
-    setBreakpoint('desktop');
-    setSelectedId(null);
-    setClipboardElement(null);
-    setHistory([{ elements: nextElements, selectedId: null }]);
-    setHistoryIndex(0);
-    setHasUnsavedChanges(false);
-    changeSequenceRef.current += 1;
-    if (onChange) {
-      onChange(nextElements, nextSettings, initialSize || DEFAULT_CANVAS_SIZE);
+    if (onReload) {
+      try {
+        hasPendingElementMutationRef.current = false;
+        hasPendingCanvasResizeRef.current = false;
+        hasInFlightMutationRef.current = false;
+        await Promise.resolve(onReload());
+        persistedHistoryIndexRef.current = historyIndexRef.current;
+        setHasUnsavedChanges(false);
+        setDirtyStateFromHistoryIndex(historyIndexRef.current);
+      } catch {
+        alert('Unable to reload from server. Please try again.');
+      }
+      return;
     }
-  }, [getInitialElements, getInitialSettings, hasUnsavedChanges, initialSize, isSaving, onChange]);
+
+    resetFromInitialState();
+  }, [
+    hasUnsavedChanges,
+    isSaving,
+    onReload,
+    resetFromInitialState,
+    setDirtyStateFromHistoryIndex,
+  ]);
 
   /**
    * Keyboard shortcuts
    */
   useEffect(() => {
     const handleKeyDown = (e: KeyboardEvent) => {
-      if (isSaving && ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's')) {
+      const eventTarget = e.target instanceof Text ? e.target.parentElement : e.target instanceof Element ? e.target : null;
+      const isTextEditingTarget = eventTarget instanceof HTMLElement && (
+        eventTarget instanceof HTMLInputElement
+        || eventTarget instanceof HTMLTextAreaElement
+        || eventTarget.isContentEditable
+      );
+      const isRichTextTarget = eventTarget instanceof HTMLElement && (
+        eventTarget.closest('[data-backy-text-editor], [data-slate-editor], [data-plate-editor], [role="textbox"], [contenteditable="true"]') !== null
+      );
+      const isRichTextInteractionTarget = isTextEditingTarget || isRichTextTarget;
+      if (isMutating && (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
         e.preventDefault();
         return;
       }
 
-      const key = e.key.toLowerCase();
-      // Ignore if typing in an input or textarea
+      if (isMutating) {
+        return;
+      }
+
       if (
-        e.target instanceof HTMLInputElement ||
-        e.target instanceof HTMLTextAreaElement ||
-        (e.target as HTMLElement).isContentEditable
+        isReadOnly
+        && (e.ctrlKey || e.metaKey)
+        && e.key.toLowerCase() === 's'
       ) {
+        e.preventDefault();
+      }
+
+      if (isReadOnly) {
+        return;
+      }
+
+      const key = e.key.toLowerCase();
+      // Let rich-text editors handle their own Undo/Redo.
+      if (!isRichTextInteractionTarget && (e.ctrlKey || e.metaKey) && key === 'z') {
+        e.preventDefault();
+        if (e.shiftKey) {
+          handleRedo();
+        } else {
+          handleUndo();
+        }
         return;
       }
 
+      if (!isRichTextInteractionTarget && (e.ctrlKey || e.metaKey) && key === 'y') {
+        e.preventDefault();
+        handleRedo();
+        return;
+      }
+
+      // Ignore non-undo keyboard shortcuts while typing in inputs/textareas/contentEditable
+      if (isTextEditingTarget) {
+        return;
+      }
+
+      const isRichTextInteraction = isRichTextInteractionTarget;
+
       if (isPreview) {
-        if ((e.ctrlKey || e.metaKey) && key === 's') {
+        if ((e.ctrlKey || e.metaKey) && key === 's' && !hideSave) {
           e.preventDefault();
           handleSaveWrapper();
         }
@@ -809,28 +1655,19 @@ export function CanvasEditor({
       }
 
       // Delete / Backspace
-      if (e.key === 'Delete' || e.key === 'Backspace') {
+      if ((e.key === 'Delete' || e.key === 'Backspace') && !isRichTextInteraction) {
+        e.preventDefault();
         deleteElement();
         return;
       }
 
       // Ctrl+S / Cmd+S (Save)
-      if ((e.ctrlKey || e.metaKey) && key === 's') {
+      if ((e.ctrlKey || e.metaKey) && key === 's' && !hideSave) {
         e.preventDefault();
         handleSaveWrapper();
         return;
       }
 
-      // Ctrl+Z / Cmd+Z (Undo)
-      if ((e.ctrlKey || e.metaKey) && key === 'z') {
-        if (e.shiftKey) {
-          handleRedo();
-        } else {
-          handleUndo();
-        }
-        return;
-      }
-
       // Ctrl+C / Cmd+C (Copy)
       if ((e.ctrlKey || e.metaKey) && key === 'c') {
         e.preventDefault();
@@ -872,29 +1709,83 @@ export function CanvasEditor({
     handlePaste,
     handleDuplicate,
     isPreview,
-    isSaving,
+    isMutating,
+    isReadOnly,
+    hideSave,
   ]);
 
 
 
+  const handleCanvasSizeChange = useCallback((newCanvasSize: CanvasSize) => {
+    if (isMutating) {
+      return;
+    }
+
+    const nextSize = { ...newCanvasSize };
+    if (nextSize.width === size.width && nextSize.height === size.height) {
+      return;
+    }
+
+    hasPendingCanvasResizeRef.current = true;
+    setSize(nextSize);
+    setHasUncommittedInteraction(true);
+    setHasUnsavedChanges(true);
+    markChanges();
+  }, [isMutating, markChanges, size]);
+
+  const handleCanvasSizeCommit = useCallback((nextCanvasSize: CanvasSize) => {
+    if (isMutating) {
+      return;
+    }
+
+    hasPendingCanvasResizeRef.current = false;
+    const committedSize = { ...nextCanvasSize };
+    const didPushHistory = addToHistory(
+      elementsRef.current,
+      getActiveSelectedId(),
+      committedSize,
+      pageSettingsRef.current,
+    );
+    if (didPushHistory) {
+      markChanges();
+    }
+    setHasUncommittedInteraction(false);
+    if (!didPushHistory) {
+      setDirtyStateFromHistoryIndex(historyIndexRef.current);
+    }
+  }, [addToHistory, getActiveSelectedId, isMutating, markChanges, setDirtyStateFromHistoryIndex]);
+
   /**
    * Handle breakpoint change
    */
   const handleBreakpointChange = useCallback(
     (bp: 'desktop' | 'tablet' | 'mobile') => {
+      if (isMutating) {
+        return;
+      }
+
+      const nextSize = { ...BREAKPOINT_CANVAS_SIZE[bp] };
+      if (nextSize.width === size.width && nextSize.height === size.height) {
+        return;
+      }
+
       setBreakpoint(bp);
-      const nextSize = BREAKPOINT_CANVAS_SIZE[bp];
       setSize(nextSize);
-      markChanges();
-      if (onChange) {
-        onChange(elements, pageSettings, nextSize);
+      const didPushHistory = addToHistory(
+        elementsRef.current,
+        getActiveSelectedId(),
+        nextSize,
+        pageSettingsRef.current,
+      );
+      if (didPushHistory) {
+        markChanges();
       }
     },
-    [elements, pageSettings, onChange, markChanges]
+    [addToHistory, getActiveSelectedId, isMutating, markChanges, size]
   );
 
   useEffect(() => {
-    if (!hasUnsavedChanges || isSaving) {
+    if (!hasUnsavedChanges || isSaving || hideSave) {
       return;
     }
 
@@ -911,7 +1802,7 @@ export function CanvasEditor({
         clearTimeout(autosaveTimeoutRef.current);
       }
     };
-  }, [handleSaveWrapper, hasUnsavedChanges, isSaving]);
+  }, [handleSaveWrapper, hasUnsavedChanges, hideSave, isSaving]);
 
   useEffect(() => () => {
     if (autosaveTimeoutRef.current) {
@@ -953,6 +1844,9 @@ export function CanvasEditor({
     };
   }, [isPreview, size.width, size.height]);
 
+  const canUndo = (!isMutating) && (historyIndexRef.current > 0 || hasUncommittedInteraction);
+  const canRedo = (!isMutating) && (historyIndexRef.current < historyRef.current.length - 1);
+
   return (
     <ActiveEditorProvider>
       <div className={cn("flex flex-col bg-background", className || "fixed inset-0")}>
@@ -1031,7 +1925,7 @@ export function CanvasEditor({
             <button
               type="button"
               onClick={handleUndo}
-              disabled={historyIndex <= 0}
+              disabled={!canUndo}
               className="px-2 py-1.5 rounded-lg text-sm font-medium hover:bg-accent disabled:opacity-50 disabled:cursor-not-allowed"
               title="Undo (Ctrl+Z)"
               aria-label="Undo"
@@ -1042,7 +1936,7 @@ export function CanvasEditor({
             <button
               type="button"
               onClick={handleRedo}
-              disabled={historyIndex >= history.length - 1}
+              disabled={!canRedo}
               className="px-2 py-1.5 rounded-lg text-sm font-medium hover:bg-accent disabled:opacity-50 disabled:cursor-not-allowed"
               title="Redo (Ctrl+Shift+Z)"
               aria-label="Redo"
@@ -1055,7 +1949,7 @@ export function CanvasEditor({
             <button
               type="button"
               onClick={handleCopy}
-              disabled={!selectedId}
+              disabled={isMutating || isReadOnly || !selectedId}
               className="px-2 py-1.5 rounded-lg text-sm font-medium hover:bg-accent disabled:opacity-50 disabled:cursor-not-allowed"
               title="Copy (Ctrl+C)"
               aria-label="Copy"
@@ -1065,7 +1959,7 @@ export function CanvasEditor({
             <button
               type="button"
               onClick={handleCut}
-              disabled={!selectedId}
+              disabled={isMutating || isReadOnly || !selectedId}
               className="px-2 py-1.5 rounded-lg text-sm font-medium hover:bg-accent disabled:opacity-50 disabled:cursor-not-allowed"
               title="Cut (Ctrl+X)"
               aria-label="Cut"
@@ -1076,7 +1970,8 @@ export function CanvasEditor({
             <button
               type="button"
               onClick={handlePaste}
-              className="px-2 py-1.5 rounded-lg text-sm font-medium hover:bg-accent"
+              disabled={isMutating || isReadOnly || !clipboardElement}
+              className="px-2 py-1.5 rounded-lg text-sm font-medium hover:bg-accent disabled:opacity-50 disabled:cursor-not-allowed"
               title="Paste (Ctrl+V)"
               aria-label="Paste"
             >
@@ -1085,7 +1980,7 @@ export function CanvasEditor({
             <button
               type="button"
               onClick={handleDuplicate}
-              disabled={!selectedId}
+              disabled={isMutating || isReadOnly || !selectedId}
               className="px-2 py-1.5 rounded-lg text-sm font-medium hover:bg-accent disabled:opacity-50 disabled:cursor-not-allowed"
               title="Duplicate (Ctrl+D)"
               aria-label="Duplicate"
@@ -1095,7 +1990,7 @@ export function CanvasEditor({
             <button
               type="button"
               onClick={deleteElement}
-              disabled={!selectedId}
+              disabled={isMutating || isReadOnly || !selectedId}
               className="px-2 py-1.5 rounded-lg text-sm font-medium hover:bg-accent disabled:opacity-50 disabled:cursor-not-allowed"
               title="Delete (Delete)"
               aria-label="Delete"
@@ -1121,7 +2016,7 @@ export function CanvasEditor({
             </button>
 
             {/* Settings */}
-            {!hideSettings && (
+            {!hideSettings && !isReadOnly && (
             <button
               type="button"
               onClick={() => setIsSettingsOpen(true)}
@@ -1148,7 +2043,7 @@ export function CanvasEditor({
             <div className="w-px h-6 bg-border mx-1" />
 
             {/* Save */}
-            {!hideSave && (
+            {!hideSave && !isReadOnly && (
               <>
                 {mode === 'page' && (
                   <button
@@ -1177,9 +2072,9 @@ export function CanvasEditor({
                   </button>
                 )}
 
-                <button
-                  type="button"
-                  onClick={handleSaveWrapper}
+                  <button
+                    type="button"
+                    onClick={handleSaveWrapper}
                   disabled={isSaving}
                   className="flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm bg-primary text-primary-foreground hover:bg-primary/90 disabled:opacity-70 disabled:cursor-not-allowed"
                   title="Save Page (Ctrl+S)"
@@ -1193,10 +2088,10 @@ export function CanvasEditor({
           </div>
         </header>
 
-        {/* Main Content */}
+          {/* Main Content */}
         <div className="flex-1 flex overflow-hidden">
           {/* Left Sidebar - Component Library */}
-          {!isPreview && <ComponentLibrary onDragStart={handleDragStart} />}
+          {!isPreview && !isReadOnly && <ComponentLibrary onDragStart={handleDragStart} />}
 
           {/* Center - Canvas */}
           <div
@@ -1217,24 +2112,22 @@ export function CanvasEditor({
                 <Canvas
                   elements={elements}
                   onElementsChange={handleElementsChange}
+                  onElementUpdate={handleElementTreeUpdate}
+                  onElementsInFlightChange={handleElementsInFlightChange}
+                  onElementsMutationCommit={handleElementsMutationCommit}
                   selectedId={selectedId}
                   onSelect={handleSelect}
-                  size={size}
-                  onSizeChange={(newSize) => {
-                    setSize(newSize);
-                    markChanges();
-                    if (onChange) {
-                      onChange(elements, pageSettings, newSize);
-                    }
-                  }}
-                  isPreview={isPreview}
-                />
+	                  size={size}
+	                  onSizeChange={handleCanvasSizeChange}
+	                  onSizeCommit={handleCanvasSizeCommit}
+	                  isPreview={isPreview}
+	                />
               </div>
             </div>
           </div>
 
           {/* Right Sidebar - Property Panel */}
-          {!isPreview && (
+          {!isPreview && !isReadOnly && (
             <PropertyPanel
               element={selectedElement}
               onChange={handleElementUpdate}
@@ -1244,15 +2137,23 @@ export function CanvasEditor({
           )}
         </div>
 
-        <PageSettingsModal
-          isOpen={isSettingsOpen}
-          onClose={() => setIsSettingsOpen(false)}
-          settings={pageSettings}
-          onSave={(newSettings) => {
-            setPageSettings(newSettings);
-            markChanges();
-          }}
-        />
+	          <PageSettingsModal
+	          isOpen={isSettingsOpen}
+	          onClose={() => setIsSettingsOpen(false)}
+                  settings={pageSettings}
+                  onSave={(newSettings) => {
+                    setPageSettings(newSettings);
+                    const didPushHistory = addToHistory(
+                      elementsRef.current,
+                      getActiveSelectedId(),
+                      sizeRef.current,
+                      newSettings,
+                    );
+                    if (didPushHistory) {
+                      markChanges();
+                    }
+                  }}
+	        />
       </div>
     </ActiveEditorProvider>
   );
diff --git a/apps/admin/src/components/editor/ComponentLibrary.tsx b/apps/admin/src/components/editor/ComponentLibrary.tsx
index a79a5d3..acb9e15 100644
--- a/apps/admin/src/components/editor/ComponentLibrary.tsx
+++ b/apps/admin/src/components/editor/ComponentLibrary.tsx
@@ -157,9 +157,9 @@ export function ComponentLibrary({ onDragStart }: ComponentLibraryProps) {
               {category}
             </h3>
             <div className="space-y-1">
-              {items.map((item) => (
+              {items.map((item, index) => (
                 <LibraryItem
-                  key={item.type}
+                  key={`${category}-${item.type}-${item.name}-${index}`}
                   item={item}
                   onDragStart={() => onDragStart?.(item)}
                 />
diff --git a/apps/admin/src/components/editor/PropertyPanel.tsx b/apps/admin/src/components/editor/PropertyPanel.tsx
index 7a5922a..c681d9d 100644
--- a/apps/admin/src/components/editor/PropertyPanel.tsx
+++ b/apps/admin/src/components/editor/PropertyPanel.tsx
@@ -72,6 +72,54 @@ const parseBooleanSetting = (value: unknown, fallback = false): boolean => {
   return fallback;
 };
 
+const parseIntegerSetting = (value: string, fallback: number, min: number = 0): number => {
+  if (!value.trim()) {
+    return fallback;
+  }
+
+  const parsed = Number.parseInt(value, 10);
+  if (!Number.isFinite(parsed)) {
+    return fallback;
+  }
+
+  return Math.max(parsed, min);
+};
+
+const readSlateNodeText = (node: unknown): string => {
+  if (typeof node === 'string') {
+    return node;
+  }
+
+  if (!node || typeof node !== 'object') {
+    return '';
+  }
+
+  const asRecord = node as Record<string, unknown>;
+
+  if (typeof asRecord.text === 'string') {
+    return asRecord.text;
+  }
+
+  const children = asRecord.children;
+  if (Array.isArray(children)) {
+    return children.map(readSlateNodeText).join('');
+  }
+
+  return '';
+};
+
+const getTextContentValue = (value: unknown): string => {
+  if (typeof value === 'string') {
+    return value;
+  }
+
+  if (!Array.isArray(value)) {
+    return '';
+  }
+
+  return value.map(readSlateNodeText).join('\n').trim();
+};
+
 const normalizeCanvasElementType = (value: string): CanvasElement['type'] => {
   const normalized = typeof value === 'string' ? value.trim().toLowerCase().replace(/[^a-z0-9]+/g, '') : '';
 
@@ -442,7 +490,27 @@ function ContentProperties({
     <div className="space-y-3">
       {/* Rich Text Controls */}
         {hasTextContent && (
-          <RichTextFormatting elementId={elementId} />
+          <>
+            <div className="space-y-2">
+              <label className="text-xs text-muted-foreground mb-1 block">
+                Plain Text Content
+              </label>
+              <textarea
+                rows={3}
+                value={getTextContentValue(element.props.content as unknown)}
+                onChange={(e) => onChange({ content: e.target.value })}
+                className={cn(
+                  'w-full min-h-[72px] px-2 py-1.5 text-sm rounded-md border bg-background resize-none',
+                  'focus:outline-none focus:ring-2 focus:ring-ring'
+                )}
+                placeholder="Enter your text"
+              />
+              <p className="text-[11px] text-muted-foreground">
+                Tip: Use the canvas editor for rich text formatting, links, and block-level styling.
+              </p>
+            </div>
+            <RichTextFormatting elementId={elementId} />
+          </>
         )}
 
       {/* Image Source */}
@@ -777,8 +845,57 @@ function ContentProperties({
                   <option value="date">Date</option>
                   <option value="tel">Phone</option>
                   <option value="url">URL</option>
+                  <option value="file">File</option>
                 </select>
               </div>
+              {element.props.inputType === 'file' ? (
+                <>
+                  <div>
+                    <label className="text-xs text-muted-foreground mb-1 block">
+                      Accepted file types
+                    </label>
+                    <input
+                      type="text"
+                      value={(element.props.accept as string) || ''}
+                      onChange={(e) => onChange({ accept: e.target.value })}
+                      className={cn(
+                        'w-full px-2 py-1.5 text-sm rounded-md border bg-background',
+                        'focus:outline-none focus:ring-2 focus:ring-ring'
+                      )}
+                      placeholder="e.g. .pdf,.jpg,.png,image/*"
+                    />
+                  </div>
+                  <div>
+                    <label className="text-xs text-muted-foreground mb-1 block">
+                      Max file size (MB)
+                    </label>
+                    <input
+                      type="number"
+                      min={0}
+                      value={Number.isFinite(Number(element.props.maxFileSizeMb))
+                        ? Number(element.props.maxFileSizeMb)
+                        : ''}
+                      onChange={(e) => onChange({ maxFileSizeMb: e.target.value ? Number(e.target.value) : undefined })}
+                      className={cn(
+                        'w-full px-2 py-1.5 text-sm rounded-md border bg-background',
+                        'focus:outline-none focus:ring-2 focus:ring-ring'
+                      )}
+                      placeholder="25"
+                    />
+                  </div>
+                  <div className="flex items-center gap-2">
+                    <input
+                      type="checkbox"
+                      id={`multiple-${element.id}`}
+                      checked={Boolean(element.props.multiple)}
+                      onChange={(e) => onChange({ multiple: e.target.checked })}
+                    />
+                    <label htmlFor={`multiple-${element.id}`} className="text-xs text-muted-foreground">
+                      Allow multiple files
+                    </label>
+                  </div>
+                </>
+              ) : null}
               <div>
                 <label className="text-xs text-muted-foreground mb-1 block">
                   Validation Pattern (regex)
@@ -802,8 +919,8 @@ function ContentProperties({
               <input
                 type="number"
                 min={0}
-                value={(element.props.minLength as number) || ''}
-                onChange={(e) => onChange({ minLength: Number(e.target.value) })}
+              value={(element.props.minLength as number) || ''}
+                      onChange={(e) => onChange({ minLength: Number(e.target.value) })}
                 className={cn(
                   'w-full px-2 py-1.5 text-sm rounded-md border bg-background',
                   'focus:outline-none focus:ring-2 focus:ring-ring'
@@ -1398,6 +1515,195 @@ function ContentProperties({
               <option value="oldest">Oldest first</option>
             </select>
           </div>
+          <div className="rounded-md border border-border bg-muted/20 p-2 space-y-2">
+            <p className="text-xs font-medium text-muted-foreground">Anti-abuse controls</p>
+            <div className="grid grid-cols-2 gap-2">
+              <label className="text-xs text-muted-foreground">
+                <span className="block mb-1">Rate limit</span>
+                <input
+                  type="number"
+                  min={1}
+                  step={1}
+                  value={String(element.props.commentAntiAbuseRateLimit ?? 12)}
+                  onChange={(event) => onChange({
+                    commentAntiAbuseRateLimit: parseIntegerSetting(event.target.value, element.props.commentAntiAbuseRateLimit ?? 12, 1),
+                  })}
+                  className={cn(
+                    'w-full px-2 py-1.5 text-sm rounded-md border bg-background',
+                    'focus:outline-none focus:ring-2 focus:ring-ring',
+                  )}
+                />
+              </label>
+              <label className="text-xs text-muted-foreground">
+                <span className="block mb-1">Window (ms)</span>
+                <input
+                  type="number"
+                  min={1000}
+                  step={250}
+                  value={String(element.props.commentAntiAbuseRateWindowMs ?? 45000)}
+                  onChange={(event) => onChange({
+                    commentAntiAbuseRateWindowMs: parseIntegerSetting(event.target.value, element.props.commentAntiAbuseRateWindowMs ?? 45000, 1),
+                  })}
+                  className={cn(
+                    'w-full px-2 py-1.5 text-sm rounded-md border bg-background',
+                    'focus:outline-none focus:ring-2 focus:ring-ring',
+                  )}
+                />
+              </label>
+              <label className="text-xs text-muted-foreground">
+                <span className="block mb-1">Duplicate window (ms)</span>
+                <input
+                  type="number"
+                  min={1000}
+                  step={250}
+                  value={String(element.props.commentAntiAbuseSignatureWindowMs ?? 300000)}
+                  onChange={(event) => onChange({
+                    commentAntiAbuseSignatureWindowMs: parseIntegerSetting(event.target.value, element.props.commentAntiAbuseSignatureWindowMs ?? 300000, 1),
+                  })}
+                  className={cn(
+                    'w-full px-2 py-1.5 text-sm rounded-md border bg-background',
+                    'focus:outline-none focus:ring-2 focus:ring-ring',
+                  )}
+                />
+              </label>
+              <label className="text-xs text-muted-foreground">
+                <span className="block mb-1">Minimum submit time (ms)</span>
+                <input
+                  type="number"
+                  min={0}
+                  step={50}
+                  value={String(element.props.commentAntiAbuseMinFillMs ?? 900)}
+                  onChange={(event) => onChange({
+                    commentAntiAbuseMinFillMs: parseIntegerSetting(event.target.value, element.props.commentAntiAbuseMinFillMs ?? 900, 0),
+                  })}
+                  className={cn(
+                    'w-full px-2 py-1.5 text-sm rounded-md border bg-background',
+                    'focus:outline-none focus:ring-2 focus:ring-ring',
+                  )}
+                />
+              </label>
+              <label className="text-xs text-muted-foreground">
+                <span className="block mb-1">Auto-block threshold</span>
+                <input
+                  type="number"
+                  min={1}
+                  step={1}
+                  value={String(element.props.commentAntiAbuseAutoBlockSpamCount ?? 6)}
+                  onChange={(event) => onChange({
+                    commentAntiAbuseAutoBlockSpamCount: parseIntegerSetting(
+                      event.target.value,
+                      element.props.commentAntiAbuseAutoBlockSpamCount ?? 6,
+                      1,
+                    ),
+                  })}
+                  className={cn(
+                    'w-full px-2 py-1.5 text-sm rounded-md border bg-background',
+                    'focus:outline-none focus:ring-2 focus:ring-ring',
+                  )}
+                />
+              </label>
+              <label className="text-xs text-muted-foreground">
+                <span className="block mb-1">Request rate limit</span>
+                <input
+                  type="number"
+                  min={1}
+                  step={1}
+                  value={String(element.props.commentAntiAbuseRequestRateLimit ?? 6)}
+                  onChange={(event) => onChange({
+                    commentAntiAbuseRequestRateLimit: parseIntegerSetting(
+                      event.target.value,
+                      element.props.commentAntiAbuseRequestRateLimit ?? 6,
+                      1,
+                    ),
+                  })}
+                  className={cn(
+                    'w-full px-2 py-1.5 text-sm rounded-md border bg-background',
+                    'focus:outline-none focus:ring-2 focus:ring-ring',
+                  )}
+                />
+              </label>
+              <label className="text-xs text-muted-foreground">
+                <span className="block mb-1">Request window (ms)</span>
+                <input
+                  type="number"
+                  min={1000}
+                  step={250}
+                  value={String(element.props.commentAntiAbuseRequestRateWindowMs ?? 120000)}
+                  onChange={(event) => onChange({
+                    commentAntiAbuseRequestRateWindowMs: parseIntegerSetting(
+                      event.target.value,
+                      element.props.commentAntiAbuseRequestRateWindowMs ?? 120000,
+                      1,
+                    ),
+                  })}
+                  className={cn(
+                    'w-full px-2 py-1.5 text-sm rounded-md border bg-background',
+                    'focus:outline-none focus:ring-2 focus:ring-ring',
+                  )}
+                />
+              </label>
+              <label className="text-xs text-muted-foreground">
+                <span className="block mb-1">Auto-block user threshold</span>
+                <input
+                  type="number"
+                  min={0}
+                  step={1}
+                  value={String(element.props.commentAntiAbuseAutoBlockUserThreshold ?? 0)}
+                  onChange={(event) => onChange({
+                    commentAntiAbuseAutoBlockUserThreshold: parseIntegerSetting(
+                      event.target.value,
+                      element.props.commentAntiAbuseAutoBlockUserThreshold ?? 0,
+                      0,
+                    ),
+                  })}
+                  className={cn(
+                    'w-full px-2 py-1.5 text-sm rounded-md border bg-background',
+                    'focus:outline-none focus:ring-2 focus:ring-ring',
+                  )}
+                />
+              </label>
+              <label className="text-xs text-muted-foreground">
+                <span className="block mb-1">Auto-block request threshold</span>
+                <input
+                  type="number"
+                  min={0}
+                  step={1}
+                  value={String(element.props.commentAntiAbuseAutoBlockRequestThreshold ?? 0)}
+                  onChange={(event) => onChange({
+                    commentAntiAbuseAutoBlockRequestThreshold: parseIntegerSetting(
+                      event.target.value,
+                      element.props.commentAntiAbuseAutoBlockRequestThreshold ?? 0,
+                      0,
+                    ),
+                  })}
+                  className={cn(
+                    'w-full px-2 py-1.5 text-sm rounded-md border bg-background',
+                    'focus:outline-none focus:ring-2 focus:ring-ring',
+                  )}
+                />
+              </label>
+              <label className="text-xs text-muted-foreground">
+                <span className="block mb-1">Auto-block duration (min)</span>
+                <input
+                  type="number"
+                  min={0}
+                  step={1}
+                  value={String(element.props.commentAntiAbuseAutoBlockDurationMinutes ?? 120)}
+                  onChange={(event) => onChange({
+                    commentAntiAbuseAutoBlockDurationMinutes: parseIntegerSetting(
+                      event.target.value,
+                      element.props.commentAntiAbuseAutoBlockDurationMinutes ?? 120,
+                      0,
+                    ),
+                  })}
+                  className={cn(
+                    'w-full px-2 py-1.5 text-sm rounded-md border bg-background',
+                    'focus:outline-none focus:ring-2 focus:ring-ring',
+                  )}
+                />
+              </label>
+            </div>
+          </div>
         </div>
       )}
 
diff --git a/apps/admin/src/components/editor/RichTextFormatting.tsx b/apps/admin/src/components/editor/RichTextFormatting.tsx
index 0b68a2c..ae81dee 100644
--- a/apps/admin/src/components/editor/RichTextFormatting.tsx
+++ b/apps/admin/src/components/editor/RichTextFormatting.tsx
@@ -52,6 +52,14 @@ interface RichTextFormattingProps {
 const MARK_ABSENT = Symbol('richtext-mark-absent');
 const MARK_MIXED = Symbol('richtext-mark-mixed');
 
+interface RangeSelectionRunResult {
+  executed: boolean;
+  selectionWasCollapsed: boolean;
+  selectionSnapshot: SlateRange | null;
+  restoredSelection: boolean;
+  appliedToWholeElement: boolean;
+}
+
 type MarkStateValue = string | number | boolean | null | undefined | symbol;
 
 export function RichTextFormatting({
@@ -63,10 +71,11 @@ export function RichTextFormatting({
   const fontFamilies = useMemo(() => getFontFamilyOptions(media), [media]);
   const {
     getActiveEditor,
+    removeMark,
+    insertText,
     getActiveEditorElementId,
     setAlign,
     toggleList,
-    isMarkActive,
     restoreSelection,
     hasSelection,
     selectionRevision,
@@ -116,6 +125,26 @@ export function RichTextFormatting({
       selector: `[data-element-id="${elementId}"]`,
     });
     if (hostElement) {
+      const editableHost = hostElement.querySelector<HTMLElement>('[data-backy-text-editor] [contenteditable=\"true\"]')
+        || hostElement.querySelector<HTMLElement>('[contenteditable=\"true\"]')
+        || hostElement.querySelector<HTMLElement>('[role=\"textbox\"][contenteditable=\"true\"]')
+        || hostElement.querySelector<HTMLElement>('[role=\"textbox\"]')
+        || hostElement.querySelector<HTMLElement>('[data-slate-editor]')
+        || hostElement.querySelector<HTMLElement>('[data-plate-editor]');
+      if (editableHost) {
+        try {
+          editableHost.focus();
+          logTextAction('activateTextEditor.focus', { elementId });
+          dispatchExternalEditRequest();
+          return true;
+        } catch (error) {
+          logTextAction('activateTextEditor.focus-failed', {
+            elementId,
+            error: (error as Error)?.message || String(error),
+          });
+        }
+      }
+
       logTextAction('activateTextEditor.dispatch-dblclick');
       hostElement.dispatchEvent(
         new MouseEvent('dblclick', {
@@ -141,7 +170,8 @@ export function RichTextFormatting({
       activeEditorId: getCurrentActiveEditorId(),
       activeEditorMatchesElement,
     });
-    if (canInteractWithEditor() && activeEditorMatchesElement) {
+    const canInteractInitial = canInteractWithEditor();
+    if (canInteractInitial && activeEditorMatchesElement) {
       logTextAction('runOrActivateTextEditor.direct-execute', {
         actionName,
         activeEditorId: getCurrentActiveEditorId(),
@@ -150,7 +180,7 @@ export function RichTextFormatting({
       return;
     }
 
-    if (canInteractWithEditor() && !activeEditorMatchesElement) {
+    if (canInteractInitial && !activeEditorMatchesElement) {
       const activeEditorElementId = getCurrentActiveEditorId();
       logTextAction('runOrActivateTextEditor.target-mismatch', {
         actionName,
@@ -173,9 +203,17 @@ export function RichTextFormatting({
     const maxAttempts = 60;
     const poll = () => {
       attempts += 1;
+      const canInteract = canInteractWithEditor();
       const activeEditorElementId = getCurrentActiveEditorId();
       const activeMatches = !elementId || (!!activeEditorElementId && activeEditorElementId === elementId);
-      const canInteract = canInteractWithEditor();
+      if (canInteract && !activeMatches) {
+        logTextAction('runOrActivateTextEditor.poll-target-mismatch', {
+          actionName,
+          attempts,
+          activeEditorElementId,
+          expectedElementId: elementId,
+        });
+      }
 
       if (canInteract && activeMatches) {
         pendingActionRef.current = null;
@@ -204,13 +242,30 @@ export function RichTextFormatting({
           actionName,
           attempts,
         });
-        if (canInteract) {
+        if (canInteract && activeMatches) {
           logTextAction('runOrActivateTextEditor.poll-fallback-execute', {
             actionName,
             activeEditorId: getCurrentActiveEditorId(),
           });
           action();
         }
+
+        if (!canInteract) {
+          const activatedAgain = activateTextEditor();
+          if (activatedAgain) {
+            pendingActionRef.current = window.setTimeout(() => poll(), 80);
+          }
+        } else if (!activeMatches) {
+          const retryElementId = elementId;
+          if (retryElementId) {
+            requestAnimationFrame(() => requestAnimationFrame(() => {
+              if (activateTextEditor()) {
+                pendingActionRef.current = window.setTimeout(() => poll(), 80);
+              }
+            }));
+          }
+        }
+
         return;
       }
 
@@ -246,101 +301,212 @@ export function RichTextFormatting({
   const runForRangeSelection = useCallback((fn: () => void, options?: {
     requireTextSelection?: boolean;
     fallbackToWholeElement?: boolean;
-  }) => {
+  }): RangeSelectionRunResult => {
+    const defaultResult: RangeSelectionRunResult = {
+      executed: false,
+      selectionWasCollapsed: false,
+      selectionSnapshot: null,
+      restoredSelection: false,
+      appliedToWholeElement: false,
+    };
     const editor = getActiveEditor();
     if (!editor) {
       logTextAction('runForRangeSelection.aborted.no-editor', { options });
-      return;
+      return defaultResult;
     }
 
-    const currentSelection = editor.selection;
-    const hasActiveRange = currentSelection && SlateRange.isRange(currentSelection);
-    const hasValidSelection = hasActiveRange
-      && Node.has(editor as any, currentSelection.anchor.path)
-      && Node.has(editor as any, currentSelection.focus.path);
-    logTextAction('runForRangeSelection.state', {
-      requireTextSelection: options?.requireTextSelection,
-      fallbackToWholeElement: options?.fallbackToWholeElement,
-      hasActiveRange,
-      hasValidSelection,
-    });
-
     const shouldRequireTextSelection = options?.requireTextSelection ?? false;
-    if (!hasActiveRange || !hasValidSelection) {
-      if (shouldRequireTextSelection) {
-        logTextAction('runForRangeSelection.restore-failed', {
-          requireTextSelection: shouldRequireTextSelection,
-        });
-        return;
+    const shouldFallbackToWholeElement = options?.fallbackToWholeElement ?? false;
+
+    const restoreResult = restoreSelection({ requireTextSelection: false });
+    if (!restoreResult && shouldRequireTextSelection) {
+      logTextAction('runForRangeSelection.restore-failed', {
+        requireTextSelection: shouldRequireTextSelection,
+        reason: 'restore-failed',
+      });
+      return defaultResult;
+    }
+
+    if (!restoreResult && !shouldFallbackToWholeElement) {
+      logTextAction('runForRangeSelection.restore-failed', {
+        requireTextSelection: shouldRequireTextSelection,
+        reason: 'restore-failed',
+        fallbackAllowed: shouldFallbackToWholeElement,
+      });
+      return defaultResult;
+    }
+
+    const initialSelection = editor.selection;
+    const hadSelection = initialSelection && SlateRange.isRange(initialSelection);
+    const hasValidSelection = hadSelection
+      && Node.has(editor as any, initialSelection.anchor.path)
+      && Node.has(editor as any, initialSelection.focus.path);
+    const initialSelectionCollapsed = hadSelection && SlateRange.isCollapsed(initialSelection);
+    const initialSelectionSnapshot = hadSelection && hasValidSelection
+      ? {
+        anchor: {
+          path: [...initialSelection.anchor.path],
+          offset: initialSelection.anchor.offset,
+        },
+        focus: {
+          path: [...initialSelection.focus.path],
+          offset: initialSelection.focus.offset,
+        },
       }
+      : null;
 
+    if ((!hadSelection || !hasValidSelection) && shouldFallbackToWholeElement) {
       try {
         const start = Editor.start(editor as any, []);
         const end = Editor.end(editor as any, []);
         Transforms.select(editor as any, { anchor: start, focus: end });
-        logTextAction('runForRangeSelection.restore-fallback-whole-document');
       } catch (error) {
         logTextAction('runForRangeSelection.restore-failed', {
           requireTextSelection: shouldRequireTextSelection,
           reason: 'restore-fallback-failed',
+          hasSelectionBeforeRestore: hadSelection,
+          hasValidSelection,
           restoreError: (error as Error)?.message || String(error),
         });
-        return;
+        return defaultResult;
       }
     }
 
-    storeSelection();
+    if (!hadSelection || !hasValidSelection) {
+      if (shouldRequireTextSelection) {
+        logTextAction('runForRangeSelection.restore-failed', {
+          requireTextSelection: shouldRequireTextSelection,
+          reason: 'selection-required',
+        });
+        return defaultResult;
+      }
 
-    const selectionSnapshot = SlateRange.isRange(editor.selection)
-      ? {
-        anchor: {
-          path: [...editor.selection.anchor.path],
-          offset: editor.selection.anchor.offset,
-        },
-        focus: {
-          path: [...editor.selection.focus.path],
-          offset: editor.selection.focus.offset,
-        },
+      if (!shouldFallbackToWholeElement) {
+        logTextAction('runForRangeSelection.state', {
+          requireTextSelection: options?.requireTextSelection,
+          fallbackToWholeElement: options?.fallbackToWholeElement,
+          hasActiveRange: false,
+          hadSelection,
+          hasValidSelection,
+          restoreResult,
+          selectionWasCollapsed: false,
+          appliedToWholeElement: false,
+        });
+        return defaultResult;
       }
-      : null;
+    }
+
+    const activeSelection = editor.selection;
+    const hasActiveRange = activeSelection && SlateRange.isRange(activeSelection);
+    if (!hasActiveRange) {
+      if (shouldRequireTextSelection || !shouldFallbackToWholeElement) {
+        logTextAction('runForRangeSelection.restore-failed', {
+          requireTextSelection: shouldRequireTextSelection,
+          restoreResult,
+        });
+        return defaultResult;
+      }
+      return defaultResult;
+    }
+
+    const currentSelection = activeSelection as SlateRange;
+    const selectionWasCollapsed = SlateRange.isCollapsed(currentSelection);
+    const shouldSelectWholeElement = shouldFallbackToWholeElement && (!hadSelection || selectionWasCollapsed);
 
-    if (
-      options?.fallbackToWholeElement &&
-      SlateRange.isRange(editor.selection) &&
-      SlateRange.isCollapsed(editor.selection)
-    ) {
+    if (shouldSelectWholeElement) {
       try {
         const start = Editor.start(editor as any, []);
         const end = Editor.end(editor as any, []);
         Transforms.select(editor as any, { anchor: start, focus: end });
-      } catch {
+      } catch (error) {
+        logTextAction('runForRangeSelection.restore-failed', {
+          requireTextSelection: shouldRequireTextSelection,
+          reason: 'select-all-for-whole-element-failed',
+          restoreError: (error as Error)?.message || String(error),
+        });
+        return defaultResult;
       }
     }
 
+    logTextAction('runForRangeSelection.state', {
+      requireTextSelection: options?.requireTextSelection,
+      fallbackToWholeElement: options?.fallbackToWholeElement,
+      hasActiveRange,
+      hadSelection,
+      hasValidSelection,
+      restoreResult,
+      selectionWasCollapsed,
+      shouldFallbackToWholeElement: shouldSelectWholeElement,
+    });
+
+    const result: RangeSelectionRunResult = {
+      executed: true,
+      selectionWasCollapsed: initialSelectionCollapsed,
+      selectionSnapshot: initialSelectionSnapshot,
+      restoredSelection: false,
+      appliedToWholeElement: shouldSelectWholeElement,
+    };
+
     storeSelection();
 
     try {
       logTextAction('runForRangeSelection.execute', { actionName: activePropertyActionRef.current });
       fn();
     } finally {
-      if (selectionSnapshot) {
+      if (result.selectionSnapshot) {
         try {
-          Transforms.select(editor as any, selectionSnapshot);
+          Transforms.select(editor as any, result.selectionSnapshot);
+          result.restoredSelection = true;
         } catch {
         }
       }
       logTextAction('runForRangeSelection.restore-cursor');
       storeSelection();
     }
-  }, [activePropertyActionRef, getActiveEditor, logTextAction, storeSelection]);
+
+    return result;
+  }, [activePropertyActionRef, getActiveEditor, logTextAction, restoreSelection, storeSelection]);
 
   const runForTextSelectionOrCaret = useCallback((fn: () => void, preferSelectionOnly = false) => {
-    runForRangeSelection(fn, {
+    return runForRangeSelection(fn, {
       requireTextSelection: preferSelectionOnly,
       fallbackToWholeElement: !preferSelectionOnly,
     });
   }, [runForRangeSelection]);
 
+  const syncCollapsedFormatStateAfterWholeSelection = useCallback((
+    result: RangeSelectionRunResult,
+    format: string,
+    nextValue: MarkStateValue,
+  ) => {
+    if (!result.appliedToWholeElement || !result.selectionWasCollapsed || !result.selectionSnapshot) {
+      return;
+    }
+
+    const editor = getActiveEditor();
+    if (!editor) {
+      return;
+    }
+
+    try {
+      Transforms.select(editor as any, result.selectionSnapshot);
+      if (
+        nextValue === MARK_ABSENT
+        || nextValue === MARK_MIXED
+        || nextValue === null
+        || nextValue === undefined
+        || nextValue === ''
+      ) {
+        Editor.removeMark(editor as any, format);
+      } else {
+        Editor.addMark(editor as any, format, nextValue);
+      }
+      storeSelection();
+    } catch {
+      // No-op: selection focus could be stale after an immediate editor remount.
+    }
+  }, [getActiveEditor, storeSelection]);
+
   const runForCaretPosition = useCallback((fn: () => void) => {
     const editor = getActiveEditor();
     if (!editor) {
@@ -392,40 +558,112 @@ export function RichTextFormatting({
     }
   }, [activePropertyActionRef, getActiveEditor, logTextAction, restoreSelection, storeSelection]);
 
+  const readActiveTextMark = useCallback((format: string): MarkStateValue => {
+    const editor = getActiveEditor();
+    if (!editor) {
+      return MARK_ABSENT;
+    }
+
+    try {
+      const selection = editor.selection;
+      if (!selection || !SlateRange.isRange(selection)) {
+        return MARK_ABSENT;
+      }
+
+      const textNodes = Array.from(
+        Editor.nodes(editor, {
+          at: selection,
+          match: (node) => Text.isText(node),
+          mode: 'all',
+        })
+      ).map(([node]) => node as Record<string, unknown>);
+
+      if (textNodes.length === 0) {
+        const marks = Editor.marks(editor as any) as Record<string, unknown> | null;
+        if (!marks || !(format in marks)) {
+          return MARK_ABSENT;
+        }
+
+        return marks[format] as MarkStateValue;
+      }
+
+      let initialized = false;
+      let firstValue: unknown;
+      for (const node of textNodes) {
+        const hasProperty = Object.prototype.hasOwnProperty.call(node, format);
+        const value = hasProperty ? node[format] : undefined;
+
+        if (!initialized) {
+          initialized = true;
+          firstValue = value;
+          continue;
+        }
+
+        if (firstValue !== value) {
+          return MARK_MIXED;
+        }
+      }
+
+      if (!initialized || firstValue === undefined) {
+        return MARK_ABSENT;
+      }
+
+      return firstValue as MarkStateValue;
+    } catch {
+      return MARK_ABSENT;
+    }
+  }, [getActiveEditor, MARK_ABSENT, MARK_MIXED]);
+
+  const isActiveTextMark = useCallback((format: string): boolean => (
+    readActiveTextMark(format) === true
+  ), [readActiveTextMark]);
+
   const stopBubble = useCallback((event: React.MouseEvent) => {
     event.stopPropagation();
   }, []);
 
   const runMark = useCallback((format: string, value?: any) => {
-    runForTextSelectionOrCaret(() => {
+    const normalizedValue = value === undefined || value === '' ? '' : value;
+    const runResult = runForTextSelectionOrCaret(() => {
       const editor = getActiveEditor();
       if (!editor) {
         return;
       }
 
-      if (value === undefined || value === '') {
+      if (normalizedValue === '') {
         Editor.removeMark(editor as any, format);
-        return;
+      } else {
+        Editor.addMark(editor as any, format, normalizedValue);
       }
-
-      Editor.addMark(editor as any, format, value);
     });
-  }, [getActiveEditor, runForTextSelectionOrCaret]);
+    syncCollapsedFormatStateAfterWholeSelection(
+      runResult,
+      format,
+      normalizedValue === '' ? MARK_ABSENT : normalizedValue,
+    );
+  }, [runForTextSelectionOrCaret, syncCollapsedFormatStateAfterWholeSelection, getActiveEditor]);
 
   const toggleTextMark = useCallback((format: string) => {
-    runForTextSelectionOrCaret(() => {
+    const isActive = readActiveTextMark(format) === true;
+    const nextValue: MarkStateValue = isActive ? MARK_ABSENT : true;
+    const runResult = runForTextSelectionOrCaret(() => {
       const editor = getActiveEditor();
       if (!editor) {
         return;
       }
 
-      if (isMarkActive(format)) {
+      if (isActive) {
         Editor.removeMark(editor as any, format);
       } else {
         Editor.addMark(editor as any, format, true);
       }
     });
-  }, [getActiveEditor, isMarkActive, runForTextSelectionOrCaret]);
+    syncCollapsedFormatStateAfterWholeSelection(
+      runResult,
+      format,
+      nextValue,
+    );
+  }, [getActiveEditor, readActiveTextMark, runForTextSelectionOrCaret, syncCollapsedFormatStateAfterWholeSelection]);
 
   const insertTextAtSelection = useCallback((text: string) => {
     if (!text) {
@@ -433,22 +671,12 @@ export function RichTextFormatting({
     }
 
     runForTextSelectionOrCaret(() => {
-      const editor = getActiveEditor();
-      if (!editor) {
-        return;
-      }
-
-      Transforms.insertText(editor as any, text);
+      insertText(text);
     });
-  }, [getActiveEditor, runForTextSelectionOrCaret]);
+  }, [insertText, runForTextSelectionOrCaret]);
 
   const clearRichTextFormatting = useCallback(() => {
     runForTextSelectionOrCaret(() => {
-      const editor = getActiveEditor();
-      if (!editor) {
-        return;
-      }
-
       const marks = [
         'bold',
         'italic',
@@ -464,10 +692,10 @@ export function RichTextFormatting({
       ];
 
       marks.forEach((mark) => {
-        Editor.removeMark(editor as any, mark);
+        removeMark(mark);
       });
     });
-  }, [getActiveEditor, runForTextSelectionOrCaret]);
+  }, [removeMark, runForTextSelectionOrCaret]);
 
   const [showEmojiPicker, setShowEmojiPicker] = useState(false);
   const [emojiPickerPosition, setEmojiPickerPosition] = useState<{ x: number; y: number } | null>(null);
@@ -522,62 +750,6 @@ export function RichTextFormatting({
     };
   }, [showEmojiPicker]);
 
-  const readActiveTextMark = useCallback((format: string): MarkStateValue => {
-    const editor = getActiveEditor();
-    if (!editor) {
-      return MARK_ABSENT;
-    }
-
-    try {
-      const selection = editor.selection;
-      if (!selection || !SlateRange.isRange(selection)) {
-        return MARK_ABSENT;
-      }
-
-      const textNodes = Array.from(
-        Editor.nodes(editor, {
-          at: selection,
-          match: (node) => Text.isText(node),
-          mode: 'all',
-        })
-      ).map(([node]) => node as Record<string, unknown>);
-
-      if (textNodes.length === 0) {
-        const marks = Editor.marks(editor as any) as Record<string, unknown> | null;
-        if (!marks || !(format in marks)) {
-          return MARK_ABSENT;
-        }
-
-        return marks[format] as MarkStateValue;
-      }
-
-      let initialized = false;
-      let firstValue: unknown;
-      for (const node of textNodes) {
-        const hasProperty = Object.prototype.hasOwnProperty.call(node, format);
-        const value = hasProperty ? node[format] : undefined;
-
-        if (!initialized) {
-          initialized = true;
-          firstValue = value;
-          continue;
-        }
-
-        if (firstValue !== value) {
-          return MARK_MIXED;
-        }
-      }
-
-      if (!initialized || firstValue === undefined) {
-        return MARK_ABSENT;
-      }
-
-      return firstValue as MarkStateValue;
-    } catch {
-      return MARK_ABSENT;
-    }
-  }, [getActiveEditor, MARK_ABSENT, MARK_MIXED]);
-
   useEffect(() => {
     return () => {
       if (pendingActionRef.current) {
@@ -794,7 +966,7 @@ export function RichTextFormatting({
             }}
           className={cn(
             "w-8 h-8 rounded border border-border grid place-items-center",
-            isMarkActive('bold') && canApplySelection ? "bg-primary text-primary-foreground border-primary" : "hover:bg-accent"
+            isActiveTextMark('bold') && canApplySelection ? "bg-primary text-primary-foreground border-primary" : "hover:bg-accent"
           )}
           title={canInteract ? 'Bold' : 'Enable text edit on canvas to use'}
         >
@@ -812,7 +984,7 @@ export function RichTextFormatting({
             }}
           className={cn(
             "w-8 h-8 rounded border border-border grid place-items-center",
-            isMarkActive('italic') && canApplySelection ? "bg-primary text-primary-foreground border-primary" : "hover:bg-accent"
+            isActiveTextMark('italic') && canApplySelection ? "bg-primary text-primary-foreground border-primary" : "hover:bg-accent"
           )}
           title={canInteract ? 'Italic' : 'Enable text edit on canvas to use'}
         >
@@ -830,7 +1002,7 @@ export function RichTextFormatting({
             }}
           className={cn(
             "w-8 h-8 rounded border border-border grid place-items-center",
-            isMarkActive('underline') && canApplySelection ? "bg-primary text-primary-foreground border-primary" : "hover:bg-accent"
+            isActiveTextMark('underline') && canApplySelection ? "bg-primary text-primary-foreground border-primary" : "hover:bg-accent"
           )}
           title={canInteract ? 'Underline' : 'Enable text edit on canvas to use'}
         >
@@ -848,7 +1020,7 @@ export function RichTextFormatting({
             }}
           className={cn(
             "w-8 h-8 rounded border border-border grid place-items-center",
-            isMarkActive('strikethrough') && canApplySelection ? "bg-primary text-primary-foreground border-primary" : "hover:bg-accent"
+            isActiveTextMark('strikethrough') && canApplySelection ? "bg-primary text-primary-foreground border-primary" : "hover:bg-accent"
           )}
           title={canInteract ? 'Strikethrough' : 'Enable text edit on canvas to use'}
         >
@@ -866,7 +1038,7 @@ export function RichTextFormatting({
             }}
           className={cn(
             "w-8 h-8 rounded border border-border grid place-items-center",
-            isMarkActive('code') && canApplySelection ? "bg-primary text-primary-foreground border-primary" : "hover:bg-accent"
+            isActiveTextMark('code') && canApplySelection ? "bg-primary text-primary-foreground border-primary" : "hover:bg-accent"
           )}
           title={canInteract ? 'Inline code' : 'Enable text edit on canvas to use'}
         >
diff --git a/apps/admin/src/components/editor/blocks/RichTextBlock.tsx b/apps/admin/src/components/editor/blocks/RichTextBlock.tsx
index d80570a..98115d2 100644
--- a/apps/admin/src/components/editor/blocks/RichTextBlock.tsx
+++ b/apps/admin/src/components/editor/blocks/RichTextBlock.tsx
@@ -188,9 +188,6 @@ export function RichTextBlock({
       style={style}
       data-backy-text-editor="true"
             data-backy-text-editor-editable={String(!!isEditable)}
-            onDoubleClick={() => {
-                // Allow bubbling to parent to trigger "Edit Mode"
-            }}
         >
             <BackyEditor
                 key={isEditable ? 'editable' : 'readonly'}
diff --git a/apps/admin/src/components/editor/editorCatalog.ts b/apps/admin/src/components/editor/editorCatalog.ts
index 0158742..05e60fa 100644
--- a/apps/admin/src/components/editor/editorCatalog.ts
+++ b/apps/admin/src/components/editor/editorCatalog.ts
@@ -293,6 +293,22 @@ export const CANVAS_COMPONENT_LIBRARY: ComponentLibraryItem[] = [
     defaultSize: { width: 250, height: 40 },
     description: 'Text input field',
   },
+  {
+    type: 'input',
+    name: 'File input field',
+    icon: 'FormInput',
+    category: 'form',
+    defaultProps: {
+      label: 'Upload file',
+      name: 'file',
+      inputType: 'file',
+      required: false,
+      borderRadius: 4,
+      borderColor: '#d1d5db',
+    },
+    defaultSize: { width: 260, height: 48 },
+    description: 'File input field',
+  },
   {
     type: 'textarea',
     name: 'Multi-line text input',
@@ -416,6 +432,12 @@ export const CANVAS_COMPONENT_LIBRARY: ComponentLibraryItem[] = [
       commentAllowReplies: true,
       commentModerationMode: 'manual',
       commentSortOrder: 'newest',
+      commentAntiAbuseRateLimit: 12,
+      commentAntiAbuseRateWindowMs: 45000,
+      commentAntiAbuseSignatureWindowMs: 300000,
+      commentAntiAbuseMinFillMs: 900,
+      commentAntiAbuseAutoBlockSpamCount: 6,
+      commentAntiAbuseAutoBlockDurationMinutes: 120,
     },
     defaultSize: { width: 360, height: 320 },
     description: 'Moderated public comment thread',
diff --git a/apps/admin/src/components/layout/Header.tsx b/apps/admin/src/components/layout/Header.tsx
index 6180c68..61bce23 100644
--- a/apps/admin/src/components/layout/Header.tsx
+++ b/apps/admin/src/components/layout/Header.tsx
@@ -22,7 +22,7 @@ import {
   ChevronDown,
 } from 'lucide-react';
 import { cn } from '@/lib/utils';
-import { useAuthStore } from '@/stores/authStore';
+import { useAuthStore, selectCanAdminister } from '@/stores/authStore';
 
 // ============================================
 // TYPES
@@ -41,6 +41,7 @@ export function Header({ sidebarCollapsed, onSidebarToggle }: HeaderProps) {
   const navigate = useNavigate();
   const routerState = useRouterState();
   const { user, signOut } = useAuthStore();
+  const canAdminister = useAuthStore(selectCanAdminister);
   const [userMenuOpen, setUserMenuOpen] = useState(false);
 
   // Get page title from route
@@ -59,7 +60,7 @@ export function Header({ sidebarCollapsed, onSidebarToggle }: HeaderProps) {
   const handleSignOut = () => {
     signOut();
     setUserMenuOpen(false);
-    navigate({ to: '/login' });
+    navigate({ to: '/login', replace: true });
   };
 
   return (
@@ -122,27 +123,31 @@ export function Header({ sidebarCollapsed, onSidebarToggle }: HeaderProps) {
                 onClick={() => setUserMenuOpen(false)}
               />
               <div className="absolute right-0 top-full mt-2 w-48 bg-card border border-border rounded-lg shadow-lg z-20 py-1">
-                <button
-                  onClick={() => {
-                    setUserMenuOpen(false);
-                    navigate({ to: '/settings' });
-                  }}
-                  className="flex items-center gap-2 px-4 py-2 text-sm hover:bg-accent w-full text-left"
-                >
-                  <User className="w-4 h-4" />
-                  Profile
-                </button>
-                <button
-                  onClick={() => {
-                    setUserMenuOpen(false);
-                    navigate({ to: '/settings' });
-                  }}
-                  className="flex items-center gap-2 px-4 py-2 text-sm hover:bg-accent w-full text-left"
-                >
-                  <Settings className="w-4 h-4" />
-                  Settings
-                </button>
-                <hr className="my-1 border-border" />
+                {canAdminister ? (
+                  <>
+                    <button
+                      onClick={() => {
+                        setUserMenuOpen(false);
+                        navigate({ to: '/settings' });
+                      }}
+                      className="flex items-center gap-2 px-4 py-2 text-sm hover:bg-accent w-full text-left"
+                    >
+                      <User className="w-4 h-4" />
+                      Profile
+                    </button>
+                    <button
+                      onClick={() => {
+                        setUserMenuOpen(false);
+                        navigate({ to: '/settings' });
+                      }}
+                      className="flex items-center gap-2 px-4 py-2 text-sm hover:bg-accent w-full text-left"
+                    >
+                      <Settings className="w-4 h-4" />
+                      Settings
+                    </button>
+                    <hr className="my-1 border-border" />
+                  </>
+                ) : null}
                 <button
                   onClick={handleSignOut}
                   className="flex items-center gap-2 px-4 py-2 text-sm text-red-600 hover:bg-red-50 w-full text-left"
diff --git a/apps/admin/src/components/layout/Sidebar.tsx b/apps/admin/src/components/layout/Sidebar.tsx
index 3c120e0..ec34368 100644
--- a/apps/admin/src/components/layout/Sidebar.tsx
+++ b/apps/admin/src/components/layout/Sidebar.tsx
@@ -24,6 +24,7 @@ import {
   ChevronRight,
 } from 'lucide-react';
 import { cn } from '@/lib/utils';
+import { useAuthStore, selectCanAdminister } from '@/stores/authStore';
 
 // ============================================
 // TYPES
@@ -45,6 +46,8 @@ interface NavItem {
   icon: React.ElementType;
   /** Badge text (optional) */
   badge?: string;
+  /** Restrict this item to administrators */
+  adminOnly?: boolean;
 }
 
 // ============================================
@@ -60,8 +63,8 @@ const NAV_ITEMS: NavItem[] = [
   { label: 'Pages', to: '/pages', icon: FileText },
   { label: 'Blog', to: '/blog', icon: Newspaper },
   { label: 'Media', to: '/media', icon: Image },
-  { label: 'Users', to: '/users', icon: Users },
-  { label: 'Settings', to: '/settings', icon: Settings },
+  { label: 'Users', to: '/users', icon: Users, adminOnly: true },
+  { label: 'Settings', to: '/settings', icon: Settings, adminOnly: true },
 ];
 
 // ============================================
@@ -78,6 +81,7 @@ const NAV_ITEMS: NavItem[] = [
  */
 export function Sidebar({ collapsed, onToggle }: SidebarProps) {
   const location = useLocation();
+  const canAdminister = useAuthStore(selectCanAdminister);
 
   return (
     <aside
@@ -106,6 +110,10 @@ export function Sidebar({ collapsed, onToggle }: SidebarProps) {
       {/* Navigation */}
       <nav className="flex-1 py-4 px-2 space-y-1 overflow-y-auto">
         {NAV_ITEMS.map((item) => {
+          if (item.adminOnly && !canAdminister) {
+            return null;
+          }
+
           const Icon = item.icon;
           const isActive = location.pathname === item.to ||
             location.pathname.startsWith(`${item.to}/`);
diff --git a/apps/admin/src/routes/__root.tsx b/apps/admin/src/routes/__root.tsx
index 0edaef2..7792309 100644
--- a/apps/admin/src/routes/__root.tsx
+++ b/apps/admin/src/routes/__root.tsx
@@ -3,64 +3,129 @@
  * BACKY CMS - ROOT ROUTE
  * ============================================================================
  *
- * The root route that wraps all other routes. It provides the main layout
- * for authenticated routes, but NOT for login.
+ * The root route wraps all routes and performs auth/permission gating.
  *
  * @module RootRoute
  * @author Backy CMS Team
  * @license MIT
  */
 
-import { useNavigate, createRootRoute, Outlet, useRouterState } from '@tanstack/react-router';
-import { Suspense, useEffect } from 'react';
+import { createRootRoute, Outlet, useNavigate, useRouterState } from '@tanstack/react-router';
+import { Suspense, useEffect, useMemo } from 'react';
 import { MainLayout } from '@/components/layout/MainLayout';
 import { LoadingScreen } from '@/components/ui/LoadingScreen';
-import { useAuthStore } from '@/stores/authStore';
+import { selectCanAdminister, selectCanEdit, selectIsAuthenticated, useAuthStore } from '@/stores/authStore';
 
-// ============================================
-// ROOT ROUTE
-// ============================================
+const isEditorOnlyPath = (pathname: string): boolean => (
+  pathname.startsWith('/pages/') ||
+  pathname === '/blog/new' ||
+  (pathname.startsWith('/blog/') && pathname !== '/blog') ||
+  pathname === '/media' ||
+  pathname.startsWith('/media/') ||
+  pathname === '/sites/new' ||
+  (pathname.startsWith('/sites/') && pathname !== '/sites') ||
+  pathname.startsWith('/users/')
+);
+
+const isAdminOnlyPath = (pathname: string): boolean => (
+  pathname === '/settings' ||
+  pathname.startsWith('/settings/') ||
+  pathname === '/users' ||
+  pathname.startsWith('/users/')
+);
+
+const getSessionTimeoutDelay = (sessionExpiresAt: number | null): number | null => {
+  if (!sessionExpiresAt) {
+    return null;
+  }
+
+  const remainingMs = sessionExpiresAt - Date.now();
+  if (remainingMs <= 0) {
+    return 0;
+  }
+
+  return remainingMs;
+};
 
 export const Route = createRootRoute({
   component: RootComponent,
 });
 
-// ============================================
-// ROOT COMPONENT
-// ============================================
-
-/**
- * Root Component
- *
- * Wraps authenticated routes with MainLayout.
- * Login page renders WITHOUT the layout.
- */
 function RootComponent() {
-  const navigate = useNavigate();
   const routerState = useRouterState();
   const pathname = routerState.location.pathname;
-  const isAuthenticated = useAuthStore((state) => !!state.user);
+  const navigate = useNavigate();
+  const sessionExpiresAt = useAuthStore((state) => state.sessionExpiresAt);
+  const signOut = useAuthStore((state) => state.signOut);
+  const isAuthenticated = useAuthStore(selectIsAuthenticated);
+  const canEdit = useAuthStore(selectCanEdit);
+  const canAdminister = useAuthStore(selectCanAdminister);
+  const isAuthHydrated = useAuthStore((state) => state.isHydrated);
+  const timeoutMs = useMemo(() => getSessionTimeoutDelay(sessionExpiresAt), [sessionExpiresAt]);
 
-  // Routes that should NOT have the main layout
   const publicRoutes = ['/login', '/forgot-password', '/reset-password'];
-  const isPublicRoute = publicRoutes.some(route => pathname.startsWith(route));
+  const isPublicRoute = publicRoutes.some((route) => pathname.startsWith(route));
+  const redirectTo = useMemo(() => {
+    if (!isAuthHydrated) {
+      return null;
+    }
 
-  useEffect(() => {
     if (!isPublicRoute && !isAuthenticated) {
-      navigate({ to: '/login', replace: true });
+      return '/login';
     }
-  }, [isAuthenticated, isPublicRoute, navigate]);
 
-  // Public routes render without layout
-  if (isPublicRoute) {
+    if (isPublicRoute && isAuthenticated && pathname === '/login') {
+      return '/';
+    }
+
+    if (!canEdit && isEditorOnlyPath(pathname)) {
+      return '/';
+    }
+
+    if (!canAdminister && isAdminOnlyPath(pathname)) {
+      return '/';
+    }
+
+    return null;
+  }, [isAuthHydrated, isPublicRoute, isAuthenticated, canEdit, canAdminister, pathname]);
+
+  useEffect(() => {
+    if (redirectTo && pathname !== redirectTo) {
+      navigate({ to: redirectTo, replace: true });
+    }
+  }, [pathname, navigate, redirectTo]);
+
+  useEffect(() => {
+    if (!isAuthHydrated || isPublicRoute || timeoutMs === null || !isAuthenticated) {
+      return;
+    }
+
+    if (timeoutMs === 0) {
+      signOut();
+      return;
+    }
+
+    const timer = window.setTimeout(() => {
+      signOut();
+    }, timeoutMs);
+
+    return () => {
+      window.clearTimeout(timer);
+    };
+  }, [isAuthHydrated, isPublicRoute, isAuthenticated, timeoutMs, signOut]);
+
+  if (!isAuthHydrated) {
     return (
       <Suspense fallback={<LoadingScreen />}>
-        <Outlet />
+        <LoadingScreen />
       </Suspense>
     );
   }
 
-  if (!isAuthenticated) {
+  if (redirectTo) {
+    if (pathname !== redirectTo) {
+      return null;
+    }
     return (
       <Suspense fallback={<LoadingScreen />}>
         <LoadingScreen />
@@ -68,7 +133,15 @@ function RootComponent() {
     );
   }
 
-  // Authenticated routes get the full layout
+  if (isPublicRoute) {
+
+    return (
+      <Suspense fallback={<LoadingScreen />}>
+        <Outlet />
+      </Suspense>
+    );
+  }
+
   return (
     <Suspense fallback={<LoadingScreen />}>
       <MainLayout>
diff --git a/apps/admin/src/routes/blog.$postId.tsx b/apps/admin/src/routes/blog.$postId.tsx
index dc16543..9ddffbf 100644
--- a/apps/admin/src/routes/blog.$postId.tsx
+++ b/apps/admin/src/routes/blog.$postId.tsx
@@ -2,13 +2,14 @@
  * BACKY CMS - EDIT BLOG POST (HYBRID LAYOUT)
  */
 
-import { useState, useMemo } from 'react';
+import { useEffect, useState, useMemo } from 'react';
 import { createFileRoute, useNavigate } from '@tanstack/react-router';
 import { ArrowLeft, Save, FileText, Trash2 } from 'lucide-react';
 import { useStore } from '@/stores/mockStore';
 import { PageShell } from '@/components/layout/PageShell';
 import { CanvasEditor } from '@/components/editor/CanvasEditor';
 import { cn } from '@/lib/utils';
+import { useAuthStore, selectCanEdit } from '@/stores/authStore';
 import type { CanvasElement } from '@/types/editor';
 import type { CanvasSize } from '@/types/editor';
 import type { PageSettings } from '@/components/editor/PageSettingsModal';
@@ -26,6 +27,7 @@ function EditBlogPostPage() {
     const navigate = useNavigate();
     const { postId } = Route.useParams();
     const { posts, updatePost, deletePost } = useStore();
+    const canEdit = useAuthStore(selectCanEdit);
     const post = posts.find((p) => p.id === postId);
 
     const [isLoading, setIsLoading] = useState(false);
@@ -62,9 +64,76 @@ function EditBlogPostPage() {
       ];
     }, [post, savedElements]);
 
+    const buildFallbackElements = (postRecord: {
+      id?: string;
+      content?: string;
+      title?: string;
+    }): CanvasElement[] => {
+      const fallbackContent = postRecord.id
+        ? postRecord.content?.trim() || 'Start writing...'
+        : 'Start writing...';
+
+      return [
+        createCanvasElement('text', 50, 50, {
+          width: 800,
+          height: 600,
+          props: {
+            content: fallbackContent,
+            fontSize: 18,
+            lineHeight: 1.6,
+            color: '#334155',
+          },
+        }),
+      ];
+    };
+
+    const [editorSeedElements, setEditorSeedElements] = useState<CanvasElement[]>(initialElements);
+    const [editorSeedSize, setEditorSeedSize] = useState<CanvasSize>(savedCanvasSize);
     const [canvasElements, setCanvasElements] = useState<CanvasElement[]>(initialElements);
     const [canvasSize, setCanvasSize] = useState<CanvasSize>(savedCanvasSize);
 
+    useEffect(() => {
+      const fallbackElements = savedElements.length
+        ? savedElements
+        : buildFallbackElements({
+            id: post?.id,
+            title: post?.title,
+            content: post?.content,
+          });
+
+      setEditorSeedElements(fallbackElements);
+      setEditorSeedSize(savedCanvasSize);
+      setCanvasElements(fallbackElements);
+      setCanvasSize(savedCanvasSize);
+    }, [initialElements, post?.content, savedCanvasSize, savedElements, post?.id, post?.title]);
+
+    const handleCanvasSave = (elements: CanvasElement[], _settings: PageSettings, size?: CanvasSize) => {
+      setCanvasElements(elements);
+      if (size) {
+        setCanvasSize(size);
+      }
+      return true;
+    };
+
+    const handleCanvasReload = () => {
+      const latestPost = posts.find((item) => item.id === postId);
+      if (!latestPost) {
+        return;
+      }
+
+      const { elements: persistedElements, canvasSize: persistedSize } = normalizeSavedCanvasContent(
+        latestPost.content
+      );
+      const nextElements = persistedElements.length
+        ? persistedElements
+        : buildFallbackElements(latestPost);
+
+      setEditorSeedElements(nextElements);
+      setEditorSeedSize(persistedSize);
+      setCanvasElements(nextElements);
+      setCanvasSize(persistedSize);
+    };
+
     if (!post) {
         return (
             <PageShell title="Post Not Found" description="The article you requested doesn't exist.">
@@ -84,6 +153,10 @@ function EditBlogPostPage() {
 
     const handleSubmit = async (e: React.FormEvent) => {
         e.preventDefault();
+        if (!canEdit) {
+            alert('You do not have permission to update posts.');
+            return;
+        }
         setIsLoading(true);
         await new Promise(resolve => setTimeout(resolve, 800));
 
@@ -102,6 +175,10 @@ function EditBlogPostPage() {
 
     const handleDelete = () => {
         if (confirm('Are you sure you want to delete this post?')) {
+            if (!canEdit) {
+                alert('You do not have permission to delete posts.');
+                return;
+            }
             deletePost(postId);
             navigate({ to: '/blog' });
         }
@@ -132,13 +209,20 @@ function EditBlogPostPage() {
                                     type="text"
                                     value={title}
                                     onChange={(e) => setTitle(e.target.value)}
+                                    disabled={!canEdit}
                                     placeholder="Post Title"
                                     className="w-full text-4xl font-bold bg-transparent border-none placeholder:text-muted-foreground/50 focus:ring-0 px-0"
                                 />
                             </div>
+                            {!canEdit ? (
+                                <div className="text-xs text-muted-foreground border border-border rounded-lg px-2 py-1.5 h-fit">
+                                    View-only role: edits are disabled.
+                                </div>
+                            ) : null}
                             <button
                                 type="button"
                                 onClick={handleDelete}
+                                hidden={!canEdit}
                                 className="text-destructive hover:bg-destructive/10 p-2 rounded-lg"
                                 title="Delete Post"
                             >
@@ -153,6 +237,7 @@ function EditBlogPostPage() {
                                 type="text"
                                 value={slug}
                                 onChange={(e) => setSlug(e.target.value)}
+                                disabled={!canEdit}
                                 className="bg-transparent border-none focus:ring-0 p-0 text-foreground font-mono w-full"
                                 placeholder="post-slug"
                             />
@@ -163,10 +248,12 @@ function EditBlogPostPage() {
                     <div className="h-[800px] border border-border rounded-xl overflow-hidden bg-background shadow-sm relative">
                         <CanvasEditor
                             mode="blog"
-                            initialElements={initialElements}
+                            initialElements={editorSeedElements}
                             initialSettings={dummySettings}
-                            initialSize={canvasSize}
-                            onSave={() => { }}
+                            initialSize={editorSeedSize}
+                            onSave={handleCanvasSave}
+                            onReload={handleCanvasReload}
+                            readOnly={!canEdit}
                             onChange={(elements, _settings, size) => {
                                 setCanvasElements(elements);
                                 if (size) setCanvasSize(size);
@@ -193,10 +280,11 @@ function EditBlogPostPage() {
                             <div>
                                 <label className="block text-sm font-medium mb-2">Status</label>
                                 <select
-                                    value={status}
-                                    onChange={(e) => setStatus(e.target.value as any)}
-                                    className="w-full px-4 py-2.5 rounded-lg border bg-background"
-                                >
+                                value={status}
+                                onChange={(e) => setStatus(e.target.value as any)}
+                                disabled={!canEdit}
+                                className="w-full px-4 py-2.5 rounded-lg border bg-background"
+                            >
                                     <option value="draft">Draft</option>
                                     <option value="published">Published</option>
                                 </select>
@@ -206,6 +294,7 @@ function EditBlogPostPage() {
                                 <textarea
                                     value={excerpt}
                                     onChange={(e) => setExcerpt(e.target.value)}
+                                    disabled={!canEdit}
                                     rows={2}
                                     className="w-full px-4 py-2.5 rounded-lg border bg-background resize-none"
                                     placeholder="Short summary..."
@@ -226,6 +315,7 @@ function EditBlogPostPage() {
                         <button
                             type="submit"
                             disabled={isLoading || !title}
+                            hidden={!canEdit}
                             className={cn(
                                 'flex items-center gap-2 px-6 py-2.5 rounded-lg',
                                 'bg-primary text-primary-foreground font-medium',
diff --git a/apps/admin/src/routes/blog.new.tsx b/apps/admin/src/routes/blog.new.tsx
index 6def7bd..4631756 100644
--- a/apps/admin/src/routes/blog.new.tsx
+++ b/apps/admin/src/routes/blog.new.tsx
@@ -9,7 +9,7 @@ import { useStore } from '@/stores/mockStore';
 import { PageShell } from '@/components/layout/PageShell';
 import { CanvasEditor } from '@/components/editor/CanvasEditor';
 import { cn } from '@/lib/utils';
-import { useAuthStore } from '@/stores/authStore';
+import { useAuthStore, selectCanEdit } from '@/stores/authStore';
 import type { CanvasElement } from '@/types/editor';
 import type { CanvasSize } from '@/types/editor';
 import type { PageSettings } from '@/components/editor/PageSettingsModal';
@@ -27,6 +27,7 @@ function NewBlogPostPage() {
     const navigate = useNavigate();
     const { addPost } = useStore();
     const { user } = useAuthStore();
+    const canEdit = useAuthStore(selectCanEdit);
 
     const [isLoading, setIsLoading] = useState(false);
 
@@ -50,9 +51,26 @@ function NewBlogPostPage() {
         }),
     ], []);
 
+    const [editorSeedElements, setEditorSeedElements] = useState<CanvasElement[]>(initialElements);
+    const [editorSeedSize, setEditorSeedSize] = useState<CanvasSize>(DEFAULT_CANVAS_SIZE);
     const [canvasElements, setCanvasElements] = useState<CanvasElement[]>(initialElements);
     const [canvasSize, setCanvasSize] = useState<CanvasSize>(DEFAULT_CANVAS_SIZE);
 
+    const handleCanvasSave = (elements: CanvasElement[], _settings: PageSettings, size?: CanvasSize) => {
+        setCanvasElements(elements);
+        if (size) {
+            setCanvasSize(size);
+        }
+        return true;
+    };
+
+    const handleCanvasReload = () => {
+        setEditorSeedElements(initialElements);
+        setEditorSeedSize(DEFAULT_CANVAS_SIZE);
+        setCanvasElements(initialElements);
+        setCanvasSize(DEFAULT_CANVAS_SIZE);
+    };
+
     // Dummy settings for CanvasEditor (since we manage settings externally)
     const dummySettings: PageSettings = {
         title,
@@ -63,6 +81,10 @@ function NewBlogPostPage() {
 
     const handleSubmit = async (e: React.FormEvent) => {
         e.preventDefault();
+        if (!canEdit) {
+            alert('You do not have permission to create posts.');
+            return;
+        }
         setIsLoading(true);
         await new Promise(resolve => setTimeout(resolve, 800));
 
@@ -111,6 +133,7 @@ function NewBlogPostPage() {
                                 }}
                                 placeholder="Post Title"
                                 className="w-full text-4xl font-bold bg-transparent border-none placeholder:text-muted-foreground/50 focus:ring-0 px-0"
+                                disabled={!canEdit}
                                 autoFocus
                             />
                         </div>
@@ -124,6 +147,7 @@ function NewBlogPostPage() {
                                 onChange={(e) => setSlug(e.target.value)}
                                 className="bg-transparent border-none focus:ring-0 p-0 text-foreground font-mono w-full"
                                 placeholder="post-slug"
+                                disabled={!canEdit}
                             />
                         </div>
                     </div>
@@ -132,10 +156,12 @@ function NewBlogPostPage() {
                     <div className="h-[800px] border border-border rounded-xl overflow-hidden bg-background shadow-sm relative">
                         <CanvasEditor
                             mode="blog"
-                            initialElements={initialElements}
+                            initialElements={editorSeedElements}
                             initialSettings={dummySettings}
-                            initialSize={canvasSize}
-                            onSave={() => { }} // Disabled internal save
+                            initialSize={editorSeedSize}
+                            onSave={handleCanvasSave}
+                            onReload={handleCanvasReload}
+                            readOnly={!canEdit}
                             onChange={(elements, _settings, size) => {
                                 setCanvasElements(elements);
                                 if (size) setCanvasSize(size);
@@ -159,6 +185,7 @@ function NewBlogPostPage() {
                                 <select
                                     value={status}
                                     onChange={(e) => setStatus(e.target.value as any)}
+                                    disabled={!canEdit}
                                     className="w-full px-4 py-2.5 rounded-lg border bg-background"
                                 >
                                     <option value="draft">Draft</option>
@@ -170,6 +197,7 @@ function NewBlogPostPage() {
                                 <textarea
                                     value={excerpt}
                                     onChange={(e) => setExcerpt(e.target.value)}
+                                    disabled={!canEdit}
                                     rows={2}
                                     className="w-full px-4 py-2.5 rounded-lg border bg-background resize-none"
                                     placeholder="Short summary..."
@@ -180,6 +208,11 @@ function NewBlogPostPage() {
 
                     {/* Footer Actions */}
                     <div className="flex justify-end gap-3 sticky bottom-4 z-50">
+                        {!canEdit ? (
+                            <div className="text-xs text-muted-foreground border border-border rounded-lg px-3 py-2 h-fit">
+                                View-only role: posts are read-only.
+                            </div>
+                        ) : null}
                         <button
                             type="button"
                             onClick={() => navigate({ to: '/blog' })}
@@ -190,6 +223,7 @@ function NewBlogPostPage() {
                         <button
                             type="submit"
                             disabled={isLoading || !title}
+                            hidden={!canEdit}
                             className={cn(
                                 'flex items-center gap-2 px-6 py-2.5 rounded-lg',
                                 'bg-primary text-primary-foreground font-medium',
diff --git a/apps/admin/src/routes/blog.tsx b/apps/admin/src/routes/blog.tsx
index 76bd58c..acf9b8e 100644
--- a/apps/admin/src/routes/blog.tsx
+++ b/apps/admin/src/routes/blog.tsx
@@ -7,13 +7,13 @@
 import { createFileRoute, Link, useNavigate, Outlet, useRouterState } from '@tanstack/react-router';
 import { Plus, FileText, Edit, Trash2 } from 'lucide-react';
 import { useStore, type BlogPost } from '@/stores/mockStore';
+import { useAuthStore, selectCanEdit } from '@/stores/authStore';
 import { useDataTable, type Column } from '@/hooks/useDataTable';
 import { PageShell } from '@/components/layout/PageShell';
 import { DataGrid } from '@/components/ui/DataGrid';
 import { StatusBadge } from '@/components/ui/StatusBadge';
 import { EmptyState } from '@/components/ui/EmptyState';
 import { formatDate } from '@/lib/utils';
-import { useState } from 'react';
 
 export const Route = createFileRoute('/blog')({
   component: BlogLayout,
@@ -32,6 +32,7 @@ function BlogLayout() {
 
 function BlogListView() {
   const navigate = useNavigate();
+  const canEdit = useAuthStore(selectCanEdit);
   const { posts, deletePost } = useStore();
 
   const columns: Column<BlogPost>[] = [
@@ -71,7 +72,7 @@ function BlogListView() {
     {
       key: 'actions',
       label: '',
-      render: (post) => (
+      render: (post) => canEdit ? (
         <div className="flex items-center justify-end gap-2">
           <button
             onClick={() => navigate({ to: '/blog/$postId', params: { postId: post.id } })}
@@ -81,6 +82,9 @@ function BlogListView() {
           </button>
           <button
             onClick={() => {
+              if (!canEdit) {
+                return;
+              }
               if (confirm('Delete this post?')) deletePost(post.id);
             }}
             className="p-2 text-muted-foreground hover:text-red-600 hover:bg-red-50 rounded-lg transition-colors"
@@ -88,7 +92,7 @@ function BlogListView() {
             <Trash2 className="w-4 h-4" />
           </button>
         </div>
-      )
+      ) : null
     }
   ];
 
@@ -113,13 +117,15 @@ function BlogListView() {
       title="Blog Posts"
       description="Manage your blog articles and news."
       action={
-        <Link
-          to="/blog/new"
-          className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-primary text-primary-foreground font-medium hover:bg-primary/90 transition-colors"
-        >
-          <Plus className="w-4 h-4" />
-          New Post
-        </Link>
+        canEdit ? (
+          <Link
+            to="/blog/new"
+            className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-primary text-primary-foreground font-medium hover:bg-primary/90 transition-colors"
+          >
+            <Plus className="w-4 h-4" />
+            New Post
+          </Link>
+        ) : null
       }
     >
       <div className="flex items-center gap-4 mb-6">
@@ -149,13 +155,15 @@ function BlogListView() {
             title="No posts yet"
             description="Write your first blog post to get started."
             action={
-              <Link
-                to="/blog/new"
-                className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-primary text-primary-foreground font-medium hover:bg-primary/90 mt-4"
-              >
-                <Plus className="w-4 h-4" />
-                Create Post
-              </Link>
+              canEdit ? (
+                <Link
+                  to="/blog/new"
+                  className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-primary text-primary-foreground font-medium hover:bg-primary/90 mt-4"
+                >
+                  <Plus className="w-4 h-4" />
+                  Create Post
+                </Link>
+              ) : null
             }
           />
         }
diff --git a/apps/admin/src/routes/login.tsx b/apps/admin/src/routes/login.tsx
index 4869e9c..912b0fa 100644
--- a/apps/admin/src/routes/login.tsx
+++ b/apps/admin/src/routes/login.tsx
@@ -11,7 +11,7 @@
  * @license MIT
  */
 
-import { useEffect, useState } from 'react';
+import { useState } from 'react';
 import { createFileRoute, useNavigate } from '@tanstack/react-router';
 import { Mail, Lock, Eye, EyeOff, Loader2 } from 'lucide-react';
 import { useAuthStore } from '@/stores/authStore';
@@ -41,13 +41,7 @@ export const Route = createFileRoute('/login')({
  */
 function LoginPage() {
   const navigate = useNavigate();
-  const { signIn, isLoading, error, clearError, user } = useAuthStore();
-
-  useEffect(() => {
-    if (user) {
-      navigate({ to: '/' });
-    }
-  }, [user, navigate]);
+  const { signIn, isLoading, error, clearError } = useAuthStore();
 
   // Form state
   const [email, setEmail] = useState('');
@@ -89,7 +83,7 @@ function LoginPage() {
     try {
       await signIn(email, password);
       // Redirect to dashboard on success
-      navigate({ to: '/' });
+      navigate({ to: '/', replace: true });
     } catch {
       // Error is handled by the store
     }
diff --git a/apps/admin/src/routes/media.tsx b/apps/admin/src/routes/media.tsx
index fac03fb..7075498 100644
--- a/apps/admin/src/routes/media.tsx
+++ b/apps/admin/src/routes/media.tsx
@@ -9,6 +9,7 @@ import { PageShell } from '@/components/layout/PageShell';
 import { EmptyState } from '@/components/ui/EmptyState';
 import { cn } from '@/lib/utils'; // Assuming bytes formatting is in utils, or inline it
 import { useStore } from '@/stores/mockStore';
+import { useAuthStore, selectCanEdit } from '@/stores/authStore';
 
 export const Route = createFileRoute('/media')({
   component: MediaPage,
@@ -19,6 +20,7 @@ function MediaPage() {
   const files = useStore((state) => state.media);
   const addMedia = useStore((state) => state.addMedia);
   const deleteMedia = useStore((state) => state.deleteMedia);
+  const canEdit = useAuthStore(selectCanEdit);
 
   const handleDragOver = (e: React.DragEvent) => {
     e.preventDefault();
@@ -30,6 +32,7 @@ function MediaPage() {
   };
 
   const handleFileUpload = (fileList: FileList | null) => {
+    if (!canEdit) return;
     if (!fileList || fileList.length === 0) return;
 
     Array.from(fileList).forEach(file => {
@@ -70,23 +73,32 @@ function MediaPage() {
       description="Manage images and files."
       action={
         <div className="relative">
-          <input
-            type="file"
-            id="header-upload"
-            className="hidden"
-            multiple
-            onChange={(e) => handleFileUpload(e.target.files)}
-          />
-          <label
-            htmlFor="header-upload"
-            className="flex items-center gap-2 px-4 py-2 rounded-lg bg-primary text-primary-foreground font-medium hover:bg-primary/90 cursor-pointer"
-          >
-            <Upload className="w-4 h-4" />
-            Upload
-          </label>
+          {canEdit ? (
+            <>
+              <input
+                type="file"
+                id="header-upload"
+                className="hidden"
+                multiple
+                onChange={(e) => handleFileUpload(e.target.files)}
+              />
+              <label
+                htmlFor="header-upload"
+                className="flex items-center gap-2 px-4 py-2 rounded-lg bg-primary text-primary-foreground font-medium hover:bg-primary/90 cursor-pointer"
+              >
+                <Upload className="w-4 h-4" />
+                Upload
+              </label>
+            </>
+          ) : null}
         </div>
       }
     >
+      {!canEdit ? (
+        <div className="mb-4 border border-border rounded-lg p-3 bg-muted/30 text-sm text-muted-foreground">
+          View-only role: you can browse media but cannot upload or delete files.
+        </div>
+      ) : null}
       {/* Drop Zone */}
       <div
         onDragOver={handleDragOver}
@@ -100,15 +112,18 @@ function MediaPage() {
           "mb-8 border-2 border-dashed rounded-xl p-8 text-center transition-all relative",
           isDragging
             ? "border-primary bg-primary/5 scale-[1.01]"
-            : "border-border hover:border-primary/50"
+            : "border-border hover:border-primary/50",
+          !canEdit ? "pointer-events-none opacity-60" : null
         )}
       >
-        <input
-          type="file"
-          className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
-          multiple
-          onChange={(e) => handleFileUpload(e.target.files)}
-        />
+        {canEdit ? (
+          <input
+            type="file"
+            className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
+            multiple
+            onChange={(e) => handleFileUpload(e.target.files)}
+          />
+        ) : null}
         <div className="w-12 h-12 rounded-full bg-primary/10 flex items-center justify-center mx-auto mb-4 pointer-events-none">
           <Upload className="w-6 h-6 text-primary" />
         </div>
@@ -130,11 +145,19 @@ function MediaPage() {
 
                 {/* Overlay */}
                 <div className="absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center gap-2">
-                  <button className="p-2 bg-white rounded-lg text-red-600 hover:bg-red-50" onClick={() => {
-                    deleteMedia(file.id);
-                  }}>
-                    <Trash2 className="w-4 h-4" />
-                  </button>
+                  {canEdit ? (
+                    <button
+                      className="p-2 bg-white rounded-lg text-red-600 hover:bg-red-50"
+                      onClick={() => {
+                        if (!canEdit) {
+                          return;
+                        }
+                        deleteMedia(file.id);
+                      }}
+                    >
+                      <Trash2 className="w-4 h-4" />
+                    </button>
+                  ) : null}
                 </div>
               </div>
 
diff --git a/apps/admin/src/routes/pages.$pageId.edit.tsx b/apps/admin/src/routes/pages.$pageId.edit.tsx
index e05046e..4f5d030 100644
--- a/apps/admin/src/routes/pages.$pageId.edit.tsx
+++ b/apps/admin/src/routes/pages.$pageId.edit.tsx
@@ -6,19 +6,50 @@
  * Uses the reusable CanvasEditor component with real data persistence.
  */
 
-import { useMemo } from 'react';
+import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
 import { createFileRoute, useNavigate } from '@tanstack/react-router';
 import { CanvasEditor } from '@/components/editor/CanvasEditor';
 import type { CanvasElement, CanvasSize } from '@/types/editor';
 import { PageSettings } from '@/components/editor/PageSettingsModal';
 import { useStore } from '@/stores/mockStore';
 import { PageShell } from '@/components/layout/PageShell';
+import { useAuthStore, selectCanEdit } from '@/stores/authStore';
 import {
   createCanvasElement,
   normalizeSavedCanvasContent,
   serializeCanvasContent,
 } from '@/components/editor/editorCatalog';
 
+const normalizeForComparison = (value: unknown): unknown => {
+  if (value === null || value === undefined) {
+    return value;
+  }
+
+  if (Array.isArray(value)) {
+    return value.map((item) => normalizeForComparison(item));
+  }
+
+  if (typeof value === 'object') {
+    const record = value as Record<string, unknown>;
+    const keys = Object.keys(record).sort();
+    const normalized = keys.reduce<Record<string, unknown>>((acc, key) => {
+      acc[key] = normalizeForComparison(record[key]);
+      return acc;
+    }, {});
+    return normalized;
+  }
+
+  return value;
+};
+
+const buildStableString = (value: unknown): string => JSON.stringify(normalizeForComparison(value));
+
+const buildPageStateFingerprint = (
+  elements: CanvasElement[],
+  size: CanvasSize,
+  settings: PageSettings,
+): string => buildStableString({ elements, size, settings });
+
 export const Route = createFileRoute('/pages/$pageId/edit')({
   component: PageEditorRoute,
 });
@@ -27,6 +58,14 @@ function PageEditorRoute() {
   const navigate = useNavigate();
   const { pageId } = Route.useParams();
   const { pages, updatePage } = useStore();
+  const canEdit = useAuthStore(selectCanEdit);
+  const [isSaving, setIsSaving] = useState(false);
+  const [saveError, setSaveError] = useState<string | null>(null);
+  const lastPersistedContentRef = useRef<string | null>(null);
+  const lastPersistedAtRef = useRef<string | null>(null);
+  const lastPersistedEditorFingerprintRef = useRef<string | null>(null);
+  const lastLocalEditorFingerprintRef = useRef<string | null>(null);
+  const isApplyingRemoteSyncRef = useRef(false);
 
   // Find the page in the store
   const page = pages.find(p => p.id === pageId);
@@ -48,57 +87,316 @@ function PageEditorRoute() {
     [page?.content]
   );
 
+  const buildFallbackElements = (pageRecord: {
+    id?: string;
+    title?: string;
+  }): CanvasElement[] => [
+    createCanvasElement('heading', 100, 100, {
+      id: pageRecord.id || 'page-heading',
+      width: 400,
+      height: 60,
+      props: {
+        content: pageRecord.title || 'New Page',
+        level: 'h1',
+        fontSize: 48,
+        fontWeight: 'bold',
+      },
+    }),
+    createCanvasElement('text', 100, 180, {
+      id: `${pageRecord.id || 'page'}-text`,
+      width: 500,
+      height: 80,
+      props: {
+        content: 'Start building your page...',
+        fontSize: 18,
+        lineHeight: 1.6,
+      },
+    }),
+  ];
+
   const fallbackElements: CanvasElement[] = useMemo(() => {
     if (initialElements.length) {
       return initialElements;
     }
 
-    return [
-      createCanvasElement('heading', 100, 100, {
-        id: page?.id || 'page-heading',
-        width: 400,
-        height: 60,
-        props: {
-          content: page?.title || 'New Page',
-          level: 'h1',
-          fontSize: 48,
-          fontWeight: 'bold',
-        },
-      }),
-      createCanvasElement('text', 100, 180, {
-        id: `${page?.id || 'page'}-text`,
-        width: 500,
-        height: 80,
-        props: {
-          content: 'Start building your page...',
-          fontSize: 18,
-          lineHeight: 1.6,
-        },
-      }),
-    ];
+    return buildFallbackElements(page || {});
   }, [initialElements, page?.id, page?.title]);
 
-  // Load Settings
-  const initialSettings: PageSettings = {
+  const [editorElements, setEditorElements] = useState<CanvasElement[]>(
+    () => initialElements.length ? initialElements : fallbackElements,
+  );
+  const [editorSize, setEditorSize] = useState<CanvasSize>(
+    () => initialCanvasSize,
+  );
+  const [editorSettings, setEditorSettings] = useState<PageSettings>({
     title: page.title,
     slug: page.slug,
     status: page.status,
     meta: page.meta || { title: page.title, description: '' },
+  });
+
+  const buildEditorFingerprint = useCallback((elements: CanvasElement[], canvasSize: CanvasSize, settings: PageSettings) => (
+    buildPageStateFingerprint(elements, canvasSize, settings)
+  ), []);
+
+  const handleEditorChange = useCallback((
+    nextElements: CanvasElement[],
+    nextSettings: PageSettings,
+    nextSize: CanvasSize,
+  ) => {
+    if (isApplyingRemoteSyncRef.current) {
+      return;
+    }
+
+    const nextFingerprint = buildEditorFingerprint(
+      nextElements,
+      nextSize,
+      nextSettings,
+    );
+
+    setEditorElements(nextElements);
+    setEditorSettings(nextSettings);
+    setEditorSize(nextSize);
+    lastLocalEditorFingerprintRef.current = nextFingerprint;
+
+    if (saveError) {
+      setSaveError(null);
+    }
+  }, [buildEditorFingerprint, saveError]);
+
+  useEffect(() => {
+    const currentFingerprint = buildEditorFingerprint(editorElements, editorSize, editorSettings);
+    lastLocalEditorFingerprintRef.current = currentFingerprint;
+  }, [buildEditorFingerprint, editorElements, editorSize, editorSettings]);
+
+  useEffect(() => {
+    const nextEditorRevision = page.lastUpdated || null;
+    const nextEditorElements = initialElements.length ? initialElements : fallbackElements;
+    const nextSettings: PageSettings = {
+      title: page.title,
+      slug: page.slug,
+      status: page.status,
+      meta: page.meta || { title: page.title, description: '' },
+    };
+    const nextFingerprint = buildPageStateFingerprint(
+      nextEditorElements,
+      initialCanvasSize,
+      nextSettings,
+    );
+    const nextContent = page.content || null;
+    const nextSerializedContent = nextContent || serializeCanvasContent(nextEditorElements, initialCanvasSize);
+    const currentFingerprint = buildPageStateFingerprint(
+      editorElements,
+      editorSize,
+      editorSettings,
+    );
+    const isLocalEchoByFingerprint = lastPersistedEditorFingerprintRef.current === nextFingerprint;
+    const isLocalEchoByRevision = Boolean(
+      lastPersistedAtRef.current && lastPersistedAtRef.current === page.lastUpdated,
+    );
+    const isLocalEchoByContent = Boolean(
+      lastPersistedContentRef.current && nextContent && lastPersistedContentRef.current === nextContent,
+    );
+    const isLocalEcho = isLocalEchoByFingerprint
+      || isLocalEchoByRevision
+      || isLocalEchoByContent;
+
+    if (isLocalEcho) {
+      if (nextSerializedContent) {
+        lastPersistedContentRef.current = nextSerializedContent;
+      }
+
+      lastLocalEditorFingerprintRef.current = nextFingerprint;
+      if (nextEditorRevision) {
+        lastPersistedAtRef.current = nextEditorRevision;
+      }
+      if (nextFingerprint) {
+        lastPersistedEditorFingerprintRef.current = nextFingerprint;
+      }
+      setSaveError(null);
+      return;
+    }
+
+    const nextSerializedContentFromLocal = serializeCanvasContent(editorElements, editorSize);
+    const doesLocalContentMatchRemote = Boolean(
+      nextContent && nextSerializedContentFromLocal === nextContent,
+    );
+
+    if (doesLocalContentMatchRemote) {
+      lastLocalEditorFingerprintRef.current = nextFingerprint;
+      if (nextEditorRevision) {
+        lastPersistedAtRef.current = nextEditorRevision;
+      }
+      if (nextSerializedContent) {
+        lastPersistedContentRef.current = nextSerializedContent;
+      }
+      if (nextFingerprint) {
+        lastPersistedEditorFingerprintRef.current = nextFingerprint;
+      }
+      setSaveError(null);
+      return;
+    }
+
+    if (currentFingerprint !== nextFingerprint) {
+      setEditorElements(nextEditorElements);
+    }
+    if (JSON.stringify(editorSize) !== JSON.stringify(initialCanvasSize)) {
+      setEditorSize(initialCanvasSize);
+    }
+    if (JSON.stringify(editorSettings) !== JSON.stringify(nextSettings)) {
+      setEditorSettings(nextSettings);
+    }
+
+    if (nextEditorRevision) {
+      lastPersistedAtRef.current = nextEditorRevision;
+    }
+    if (nextSerializedContent) {
+      lastPersistedContentRef.current = nextSerializedContent;
+    }
+
+    lastPersistedEditorFingerprintRef.current = nextFingerprint;
+    lastLocalEditorFingerprintRef.current = nextFingerprint;
+
+    isApplyingRemoteSyncRef.current = true;
+    Promise.resolve().then(() => {
+      isApplyingRemoteSyncRef.current = false;
+    });
+    setSaveError(null);
+  }, [
+    editorElements,
+    editorSize,
+    editorSettings,
+    fallbackElements,
+    initialCanvasSize,
+    initialElements,
+      page,
+  ]);
+
+  useEffect(() => {
+    if (!page) {
+      return;
+    }
+
+    const nextSerializedContent = page.content || serializeCanvasContent(editorElements, editorSize);
+    const nextSerializedEditorState = buildEditorFingerprint(editorElements, editorSize, editorSettings);
+    if (nextSerializedContent) {
+      lastPersistedContentRef.current = nextSerializedContent;
+    }
+    if (nextSerializedEditorState) {
+      lastLocalEditorFingerprintRef.current = nextSerializedEditorState;
+      lastPersistedEditorFingerprintRef.current = nextSerializedEditorState;
+    }
+    if (page.lastUpdated) {
+      lastPersistedAtRef.current = page.lastUpdated;
+    }
+  }, [buildEditorFingerprint, editorElements, editorSettings, editorSize, page?.content, page?.lastUpdated]);
+
+  const hasConflict = (): boolean => {
+    const latestPage = pages.find((item) => item.id === pageId);
+    if (!latestPage) {
+      return false;
+    }
+
+    if (!lastPersistedAtRef.current) {
+      lastPersistedAtRef.current = latestPage.lastUpdated;
+      return false;
+    }
+
+    return latestPage.lastUpdated !== lastPersistedAtRef.current;
   };
 
+  const serializeForSave = (content: CanvasElement[], size: CanvasSize): string =>
+    serializeCanvasContent(content, size);
+
   const handleSave = async (
     elements: CanvasElement[],
     settings: PageSettings,
-    canvasSize: CanvasSize = initialCanvasSize
-  ) => {
-    // Save to Store
-    updatePage(pageId, {
-      content: serializeCanvasContent(elements, canvasSize),
-      title: settings.title,
-      slug: settings.slug,
-      status: settings.status,
-      meta: settings.meta,
-    });
+    canvasSize: CanvasSize = editorSize
+  ): Promise<boolean> => {
+    if (!canEdit) {
+      setSaveError('You do not have permission to save this page.');
+      return false;
+    }
+
+    if (isSaving) {
+      return false;
+    }
+
+    if (hasConflict()) {
+      const shouldOverwrite = window.confirm(
+        'This page was updated in another tab/session. Continue and overwrite current changes?',
+      );
+      if (!shouldOverwrite) {
+        setSaveError('Save aborted due to a concurrent edit conflict.');
+        return false;
+      }
+    }
+
+    setIsSaving(true);
+    setSaveError(null);
+    try {
+    const nextRevision = new Date().toISOString();
+    const nextPayload = serializeForSave(elements, canvasSize);
+    lastPersistedContentRef.current = nextPayload;
+    lastPersistedEditorFingerprintRef.current = buildPageStateFingerprint(
+      elements,
+      canvasSize,
+      settings,
+      );
+      lastPersistedAtRef.current = nextRevision;
+      updatePage(pageId, {
+        content: nextPayload,
+        title: settings.title,
+        slug: settings.slug,
+        status: settings.status,
+        meta: settings.meta,
+        lastUpdated: nextRevision,
+      });
+      lastPersistedAtRef.current = nextRevision;
+      return true;
+    } catch (error) {
+      lastPersistedEditorFingerprintRef.current = null;
+      lastPersistedAtRef.current = null;
+      lastPersistedContentRef.current = null;
+      setSaveError(error instanceof Error ? error.message : 'Unable to save page.');
+      throw error;
+    } finally {
+      setIsSaving(false);
+    }
+  };
+
+  const handleReload = async () => {
+    const latestPage = pages.find((item) => item.id === pageId);
+    if (!latestPage) {
+      return;
+    }
+
+    const latestData = normalizeSavedCanvasContent(latestPage.content || null);
+    const latestElements = latestData.elements.length
+      ? latestData.elements
+      : buildFallbackElements(latestPage);
+    const latestSettings: PageSettings = {
+      title: latestPage.title,
+      slug: latestPage.slug,
+      status: latestPage.status,
+      meta: latestPage.meta || { title: latestPage.title, description: '' },
+    };
+    const latestContent = latestPage.content || null;
+    setEditorElements(latestElements);
+    setEditorSize(latestData.canvasSize);
+    setEditorSettings(latestSettings);
+    if (latestContent) {
+      lastPersistedContentRef.current = latestContent;
+    } else {
+      lastPersistedContentRef.current = null;
+    }
+    lastPersistedEditorFingerprintRef.current = buildPageStateFingerprint(
+      latestElements,
+      latestData.canvasSize,
+      latestSettings,
+    );
+    lastPersistedAtRef.current = latestPage.lastUpdated;
+    setSaveError(null);
   };
 
   const handleBack = () => {
@@ -106,19 +404,31 @@ function PageEditorRoute() {
   };
 
   return (
-    <CanvasEditor
-      mode="page"
-      initialElements={initialElements.length ? initialElements : fallbackElements}
-      initialSize={initialCanvasSize}
-      initialSettings={initialSettings}
-      onSave={handleSave}
-      onBack={handleBack}
-      mediaContext={{
-        scope: 'page',
-        targetId: pageId,
-        targetLabel: page.title,
-      }}
-    // Pages use fixed layout, so no custom className/width by default
-    />
+    <>
+      {saveError ? (
+        <div className="mx-4 mt-2 rounded-md border border-amber-300 bg-amber-50 text-amber-900 px-3 py-2 text-sm">
+          {saveError}
+        </div>
+      ) : null}
+      <CanvasEditor
+        mode="page"
+        key={pageId}
+        initialElements={editorElements}
+        initialSize={editorSize}
+        initialSettings={editorSettings}
+        onSave={handleSave}
+        onReload={handleReload}
+        onBack={handleBack}
+        onChange={handleEditorChange}
+        hideSave={!canEdit}
+        readOnly={!canEdit}
+        mediaContext={{
+          scope: 'page',
+          targetId: pageId,
+          targetLabel: page.title,
+        }}
+        // Pages use fixed layout, so no custom className/width by default
+      />
+    </>
   );
 }
diff --git a/apps/admin/src/routes/pages.new.tsx b/apps/admin/src/routes/pages.new.tsx
index 7ef6734..99ac0b8 100644
--- a/apps/admin/src/routes/pages.new.tsx
+++ b/apps/admin/src/routes/pages.new.tsx
@@ -8,6 +8,7 @@ import { ArrowLeft, Save, Layout, Globe } from 'lucide-react';
 import { useStore } from '@/stores/mockStore';
 import { PageShell } from '@/components/layout/PageShell';
 import { cn } from '@/lib/utils';
+import { useAuthStore, selectCanEdit } from '@/stores/authStore';
 
 export const Route = createFileRoute('/pages/new')({
     component: NewPageRoute,
@@ -15,6 +16,7 @@ export const Route = createFileRoute('/pages/new')({
 
 function NewPageRoute() {
     const navigate = useNavigate();
+    const canEdit = useAuthStore(selectCanEdit);
     const { sites, addPage } = useStore();
     const [isLoading, setIsLoading] = useState(false);
 
@@ -29,6 +31,11 @@ function NewPageRoute() {
 
     const handleSubmit = async (e: React.FormEvent) => {
         e.preventDefault();
+        if (!canEdit) {
+            alert('You do not have permission to create pages.');
+            return;
+        }
+
         setIsLoading(true);
         await new Promise(resolve => setTimeout(resolve, 800));
 
@@ -52,6 +59,11 @@ function NewPageRoute() {
                 </button>
             }
         >
+            {!canEdit ? (
+                <div className="border border-border rounded-lg p-4 bg-muted/30 text-sm text-muted-foreground">
+                    View-only role: you can browse pages but cannot create new ones.
+                </div>
+            ) : null}
             <div className="max-w-2xl mx-auto">
                 <form onSubmit={handleSubmit} className="space-y-6">
                     <div className="bg-card border border-border rounded-xl p-6 space-y-6 shadow-sm">
@@ -162,13 +174,14 @@ function NewPageRoute() {
                             Cancel
                         </button>
                         <button
-                            type="submit"
-                            disabled={isLoading || !formData.title || !formData.siteId}
-                            className={cn(
-                                'flex items-center gap-2 px-6 py-2.5 rounded-lg',
-                                'bg-primary text-primary-foreground font-medium',
-                                'hover:bg-primary/90 disabled:opacity-50 shadow-md'
-                            )}
+                          type="submit"
+                          disabled={isLoading || !formData.title || !formData.siteId}
+                          hidden={!canEdit}
+                          className={cn(
+                              'flex items-center gap-2 px-6 py-2.5 rounded-lg',
+                              'bg-primary text-primary-foreground font-medium',
+                              'hover:bg-primary/90 disabled:opacity-50 shadow-md'
+                          )}
                         >
                             <Save className="w-4 h-4" />
                             {isLoading ? 'Creating...' : 'Create Page'}
diff --git a/apps/admin/src/routes/pages.tsx b/apps/admin/src/routes/pages.tsx
index 2641d90..69ea6b6 100644
--- a/apps/admin/src/routes/pages.tsx
+++ b/apps/admin/src/routes/pages.tsx
@@ -7,8 +7,9 @@
  */
 
 import { createFileRoute, Link, useNavigate, Outlet, useRouterState } from '@tanstack/react-router';
-import { Plus, Layout, Edit, Trash2, Home, File } from 'lucide-react';
+import { Plus, Layout, Edit, Trash2, Home } from 'lucide-react';
 import { useStore, type Page } from '@/stores/mockStore';
+import { useAuthStore, selectCanEdit } from '@/stores/authStore';
 import { useDataTable, type Column } from '@/hooks/useDataTable';
 import { PageShell } from '@/components/layout/PageShell';
 import { DataGrid } from '@/components/ui/DataGrid';
@@ -39,6 +40,7 @@ function PagesLayout() {
 
 function PagesListView() {
   const navigate = useNavigate();
+  const canEdit = useAuthStore(selectCanEdit);
   const { pages, deletePage } = useStore();
 
   const columns: Column<Page>[] = [
@@ -77,7 +79,7 @@ function PagesListView() {
     {
       key: 'actions',
       label: '',
-      render: (page) => (
+      render: (page) => canEdit ? (
         <div className="flex items-center justify-end gap-2">
           <button
             onClick={() => navigate({ to: '/pages/$pageId/edit', params: { pageId: page.id } })}
@@ -87,6 +89,9 @@ function PagesListView() {
           </button>
           <button
             onClick={() => {
+              if (!canEdit) {
+                return;
+              }
               if (confirm('Delete page?')) deletePage(page.id);
             }}
             className="p-2 text-muted-foreground hover:text-red-600 hover:bg-red-50 rounded-lg transition-colors"
@@ -94,7 +99,7 @@ function PagesListView() {
             <Trash2 className="w-4 h-4" />
           </button>
         </div>
-      )
+      ) : null
     }
   ];
 
@@ -119,13 +124,15 @@ function PagesListView() {
       title="Pages"
       description="Manage the structure and content of your site."
       action={
-        <Link
-          to="/pages/new"
-          className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-primary text-primary-foreground font-medium hover:bg-primary/90 transition-colors"
-        >
-          <Plus className="w-4 h-4" />
-          New Page
-        </Link>
+        canEdit ? (
+          <Link
+            to="/pages/new"
+            className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-primary text-primary-foreground font-medium hover:bg-primary/90 transition-colors"
+          >
+            <Plus className="w-4 h-4" />
+            New Page
+          </Link>
+        ) : null
       }
     >
       <div className="flex items-center gap-4 mb-6">
@@ -155,13 +162,15 @@ function PagesListView() {
             title="No pages found"
             description="Create your first page to start building."
             action={
-              <Link
-                to="/pages/new"
-                className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-primary text-primary-foreground font-medium hover:bg-primary/90 mt-4"
-              >
-                <Plus className="w-4 h-4" />
-                Create Page
-              </Link>
+              canEdit ? (
+                <Link
+                  to="/pages/new"
+                  className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-primary text-primary-foreground font-medium hover:bg-primary/90 mt-4"
+                >
+                  <Plus className="w-4 h-4" />
+                  Create Page
+                </Link>
+              ) : null
             }
           />
         }
diff --git a/apps/admin/src/routes/settings.tsx b/apps/admin/src/routes/settings.tsx
index 8dd2342..ac4121b 100644
--- a/apps/admin/src/routes/settings.tsx
+++ b/apps/admin/src/routes/settings.tsx
@@ -26,6 +26,7 @@ import {
   ExternalLink,
 } from 'lucide-react';
 import { cn } from '@/lib/utils';
+import { useAuthStore, selectCanAdminister } from '@/stores/authStore';
 import { useStore, type DeliveryMode } from '@/stores/mockStore';
 
 // ============================================
@@ -185,6 +186,7 @@ function buildCopyText(base: string, path: string): string {
 // ============================================
 
 function SettingsPage() {
+  const canAdminister = useAuthStore(selectCanAdminister);
   const [activeTab, setActiveTab] = useState('general');
   const [deliveryMode, setDeliveryMode] = useState<DeliveryMode>('managed-hosting');
   const [saved, setSaved] = useState(false);
@@ -199,11 +201,30 @@ function SettingsPage() {
   }, [persistedDeliveryMode]);
 
   const handleSave = () => {
+    if (!canAdminister) {
+      return;
+    }
     updateSettings({ deliveryMode });
     setSaved(true);
     setTimeout(() => setSaved(false), 2000);
   };
 
+  if (!canAdminister) {
+    return (
+      <div className="space-y-6">
+        <div>
+          <h1 className="text-2xl font-bold">Settings</h1>
+          <p className="text-muted-foreground mt-1">
+            This section is admin-only.
+          </p>
+        </div>
+        <div className="border border-border rounded-lg p-3 bg-muted/30 text-sm text-muted-foreground">
+          Admin role is required to view and edit site settings.
+        </div>
+      </div>
+    );
+  }
+
   return (
     <div className="space-y-6 animate-fade-in">
       {/* Page Header */}
diff --git a/apps/admin/src/routes/sites.$siteId.tsx b/apps/admin/src/routes/sites.$siteId.tsx
index f3c2343..6c4c87b 100644
--- a/apps/admin/src/routes/sites.$siteId.tsx
+++ b/apps/admin/src/routes/sites.$siteId.tsx
@@ -18,11 +18,13 @@ import { useStore } from '@/stores/mockStore';
 import { PageShell } from '@/components/layout/PageShell';
 import { StatusBadge } from '@/components/ui/StatusBadge';
 import { cn } from '@/lib/utils';
+import { useAuthStore, selectCanEdit } from '@/stores/authStore';
 import type {
   Comment,
   Contact,
   FormDefinition,
   FormSubmission,
+  CommentAntiAbusePolicy,
   CommentReportReason,
 } from '@backy-cms/core';
 
@@ -31,6 +33,54 @@ interface SiteFormManagementState {
   submissions: FormSubmission[];
   contacts: Contact[];
   comments: Comment[];
+  commentAnalytics: {
+    total: number;
+    status: {
+      pending: number;
+      approved: number;
+      rejected: number;
+      spam: number;
+      blocked: number;
+    };
+    byTargetType: {
+      page: number;
+      post: number;
+    };
+    threads: number;
+    replies: number;
+    totalReports: number;
+    topReportReasons: Array<{ reason: string; count: number }>;
+    antiAbuse: {
+      totalSignals: number;
+      blockedByIdentity: number;
+      blockedByType: {
+        email: number;
+        ip: number;
+        user: number;
+        request: number;
+      };
+       flags: Array<{ flag: string; count: number }>;
+       topFlaggedUsers: Array<{ userKey: string; count: number }>;
+       topRequestIds: Array<{ requestId: string; count: number }>;
+       topBlockReasons: Array<{ reasonAlias: string; count: number }>;
+       antiAbusePolicy?: CommentAntiAbusePolicy | null;
+      };
+  };
+  commentBlocks: Array<{
+    type: 'email' | 'ip' | 'user' | 'request';
+    value: string;
+    reason: string;
+    actor?: string;
+    requestId?: string;
+    createdAt: string;
+    expiresAt?: string;
+    reasonAlias?: string;
+    key: string;
+  }>;
+  commentBlocksLoading: boolean;
+  commentAntiAbusePolicy: CommentAntiAbusePolicy | null;
+  commentAntiAbusePolicyForm: CommentAntiAbusePolicyForm;
+  commentAntiAbusePolicyLoading: boolean;
   submissionCount: number;
   contactCount: number;
   commentCount: number;
@@ -41,9 +91,173 @@ interface SiteFormManagementState {
   errorMessage: string | null;
   selectedFormId: string;
   selectedCommentIds: string[];
+  selectedCommentBlockKeys: string[];
   commentReportReasons: CommentReportReason[];
 }
 
+interface CommentAntiAbusePolicyForm {
+  rateLimit: string;
+  rateWindowMs: string;
+  signatureWindowMs: string;
+  minFillMs: string;
+  autoBlockSpamCount: string;
+  autoBlockDurationMinutes: string;
+  requestRateLimit: string;
+  requestRateWindowMs: string;
+  autoBlockUserThreshold: string;
+  autoBlockRequestThreshold: string;
+}
+
+type CommentBulkScopeMode = 'selected' | 'all';
+
+type CommentAntiAbusePolicyFormField = keyof CommentAntiAbusePolicyForm;
+
+type CommentAntiAbusePolicyField = {
+  key: CommentAntiAbusePolicyFormField;
+  label: string;
+  hint: string;
+};
+
+type CommentAntiAbusePreset = {
+  key: string;
+  label: string;
+  description: string;
+  policy: Partial<CommentAntiAbusePolicy>;
+};
+
+const COMMENT_ANTI_ABUSE_POLICY_FIELDS: CommentAntiAbusePolicyField[] = [
+  { key: 'rateLimit', label: 'Rate limit', hint: 'Max submissions per identity in the rate window' },
+  { key: 'rateWindowMs', label: 'Rate window (ms)', hint: 'Window size for anti-spam rate checks' },
+  { key: 'signatureWindowMs', label: 'Signature window (ms)', hint: 'Window size for signature checks' },
+  { key: 'minFillMs', label: 'Minimum fill (ms)', hint: 'Minimum delay before accepting comment submissions' },
+  { key: 'autoBlockSpamCount', label: 'Auto-block spam count', hint: 'Spam signal threshold to auto-block' },
+  { key: 'autoBlockDurationMinutes', label: 'Auto-block duration (m)', hint: 'Minutes to keep auto-generated blocks active' },
+  { key: 'requestRateLimit', label: 'Request rate limit', hint: 'Max submissions per requestId in window' },
+  { key: 'requestRateWindowMs', label: 'Request window (ms)', hint: 'Request identity rate window in ms' },
+  { key: 'autoBlockUserThreshold', label: 'User abuse threshold', hint: 'User-level auto-block trigger count' },
+  { key: 'autoBlockRequestThreshold', label: 'Request abuse threshold', hint: 'RequestId-level auto-block trigger count' },
+];
+
+const COMMENT_BULK_MODERATION_CONFIRM_THRESHOLD = 250;
+const COMMENT_BULK_MODERATION_HARD_LIMIT = 2000;
+
+const COMMENT_ANTI_ABUSE_PRESETS: CommentAntiAbusePreset[] = [
+  {
+    key: 'permissive',
+    label: 'Permissive',
+    description: 'Lower friction for trusted traffic',
+    policy: {
+      rateLimit: 25,
+      rateWindowMs: 90_000,
+      signatureWindowMs: 10 * 60 * 1000,
+      minFillMs: 500,
+      autoBlockSpamCount: 8,
+      autoBlockDurationMinutes: 30,
+      requestRateLimit: 75,
+      requestRateWindowMs: 120_000,
+      autoBlockUserThreshold: 10,
+      autoBlockRequestThreshold: 12,
+    },
+  },
+  {
+    key: 'balanced',
+    label: 'Balanced',
+    description: 'Recommended default tradeoff',
+    policy: {
+      rateLimit: 12,
+      rateWindowMs: 45_000,
+      signatureWindowMs: 5 * 60 * 1000,
+      minFillMs: 900,
+      autoBlockSpamCount: 5,
+      autoBlockDurationMinutes: 60,
+      requestRateLimit: 30,
+      requestRateWindowMs: 60_000,
+      autoBlockUserThreshold: 5,
+      autoBlockRequestThreshold: 5,
+    },
+  },
+  {
+    key: 'strict',
+    label: 'Strict',
+    description: 'Aggressive anti-abuse controls',
+    policy: {
+      rateLimit: 6,
+      rateWindowMs: 30_000,
+      signatureWindowMs: 3 * 60 * 1000,
+      minFillMs: 1_200,
+      autoBlockSpamCount: 3,
+      autoBlockDurationMinutes: 180,
+      requestRateLimit: 12,
+      requestRateWindowMs: 60_000,
+      autoBlockUserThreshold: 3,
+      autoBlockRequestThreshold: 3,
+    },
+  },
+];
+
+const BULK_STATUS_TEXT: Record<Comment['status'], string> = {
+  pending: 'pending',
+  approved: 'approved',
+  rejected: 'rejected',
+  spam: 'spam',
+  blocked: 'blocked',
+};
+
+const DEFAULT_COMMENT_ANTI_ABUSE_POLICY: Required<CommentAntiAbusePolicy> = {
+  rateLimit: 12,
+  rateWindowMs: 45 * 1000,
+  signatureWindowMs: 5 * 60 * 1000,
+  minFillMs: 900,
+  autoBlockSpamCount: 5,
+  autoBlockDurationMinutes: 60,
+  requestRateLimit: 30,
+  requestRateWindowMs: 60 * 1000,
+  autoBlockUserThreshold: 5,
+  autoBlockRequestThreshold: 5,
+};
+
+const createDefaultCommentAntiAbusePolicyForm = (policy?: Partial<CommentAntiAbusePolicy>): CommentAntiAbusePolicyForm => ({
+  rateLimit: String(policy?.rateLimit ?? DEFAULT_COMMENT_ANTI_ABUSE_POLICY.rateLimit),
+  rateWindowMs: String(policy?.rateWindowMs ?? DEFAULT_COMMENT_ANTI_ABUSE_POLICY.rateWindowMs),
+  signatureWindowMs: String(policy?.signatureWindowMs ?? DEFAULT_COMMENT_ANTI_ABUSE_POLICY.signatureWindowMs),
+  minFillMs: String(policy?.minFillMs ?? DEFAULT_COMMENT_ANTI_ABUSE_POLICY.minFillMs),
+  autoBlockSpamCount: String(policy?.autoBlockSpamCount ?? DEFAULT_COMMENT_ANTI_ABUSE_POLICY.autoBlockSpamCount),
+  autoBlockDurationMinutes: String(
+    policy?.autoBlockDurationMinutes ?? DEFAULT_COMMENT_ANTI_ABUSE_POLICY.autoBlockDurationMinutes,
+  ),
+  requestRateLimit: String(policy?.requestRateLimit ?? DEFAULT_COMMENT_ANTI_ABUSE_POLICY.requestRateLimit),
+  requestRateWindowMs: String(
+    policy?.requestRateWindowMs ?? DEFAULT_COMMENT_ANTI_ABUSE_POLICY.requestRateWindowMs,
+  ),
+  autoBlockUserThreshold: String(
+    policy?.autoBlockUserThreshold ?? DEFAULT_COMMENT_ANTI_ABUSE_POLICY.autoBlockUserThreshold,
+  ),
+  autoBlockRequestThreshold: String(
+    policy?.autoBlockRequestThreshold ?? DEFAULT_COMMENT_ANTI_ABUSE_POLICY.autoBlockRequestThreshold,
+  ),
+});
+
+const normalizeOptionalPolicyNumber = (raw: string): number | undefined => {
+  const value = raw.trim();
+  if (!value) {
+    return undefined;
+  }
+
+  const parsed = Number.parseInt(value, 10);
+  if (!Number.isFinite(parsed) || parsed < 0) {
+    return undefined;
+  }
+
+  return parsed;
+};
+
+interface CommentBlockForm {
+  type: 'email' | 'ip' | 'user' | 'request';
+  value: string;
+  reason: string;
+  requestId: string;
+}
+
 type SubmissionStatusFilter = 'all' | 'pending' | 'approved' | 'rejected' | 'spam';
 type ContactStatusFilter = 'all' | 'new' | 'contacted' | 'qualified' | 'archived';
 type CommentStatusFilter = 'all' | 'pending' | 'approved' | 'rejected' | 'spam' | 'blocked';
@@ -61,14 +275,94 @@ const DEFAULT_COMMENT_REPORT_REASONS: CommentReportReason[] = [
   'other',
 ];
 
-const apiBase = (() => {
-  const envBase = (import.meta as unknown as { env?: Record<string, string | undefined> }).env
-    ?.VITE_BACKY_PUBLIC_API_BASE_URL?.trim();
-  return envBase ? envBase.replace(/\/$/, '') : '';
+const publicApiEnv = (import.meta as unknown as { env?: Record<string, string | undefined> }).env ?? {};
+
+const publicApiCandidate = (() => {
+  const env = publicApiEnv;
+  const candidate = [
+    env.VITE_BACKY_PUBLIC_API_BASE_URL?.trim(),
+    env.VITE_PUBLIC_API_URL?.trim(),
+    env.VITE_API_BASE_URL?.trim(),
+    env.VITE_BACKY_API_BASE_URL?.trim(),
+  ].find((value) => !!value)?.replace(/\/api\/?$/, '').replace(/\/$/, '');
+
+const fallback = typeof window === 'undefined' ? '' : `${window.location.origin}/api`;
+  return (candidate || fallback).replace(/\/$/, '');
 })();
 
+const apiBase = publicApiCandidate;
+const shouldStripApiPathPrefix = /\/api$/.test(apiBase);
+
 function buildApiUrl(path: string): string {
-  return `${apiBase}${path}`;
+  if (!apiBase) {
+    return path;
+  }
+
+  const apiPrefixedPath = shouldStripApiPathPrefix && /^\/api(\/|$)/.test(path)
+    ? path.slice(4)
+    : path;
+
+  if (!apiPrefixedPath) {
+    return apiBase;
+  }
+
+  return apiPrefixedPath.startsWith('/')
+    ? `${apiBase}${apiPrefixedPath}`
+    : `${apiBase}/${apiPrefixedPath}`;
+}
+
+function getPublicApiEnvHint(): string {
+  const env = (import.meta as unknown as { env?: Record<string, string | undefined> }).env ?? {};
+  const configured = [
+    'VITE_BACKY_PUBLIC_API_BASE_URL',
+    'VITE_PUBLIC_API_URL',
+    'VITE_API_BASE_URL',
+    'VITE_BACKY_API_BASE_URL',
+  ].find((key) => typeof env[key] === 'string' && env[key]!.trim().length > 0);
+
+  return configured
+    ? `Configured public API env key: ${configured}`
+    : 'No public API base env key found (expected VITE_BACKY_PUBLIC_API_BASE_URL, VITE_PUBLIC_API_URL, or VITE_API_BASE_URL)';
+}
+
+async function parseApiJson(
+  response: Response,
+  context: string,
+  fallback: unknown = null,
+): Promise<unknown> {
+  const contentType = response.headers.get('content-type') || '';
+  const text = await response.text();
+
+  const trimmed = text.trim();
+  const looksLikeHtml = trimmed.startsWith('<!doctype') || trimmed.startsWith('<!DOCTYPE')
+    || trimmed.startsWith('<html');
+  const looksLikeJson = trimmed.startsWith('{') || trimmed.startsWith('[');
+
+  if (!trimmed) {
+    return fallback;
+  }
+
+  const isJson = contentType.includes('application/json') || contentType.includes('+json');
+  if (!isJson && !looksLikeJson) {
+    if (looksLikeHtml) {
+      throw new Error(
+        `${context} returned HTML (likely wrong API base). ${getPublicApiEnvHint()}`,
+      );
+    }
+
+    return fallback;
+  }
+
+  try {
+    return JSON.parse(text);
+  } catch {
+    if (looksLikeHtml) {
+      throw new Error(
+        `${context} returned HTML payload that is not valid JSON. ${getPublicApiEnvHint()}`,
+      );
+    }
+    return fallback;
+  }
 }
 
 function formatTime(value?: string): string {
@@ -99,6 +393,19 @@ function makeCsvBlob(rows: string[][]): Blob {
   return new Blob([csv], { type: 'text/csv;charset=utf-8' });
 }
 
+function isExpiredCommentBlock(expiresAt?: string): boolean {
+  if (!expiresAt) {
+    return false;
+  }
+
+  const timestamp = Date.parse(expiresAt);
+  if (Number.isNaN(timestamp)) {
+    return false;
+  }
+
+  return Date.now() >= timestamp;
+}
+
 function downloadBlob(filename: string, blob: Blob): void {
   const url = URL.createObjectURL(blob);
   const link = document.createElement('a');
@@ -116,6 +423,8 @@ function EditSitePage() {
   const navigate = useNavigate();
   const { siteId } = Route.useParams();
   const { sites, updateSite, deleteSite } = useStore();
+  const canEdit = useAuthStore(selectCanEdit);
+  const adminUser = useAuthStore((state) => state.user);
 
   const site = sites.find((s) => s.id === siteId);
   const siteApiId = site?.publicSiteId || site?.slug || site?.id;
@@ -133,6 +442,44 @@ function EditSitePage() {
     submissions: [],
     contacts: [],
     comments: [],
+    commentAnalytics: {
+      total: 0,
+      status: {
+        pending: 0,
+        approved: 0,
+        rejected: 0,
+        spam: 0,
+        blocked: 0,
+      },
+      byTargetType: {
+        page: 0,
+        post: 0,
+      },
+      threads: 0,
+      replies: 0,
+      totalReports: 0,
+      topReportReasons: [],
+      antiAbuse: {
+        totalSignals: 0,
+        blockedByIdentity: 0,
+        blockedByType: {
+          email: 0,
+          ip: 0,
+          user: 0,
+          request: 0,
+        },
+        flags: [],
+        topFlaggedUsers: [],
+        topRequestIds: [],
+        topBlockReasons: [],
+        antiAbusePolicy: null,
+      },
+    },
+    commentBlocks: [],
+    commentBlocksLoading: false,
+    commentAntiAbusePolicy: null,
+    commentAntiAbusePolicyForm: createDefaultCommentAntiAbusePolicyForm(),
+    commentAntiAbusePolicyLoading: false,
     submissionCount: 0,
     contactCount: 0,
     commentCount: 0,
@@ -143,6 +490,7 @@ function EditSitePage() {
     errorMessage: null,
     selectedFormId: '',
     selectedCommentIds: [],
+    selectedCommentBlockKeys: [],
     commentReportReasons: [...DEFAULT_COMMENT_REPORT_REASONS],
   });
 
@@ -154,8 +502,175 @@ function EditSitePage() {
   const [commentRequestId, setCommentRequestId] = useState('');
   const [commentTargetType, setCommentTargetType] = useState<CommentTargetFilter>('all');
   const [commentTargetId, setCommentTargetId] = useState('');
+  const [commentThreadId, setCommentThreadId] = useState('');
+  const [commentParentOnly, setCommentParentOnly] = useState(false);
+  const [commentParentId, setCommentParentId] = useState('');
   const [commentBlockReason, setCommentBlockReason] = useState<CommentReportReason>(DEFAULT_COMMENT_REPORT_REASONS[0]);
+  const [commentBlockDurationMinutes, setCommentBlockDurationMinutes] = useState('');
+  const [commentBlockForm, setCommentBlockForm] = useState<CommentBlockForm>({
+    type: 'email',
+    value: '',
+    reason: 'manual-block',
+    requestId: '',
+  });
+  const [commentBlockFilter, setCommentBlockFilter] = useState('');
+  const [commentBlockTypeFilter, setCommentBlockTypeFilter] = useState<CommentBlockForm['type'] | 'all'>('all');
+  const [commentBlockIncludeExpired, setCommentBlockIncludeExpired] = useState(false);
   const [actionBusyId, setActionBusyId] = useState<string | null>(null);
+  const [commentBulkScopeMode, setCommentBulkScopeMode] = useState<CommentBulkScopeMode>('selected');
+
+  const buildBackyAdminHeaders = (headers?: HeadersInit): Headers => {
+    const resolvedHeaders = new Headers(headers);
+    if (!adminUser) {
+      return resolvedHeaders;
+    }
+
+    resolvedHeaders.set('x-backy-user-id', adminUser.id);
+    resolvedHeaders.set('x-backy-user-name', adminUser.fullName);
+    resolvedHeaders.set('x-backy-user-email', adminUser.email);
+    resolvedHeaders.set('x-backy-user-role', adminUser.role);
+    resolvedHeaders.set('x-backy-admin',
+      JSON.stringify({
+        userId: adminUser.id,
+        name: adminUser.fullName,
+        email: adminUser.email,
+        role: adminUser.role,
+      }),
+    );
+
+    return resolvedHeaders;
+  };
+
+  const withBackyAdminFetchOptions = (options: RequestInit = {}): RequestInit => ({
+    ...options,
+    headers: buildBackyAdminHeaders(options.headers),
+  });
+
+  const callBackyAdminApi = (path: string, options: RequestInit = {}): Promise<Response> =>
+    fetch(buildApiUrl(path), withBackyAdminFetchOptions(options));
+
+  function parseIntegerInput(raw: string): number | undefined {
+    const parsed = Number.parseInt(raw, 10);
+    if (!Number.isFinite(parsed)) {
+      return undefined;
+    }
+
+    return parsed < 0 ? undefined : parsed;
+  }
+
+  function parseCommentBlockDuration(): number | undefined {
+    return parseIntegerInput(commentBlockDurationMinutes);
+  }
+
+  const buildCommentBulkScope = () => ({
+    ...(commentStatus !== 'all' ? { status: commentStatus } : {}),
+    ...(commentTargetType !== 'all' ? { targetType: commentTargetType } : {}),
+    targetId: commentTargetId.trim() || undefined,
+    requestId: commentRequestId.trim() || undefined,
+    q: commentSearch.trim() || undefined,
+    commentThreadId: commentThreadId.trim() || undefined,
+    ...(commentParentOnly ? { parentOnly: true } : {}),
+    ...(commentParentId.trim() ? { parentId: commentParentId.trim() } : {}),
+  });
+
+  const buildCommentBulkScopeLabel = () => {
+    const scope = buildCommentBulkScope();
+    const parts: string[] = [];
+    if (scope.status) parts.push(`status=${scope.status}`);
+    if (scope.targetType) parts.push(`targetType=${scope.targetType}`);
+    if (scope.targetId) parts.push(`targetId=${scope.targetId}`);
+    if (scope.requestId) parts.push(`requestId=${scope.requestId}`);
+    if (scope.q) parts.push(`query=${scope.q}`);
+    if (scope.commentThreadId) parts.push(`threadId=${scope.commentThreadId}`);
+    if (scope.parentOnly) parts.push('scope=parentOnly');
+    if (scope.parentId) parts.push(`parentId=${scope.parentId}`);
+
+    return parts.length === 0 ? 'all comments (unfiltered)' : parts.join(' • ');
+  };
+
+  const commentBulkHasScopeFilters = () => {
+    const scope = buildCommentBulkScope();
+    return [
+      scope.status,
+      scope.targetType,
+      scope.targetId,
+      scope.requestId,
+      scope.q,
+      scope.parentOnly,
+      scope.parentId,
+      scope.commentThreadId,
+    ].some((value) => value !== undefined && value !== null && value !== '');
+  };
+
+  const buildCommentAntiAbusePolicyPayload = (policyForm: CommentAntiAbusePolicyForm): Partial<CommentAntiAbusePolicy> => {
+    const fields = {
+      rateLimit: normalizeOptionalPolicyNumber(policyForm.rateLimit),
+      rateWindowMs: normalizeOptionalPolicyNumber(policyForm.rateWindowMs),
+      signatureWindowMs: normalizeOptionalPolicyNumber(policyForm.signatureWindowMs),
+      minFillMs: normalizeOptionalPolicyNumber(policyForm.minFillMs),
+      autoBlockSpamCount: normalizeOptionalPolicyNumber(policyForm.autoBlockSpamCount),
+      autoBlockDurationMinutes: normalizeOptionalPolicyNumber(policyForm.autoBlockDurationMinutes),
+      requestRateLimit: normalizeOptionalPolicyNumber(policyForm.requestRateLimit),
+      requestRateWindowMs: normalizeOptionalPolicyNumber(policyForm.requestRateWindowMs),
+      autoBlockUserThreshold: normalizeOptionalPolicyNumber(policyForm.autoBlockUserThreshold),
+      autoBlockRequestThreshold: normalizeOptionalPolicyNumber(policyForm.autoBlockRequestThreshold),
+    };
+
+    return Object.entries(fields).reduce((next, [key, value]) => {
+      if (Number.isFinite(value)) {
+        next[key as keyof CommentAntiAbusePolicy] = value;
+      }
+
+      return next;
+    }, {} as Partial<CommentAntiAbusePolicy>);
+  };
+
+  const hasSelectableBulkScope = commentBulkScopeMode === 'selected'
+    ? state.selectedCommentIds.length > 0
+    : commentBulkHasScopeFilters();
+  const hasActiveAntiAbusePolicy = state.commentAntiAbusePolicy !== null;
+
+  const estimateBulkCommentMatchCount = async (): Promise<number> => {
+    if (!siteApiId) {
+      return 0;
+    }
+
+    const response = await callBackyAdminApi(
+      `/api/sites/${siteApiId}/comments?${buildCommentFilterQuery()}&limit=1&offset=0`,
+    );
+
+    if (!response.ok) {
+      return 0;
+    }
+
+    const payload = await parseApiJson(response, 'estimateBulkCommentMatchCount', null);
+    if (typeof payload?.count === 'number') {
+      return payload.count;
+    }
+
+    if (Array.isArray(payload?.comments)) {
+      return payload.comments.length;
+    }
+
+    return 0;
+  };
+
+  const applyCommentAntiAbusePreset = (preset: CommentAntiAbusePreset) => {
+    setState((prev) => ({
+      ...prev,
+      commentAntiAbusePolicyForm: createDefaultCommentAntiAbusePolicyForm({
+        ...prev.commentAntiAbusePolicy,
+        ...preset.policy,
+      }),
+    }));
+  };
+
+  const getCommentExportFilename = () => {
+    const statusPart = commentStatus || 'all';
+    const targetPart = commentTargetType === 'all' ? 'all-targets' : commentTargetType;
+    const requestPart = commentRequestId.trim() || 'all-requests';
+    return `comments-${statusPart}-${targetPart}-${requestPart}.csv`;
+  };
 
   useEffect(() => {
     if (site) {
@@ -175,16 +690,38 @@ function EditSitePage() {
   const setWorkflowError = (message: string | null) =>
     setState((prev) => ({ ...prev, errorMessage: message }));
 
+  const publicApiBasePath = siteApiId ? `/api/sites/${siteApiId}` : '';
+  const pageCommentEndpoint = `${publicApiBasePath}/pages/{pageId}/comments`;
+  const blogCommentEndpoint = `${publicApiBasePath}/blog/{postId}/comments`;
+  const commentAuthBridgeRefreshEvent = 'backy:identity:refresh';
+  const commentAuthBridgeSnippet = `<script>
+window.backyAuth = {
+  userId: 'USER_ID',
+  name: 'User Name',
+  email: 'user@example.com',
+  website: 'https://example.com'
+};
+window.dispatchEvent(new Event('${commentAuthBridgeRefreshEvent}'));
+</script>`;
+
+  const copyCommentAuthBridgeSnippet = () => {
+    if (typeof navigator === 'undefined' || !navigator.clipboard) {
+      return;
+    }
+
+    void navigator.clipboard.writeText(commentAuthBridgeSnippet);
+  };
+
   const loadForms = async () => {
     if (!site || !siteApiId) return;
     setState((prev) => ({ ...prev, workflowLoading: true, errorMessage: null }));
     try {
-      const response = await fetch(buildApiUrl(`/api/sites/${siteApiId}/forms`));
+      const response = await callBackyAdminApi(`/api/sites/${siteApiId}/forms`);
       if (!response.ok) {
         throw new Error('Unable to load form definitions.');
       }
 
-      const payload = await response.json();
+      const payload = await parseApiJson(response, 'loadForms');
       const forms = Array.isArray(payload.forms) ? (payload.forms as FormDefinition[]) : [];
       const firstFormId = forms[0]?.id || '';
       setState((prev) => ({
@@ -213,16 +750,14 @@ function EditSitePage() {
       }
       const query = searchParams.toString();
 
-      const response = await fetch(
-        buildApiUrl(
-          `/api/sites/${siteApiId}/forms/${formId}/submissions${query ? `?${query}` : ''}`,
-        ),
+      const response = await callBackyAdminApi(
+        `/api/sites/${siteApiId}/forms/${formId}/submissions${query ? `?${query}` : ''}`,
       );
       if (!response.ok) {
         throw new Error('Unable to load form submissions.');
       }
 
-      const payload = await response.json();
+      const payload = await parseApiJson(response, 'loadSubmissions');
       const submissions = Array.isArray(payload?.submissions?.data)
         ? (payload.submissions.data as FormSubmission[])
         : [];
@@ -256,16 +791,14 @@ function EditSitePage() {
       }
       const query = searchParams.toString();
 
-      const response = await fetch(
-        buildApiUrl(
-          `/api/sites/${siteApiId}/forms/${formId}/contacts${query ? `?${query}` : ''}`,
-        ),
+      const response = await callBackyAdminApi(
+        `/api/sites/${siteApiId}/forms/${formId}/contacts${query ? `?${query}` : ''}`,
       );
       if (!response.ok) {
         throw new Error('Unable to load contacts.');
       }
 
-      const payload = await response.json();
+      const payload = await parseApiJson(response, 'loadContacts');
       const contacts = Array.isArray(payload?.contacts) ? (payload.contacts as Contact[]) : [];
       const contactCount = typeof payload?.count === 'number' ? payload.count : contacts.length;
 
@@ -288,12 +821,12 @@ function EditSitePage() {
     setState((prev) => ({ ...prev, commentsLoading: true, errorMessage: null }));
     try {
       const query = buildCommentFilterQuery();
-      const response = await fetch(buildApiUrl(`/api/sites/${siteApiId}/comments?${query}`));
+      const response = await callBackyAdminApi(`/api/sites/${siteApiId}/comments?${query}`);
       if (!response.ok) {
         throw new Error('Unable to load comments.');
       }
 
-      const payload = await response.json();
+      const payload = await parseApiJson(response, 'loadComments');
       const comments = Array.isArray(payload?.comments) ? (payload.comments as Comment[]) : [];
       const commentCount = typeof payload?.count === 'number' ? payload.count : comments.length;
 
@@ -312,6 +845,162 @@ function EditSitePage() {
     }
   };
 
+  const loadCommentAnalytics = async () => {
+    if (!siteApiId) return;
+    try {
+      const searchParams = new URLSearchParams();
+      if (commentTargetType !== 'all') {
+        searchParams.set('targetType', commentTargetType);
+      }
+      if (commentStatus !== 'all') {
+        searchParams.set('status', commentStatus);
+      }
+      if (commentRequestId.trim()) {
+        searchParams.set('requestId', commentRequestId.trim());
+      }
+      if (commentSearch.trim()) {
+        searchParams.set('q', commentSearch.trim());
+      }
+      if (commentTargetId.trim()) {
+        searchParams.set('targetId', commentTargetId.trim());
+      }
+      if (commentThreadId.trim()) {
+        searchParams.set('commentThreadId', commentThreadId.trim());
+      }
+      if (commentParentOnly) {
+        searchParams.set('parentOnly', 'true');
+      }
+      if (commentParentId.trim()) {
+        searchParams.set('parentId', commentParentId.trim());
+      }
+
+      const response = await callBackyAdminApi(
+        `/api/sites/${siteApiId}/comments/analytics?${searchParams.toString()}`,
+      );
+      if (!response.ok) {
+        throw new Error('Unable to load comment analytics.');
+      }
+
+      const payload = await parseApiJson(response, 'loadCommentAnalytics');
+      const analytics = payload?.analytics && typeof payload.analytics === 'object' ? payload.analytics : null;
+
+      if (!analytics) {
+        throw new Error('Invalid comment analytics payload.');
+      }
+
+      setState((prev) => ({
+        ...prev,
+        commentAnalytics: {
+          total: typeof analytics.total === 'number' ? analytics.total : 0,
+          status: {
+            pending: typeof analytics.status?.pending === 'number' ? analytics.status.pending : 0,
+            approved: typeof analytics.status?.approved === 'number' ? analytics.status.approved : 0,
+            rejected: typeof analytics.status?.rejected === 'number' ? analytics.status.rejected : 0,
+            spam: typeof analytics.status?.spam === 'number' ? analytics.status.spam : 0,
+            blocked: typeof analytics.status?.blocked === 'number' ? analytics.status.blocked : 0,
+          },
+          byTargetType: {
+            page: typeof analytics.byTargetType?.page === 'number' ? analytics.byTargetType.page : 0,
+            post: typeof analytics.byTargetType?.post === 'number' ? analytics.byTargetType.post : 0,
+          },
+          threads: typeof analytics.threads === 'number' ? analytics.threads : 0,
+          replies: typeof analytics.replies === 'number' ? analytics.replies : 0,
+          totalReports: typeof analytics.totalReports === 'number' ? analytics.totalReports : 0,
+          antiAbuse: {
+            totalSignals: typeof analytics.antiAbuse?.totalSignals === 'number'
+              ? analytics.antiAbuse.totalSignals
+              : 0,
+            blockedByIdentity: typeof analytics.antiAbuse?.blockedByIdentity === 'number'
+              ? analytics.antiAbuse.blockedByIdentity
+              : 0,
+          blockedByType: {
+            email: typeof analytics.antiAbuse?.blockedByType?.email === 'number'
+              ? analytics.antiAbuse.blockedByType.email
+              : 0,
+            ip: typeof analytics.antiAbuse?.blockedByType?.ip === 'number'
+              ? analytics.antiAbuse.blockedByType.ip
+              : 0,
+            user: typeof analytics.antiAbuse?.blockedByType?.user === 'number'
+              ? analytics.antiAbuse.blockedByType.user
+              : 0,
+            request: typeof analytics.antiAbuse?.blockedByType?.request === 'number'
+              ? analytics.antiAbuse.blockedByType.request
+              : 0,
+          },
+          flags: Array.isArray(analytics.antiAbuse?.flags)
+            ? analytics.antiAbuse.flags
+            : [],
+          topFlaggedUsers: Array.isArray(analytics.antiAbuse?.topFlaggedUsers)
+            ? analytics.antiAbuse.topFlaggedUsers
+            : [],
+          topRequestIds: Array.isArray(analytics.antiAbuse?.topRequestIds)
+            ? analytics.antiAbuse.topRequestIds
+            : [],
+          topBlockReasons: Array.isArray(analytics.antiAbuse?.topBlockReasons)
+            ? analytics.antiAbuse.topBlockReasons
+              .map((item: { reasonAlias?: unknown; count?: unknown }) => ({
+                reasonAlias:
+                  typeof item.reasonAlias === 'string' ? item.reasonAlias : String(item.reasonAlias ?? ''),
+                count: typeof item.count === 'number' ? item.count : 0,
+              }))
+              .filter((item) => item.reasonAlias)
+            : [],
+          antiAbusePolicy: analytics.antiAbuse?.antiAbusePolicy
+            ? analytics.antiAbuse.antiAbusePolicy
+            : null,
+        },
+          topReportReasons: Array.isArray(analytics.topReportReasons)
+            ? analytics.topReportReasons
+              .map((item: { reason?: unknown; count?: unknown }) => ({
+                reason: typeof item.reason === 'string' ? item.reason : String(item.reason ?? ''),
+                count: typeof item.count === 'number' ? item.count : 0,
+              }))
+              .filter((item) => item.reason)
+            : [],
+        },
+      }));
+    } catch (error) {
+      const message = error instanceof Error ? error.message : 'Unable to load comment analytics.';
+      setWorkflowError(message);
+      setState((prev) => ({
+        ...prev,
+        commentAnalytics: {
+          total: 0,
+          status: {
+            pending: 0,
+            approved: 0,
+            rejected: 0,
+            spam: 0,
+            blocked: 0,
+          },
+          byTargetType: {
+            page: 0,
+            post: 0,
+          },
+          threads: 0,
+          replies: 0,
+          totalReports: 0,
+          antiAbuse: {
+            totalSignals: 0,
+            blockedByIdentity: 0,
+            blockedByType: {
+              email: 0,
+              ip: 0,
+              user: 0,
+              request: 0,
+            },
+            flags: [],
+            topFlaggedUsers: [],
+            topRequestIds: [],
+            topBlockReasons: [],
+            antiAbusePolicy: null,
+          },
+          topReportReasons: [],
+        },
+      }));
+    }
+  };
+
   const buildCommentFilterQuery = () => {
     const searchParams = new URLSearchParams();
     if (commentTargetType !== 'all') {
@@ -328,19 +1017,198 @@ function EditSitePage() {
     if (q) searchParams.set('q', q);
     if (commentRequestId.trim()) searchParams.set('requestId', commentRequestId.trim());
     if (commentTargetId.trim()) searchParams.set('targetId', commentTargetId.trim());
+    if (commentThreadId.trim()) searchParams.set('commentThreadId', commentThreadId.trim());
+    if (commentParentOnly) searchParams.set('parentOnly', 'true');
+    if (commentParentId.trim()) searchParams.set('parentId', commentParentId.trim());
 
     return searchParams.toString();
   };
 
+  const buildCommentExportQuery = () => {
+    const searchParams = new URLSearchParams(buildCommentFilterQuery());
+    searchParams.set('all', 'true');
+    searchParams.set('format', 'csv');
+    searchParams.set('includeAnalytics', 'true');
+    return searchParams.toString();
+  };
+
+  const loadCommentBlocks = async () => {
+    if (!siteApiId) return;
+    setState((prev) => ({ ...prev, commentBlocksLoading: true, errorMessage: null }));
+
+    try {
+      const query = new URLSearchParams();
+      if (commentBlockTypeFilter !== 'all') {
+        query.set('type', commentBlockTypeFilter);
+      }
+      if (commentBlockFilter.trim()) {
+        query.set('q', commentBlockFilter.trim());
+      }
+      if (commentBlockIncludeExpired) {
+        query.set('includeExpired', 'true');
+      }
+      const queryString = query.toString();
+      const endpoint = `/api/sites/${siteApiId}/comments/blocks${queryString ? `?${queryString}` : ''}`;
+
+      const response = await callBackyAdminApi(endpoint);
+      if (!response.ok) {
+        throw new Error('Unable to load comment blocks.');
+      }
+
+      const payload = await parseApiJson(response, 'loadCommentBlocks');
+      const commentBlocks = Array.isArray(payload?.blocks) ? payload.blocks : [];
+
+      setState((prev) => ({
+        ...prev,
+        commentBlocks: commentBlocks.map((block: { key: string; type: string; value: string; reason: string; actor?: string; requestId?: string; createdAt?: string; expiresAt?: string; reasonAlias?: string }) => ({
+          type: block.type as 'email' | 'ip' | 'user' | 'request',
+          value: block.value,
+          reason: block.reason || 'manual-block',
+          actor: block.actor,
+          requestId: block.requestId,
+          createdAt: typeof block.createdAt === 'string' ? block.createdAt : '',
+          expiresAt: typeof block.expiresAt === 'string' ? block.expiresAt : undefined,
+          reasonAlias: block.reasonAlias,
+          key: block.key,
+        })),
+        selectedCommentBlockKeys: [],
+      }));
+    } catch (error) {
+      const message = error instanceof Error ? error.message : 'Unable to load comment blocks.';
+      setWorkflowError(message);
+      setState((prev) => ({
+        ...prev,
+        commentBlocks: [],
+        selectedCommentBlockKeys: [],
+      }));
+    } finally {
+      setState((prev) => ({ ...prev, commentBlocksLoading: false }));
+    }
+  };
+
+  const saveCommentAntiAbusePolicy = async () => {
+    if (!canEdit) {
+      setWorkflowError('You do not have permission to update anti-abuse settings.');
+      return;
+    }
+    if (!siteApiId) return;
+    const payload = buildCommentAntiAbusePolicyPayload(state.commentAntiAbusePolicyForm);
+    if (Object.keys(payload).length === 0) {
+      setWorkflowError('Anti-abuse policy update requires at least one valid value.');
+      return;
+    }
+
+    setActionBusyId('comment-anti-abuse-policy');
+    setState((prev) => ({ ...prev, commentAntiAbusePolicyLoading: true, errorMessage: null }));
+    try {
+      const response = await callBackyAdminApi(`/api/sites/${siteApiId}/comments/policy`, {
+        method: 'PATCH',
+        headers: { 'Content-Type': 'application/json' },
+        body: JSON.stringify(payload),
+      });
+
+      if (!response.ok) {
+        const errorPayload = await parseApiJson(response, 'saveCommentAntiAbusePolicy error', null);
+        const serverError = typeof errorPayload?.error === 'string'
+          ? errorPayload.error
+          : 'Unable to save comment anti-abuse policy.';
+        const validationErrors = Array.isArray(errorPayload?.errors)
+          ? errorPayload.errors.map((entry) => String(entry)).filter(Boolean)
+          : [];
+        const message = validationErrors.length > 0
+          ? `${serverError} (${validationErrors.join('; ')})`
+          : serverError;
+        throw new Error(message);
+      }
+
+      await loadCommentAntiAbusePolicy();
+      setWorkflowError(null);
+    } catch (error) {
+      const message = error instanceof Error ? error.message : 'Unable to save comment anti-abuse policy.';
+      setWorkflowError(message);
+    } finally {
+      setState((prev) => ({ ...prev, commentAntiAbusePolicyLoading: false }));
+      setActionBusyId(null);
+    }
+  };
+
+  const clearCommentAntiAbusePolicy = async () => {
+    if (!canEdit) {
+      setWorkflowError('You do not have permission to reset anti-abuse settings.');
+      return;
+    }
+    if (!siteApiId) return;
+    if (!confirm('Reset anti-abuse policy to product defaults?')) {
+      return;
+    }
+
+    setActionBusyId('comment-anti-abuse-policy');
+    setState((prev) => ({ ...prev, commentAntiAbusePolicyLoading: true, errorMessage: null }));
+    try {
+      const response = await callBackyAdminApi(`/api/sites/${siteApiId}/comments/policy`, {
+        method: 'DELETE',
+      });
+
+      if (!response.ok) {
+        throw new Error('Unable to clear comment anti-abuse policy.');
+      }
+
+      setWorkflowError(null);
+      await loadCommentAntiAbusePolicy();
+    } catch (error) {
+      const message = error instanceof Error ? error.message : 'Unable to clear comment anti-abuse policy.';
+      setWorkflowError(message);
+    } finally {
+      setState((prev) => ({ ...prev, commentAntiAbusePolicyLoading: false }));
+      setActionBusyId(null);
+    }
+  };
+
+  const loadCommentAntiAbusePolicy = async () => {
+    if (!siteApiId) return;
+    setState((prev) => ({ ...prev, commentAntiAbusePolicyLoading: true, errorMessage: null }));
+
+    try {
+      const response = await callBackyAdminApi(`/api/sites/${siteApiId}/comments/policy`);
+      if (!response.ok) {
+        throw new Error('Unable to load comment anti-abuse policy.');
+      }
+
+      const payload = await parseApiJson(response, 'loadCommentAntiAbusePolicy', null);
+      const policy = payload?.policy;
+      const resolvedPolicy = typeof policy === 'object' && policy !== null
+        ? policy as CommentAntiAbusePolicy
+        : null;
+
+      setState((prev) => ({
+        ...prev,
+        commentAntiAbusePolicy: resolvedPolicy,
+        commentAntiAbusePolicyForm: createDefaultCommentAntiAbusePolicyForm(resolvedPolicy || undefined),
+      }));
+    } catch (error) {
+      const message = error instanceof Error
+        ? error.message
+        : 'Unable to load comment anti-abuse policy.';
+      setWorkflowError(message);
+      setState((prev) => ({
+        ...prev,
+        commentAntiAbusePolicy: null,
+        commentAntiAbusePolicyForm: createDefaultCommentAntiAbusePolicyForm(),
+      }));
+    } finally {
+      setState((prev) => ({ ...prev, commentAntiAbusePolicyLoading: false }));
+    }
+  };
+
   const loadCommentReportReasons = async () => {
     if (!siteApiId) return;
     try {
-      const response = await fetch(buildApiUrl(`/api/sites/${siteApiId}/comments/report-reasons`));
+      const response = await callBackyAdminApi(`/api/sites/${siteApiId}/comments/report-reasons`);
       if (!response.ok) {
         return;
       }
 
-      const payload = await response.json().catch(() => null);
+      const payload = await parseApiJson(response, 'loadCommentReportReasons', null);
       const reasons = Array.isArray(payload?.reasons) ? payload.reasons : [];
       const fallback = new Set(DEFAULT_COMMENT_REPORT_REASONS);
       const parsed = reasons
@@ -369,7 +1237,11 @@ function EditSitePage() {
       if (activeFormId) {
         await Promise.all([loadSubmissions(activeFormId), loadContacts(activeFormId)]);
       }
-      await loadComments();
+      await Promise.all([
+        loadComments(),
+        loadCommentAnalytics(),
+        loadCommentBlocks(),
+      ]);
     } finally {
       setWorkflowLoading(false);
     }
@@ -379,13 +1251,15 @@ function EditSitePage() {
     submission: FormSubmission,
     status: FormSubmission['status'],
   ) => {
+    if (!canEdit) {
+      setWorkflowError('You do not have permission to moderate submissions.');
+      return;
+    }
     if (!siteApiId || !state.selectedFormId) return;
     setActionBusyId(submission.id);
     try {
-      const response = await fetch(
-        buildApiUrl(
-          `/api/sites/${siteApiId}/forms/${state.selectedFormId}/submissions/${submission.id}`,
-        ),
+      const response = await callBackyAdminApi(
+        `/api/sites/${siteApiId}/forms/${state.selectedFormId}/submissions/${submission.id}`,
         {
           method: 'PATCH',
           headers: { 'Content-Type': 'application/json' },
@@ -409,13 +1283,15 @@ function EditSitePage() {
   };
 
   const updateContactStatus = async (contact: Contact, status: Contact['status']) => {
+    if (!canEdit) {
+      setWorkflowError('You do not have permission to moderate contact leads.');
+      return;
+    }
     if (!siteApiId || !state.selectedFormId) return;
     setActionBusyId(contact.id);
     try {
-      const response = await fetch(
-        buildApiUrl(
-          `/api/sites/${siteApiId}/forms/${state.selectedFormId}/contacts/${contact.id}`,
-        ),
+      const response = await callBackyAdminApi(
+        `/api/sites/${siteApiId}/forms/${state.selectedFormId}/contacts/${contact.id}`,
         {
           method: 'PATCH',
           headers: { 'Content-Type': 'application/json' },
@@ -443,22 +1319,84 @@ function EditSitePage() {
     }));
   };
 
+  const toggleVisibleCommentSelection = () => {
+    const visibleIds = Array.from(new Set(state.comments.map((comment) => comment.id)));
+    const allSelected = visibleIds.length > 0
+      && visibleIds.every((id) => state.selectedCommentIds.includes(id));
+
+    setState((prev) => {
+      const selectedSet = new Set(prev.selectedCommentIds);
+      if (allSelected) {
+        return {
+          ...prev,
+          selectedCommentIds: prev.selectedCommentIds.filter((id) => !visibleIds.includes(id)),
+        };
+      }
+
+      visibleIds.forEach((id) => selectedSet.add(id));
+      return {
+        ...prev,
+        selectedCommentIds: Array.from(selectedSet),
+      };
+    });
+  };
+
   const clearCommentSelection = () => {
     setState((prev) => ({ ...prev, selectedCommentIds: [] }));
   };
 
+  const toggleCommentBlockSelection = (blockKey: string, checked: boolean) => {
+    setState((prev) => ({
+      ...prev,
+      selectedCommentBlockKeys: checked
+        ? Array.from(new Set([...prev.selectedCommentBlockKeys, blockKey]))
+        : prev.selectedCommentBlockKeys.filter((key) => key !== blockKey),
+    }));
+  };
+
+  const toggleVisibleCommentBlockSelection = () => {
+    const visibleKeys = Array.from(new Set(state.commentBlocks.map((block) => block.key)));
+    const allSelected = visibleKeys.length > 0
+      && visibleKeys.every((key) => state.selectedCommentBlockKeys.includes(key));
+
+    setState((prev) => {
+      const selectedSet = new Set(prev.selectedCommentBlockKeys);
+      if (allSelected) {
+        return {
+          ...prev,
+          selectedCommentBlockKeys: prev.selectedCommentBlockKeys.filter((key) => !visibleKeys.includes(key)),
+        };
+      }
+
+      visibleKeys.forEach((key) => selectedSet.add(key));
+      return {
+        ...prev,
+        selectedCommentBlockKeys: Array.from(selectedSet),
+      };
+    });
+  };
+
+  const clearCommentBlockSelection = () => {
+    setState((prev) => ({ ...prev, selectedCommentBlockKeys: [] }));
+  };
+
   const updateCommentStatus = async (
     comment: Comment,
     status: Comment['status'],
     blockReason?: string,
     requestId?: string,
+    blockDurationMinutes?: number,
   ) => {
+    if (!canEdit) {
+      setWorkflowError('You do not have permission to moderate comments.');
+      return;
+    }
     if (!siteApiId) return;
     setActionBusyId(comment.id);
     try {
       const effectiveRequestId = requestId?.trim() || comment.requestId || undefined;
 
-      const response = await fetch(buildApiUrl(`/api/sites/${siteApiId}/comments/${comment.id}`), {
+      const response = await callBackyAdminApi(`/api/sites/${siteApiId}/comments/${comment.id}`, {
         method: 'PATCH',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({
@@ -467,12 +1405,13 @@ function EditSitePage() {
           actor: 'admin',
           blockReason: blockReason,
           requestId: effectiveRequestId,
+          blockDurationMinutes,
         }),
       });
       if (!response.ok) {
         throw new Error('Unable to update comment status.');
       }
-      await loadComments();
+      await Promise.all([loadComments(), loadCommentAnalytics()]);
     } catch (error) {
       const message = error instanceof Error ? error.message : 'Unable to update comment status.';
       setWorkflowError(message);
@@ -501,16 +1440,14 @@ function EditSitePage() {
         const query = new URLSearchParams(baseQuery);
         query.set('offset', `${offset}`);
 
-        const response = await fetch(
-          buildApiUrl(
-            `/api/sites/${siteApiId}/forms/${state.selectedFormId}/submissions?${query.toString()}`,
-          ),
+        const response = await callBackyAdminApi(
+          `/api/sites/${siteApiId}/forms/${state.selectedFormId}/submissions?${query.toString()}`,
         );
         if (!response.ok) {
           throw new Error('Unable to load submissions for export.');
         }
 
-        const payload = await response.json();
+        const payload = await parseApiJson(response, 'exportSubmissions', null);
         const submissions = Array.isArray(payload?.submissions?.data)
           ? (payload.submissions.data as FormSubmission[])
           : [];
@@ -574,16 +1511,14 @@ function EditSitePage() {
         const query = new URLSearchParams(baseQuery);
         query.set('offset', `${offset}`);
 
-        const response = await fetch(
-          buildApiUrl(
-            `/api/sites/${siteApiId}/forms/${state.selectedFormId}/contacts?${query.toString()}`,
-          ),
+        const response = await callBackyAdminApi(
+          `/api/sites/${siteApiId}/forms/${state.selectedFormId}/contacts?${query.toString()}`,
         );
         if (!response.ok) {
           throw new Error('Unable to load contacts for export.');
         }
 
-        const payload = await response.json();
+        const payload = await parseApiJson(response, 'exportContacts', null);
         const contacts = Array.isArray(payload?.contacts) ? (payload.contacts as Contact[]) : [];
         const count = typeof payload?.count === 'number' ? payload.count : contacts.length;
 
@@ -637,93 +1572,283 @@ function EditSitePage() {
 
   const exportComments = async () => {
     if (!siteApiId) return;
-    const allComments: Comment[] = [];
-    const limit = 200;
-    let offset = 0;
+    try {
+      const baseQuery = buildCommentExportQuery();
+      const query = baseQuery ? `?${baseQuery}` : '';
+      const response = await callBackyAdminApi(`/api/sites/${siteApiId}/comments/export${query}`);
+
+      if (!response.ok) {
+        throw new Error('Unable to load comments for export.');
+      }
+
+      const contentType = response.headers.get('content-type') || '';
+      if (contentType.includes('text/csv')) {
+        const blob = await response.blob();
+        const contentDisposition = response.headers.get('content-disposition') || '';
+        const filenameMatch = /filename="?([^\";]+)"?/i.exec(contentDisposition);
+        downloadBlob(filenameMatch?.[1] || getCommentExportFilename(), blob);
+        return;
+      }
+
+      const payload = await parseApiJson(response, 'exportComments', null);
+      const comments = Array.isArray(payload?.comments) ? payload.comments : [];
+      if (!comments.length) return;
+
+      const rows = [
+        [
+          'id',
+          'status',
+          'targetType',
+          'targetId',
+          'commentThreadId',
+          'parentId',
+          'requestId',
+          'authorName',
+          'authorEmail',
+          'authorWebsite',
+          'userId',
+          'ipHash',
+          'content',
+          'spamFlags',
+          'reportCount',
+          'reportReasons',
+          'reviewedBy',
+          'blockReason',
+          'blockedBy',
+          'rejectionReason',
+          'createdAt',
+          'updatedAt',
+        ],
+        ...comments.map((comment) => [
+          comment.id,
+          comment.status,
+          comment.targetType,
+          comment.targetId,
+          comment.commentThreadId || '',
+          comment.parentId || '',
+          comment.requestId || '',
+          comment.authorName || '',
+          comment.authorEmail || '',
+          comment.authorWebsite || '',
+          comment.userId || '',
+          comment.ipHash || '',
+          comment.content,
+          Array.isArray(comment.spamFlags) ? comment.spamFlags.join(';') : '',
+          typeof comment.reportCount === 'number' ? String(comment.reportCount) : '0',
+          Array.isArray(comment.reportReasons) ? comment.reportReasons.join(';') : '',
+          comment.reviewedBy || '',
+          comment.blockReason || '',
+          comment.blockedBy || '',
+          comment.rejectionReason || '',
+          comment.createdAt,
+          comment.updatedAt,
+        ]),
+      ];
+      const blob = makeCsvBlob(rows);
+      downloadBlob(getCommentExportFilename(), blob);
+    } catch (error) {
+      const message = error instanceof Error ? error.message : 'Unable to export comments.';
+      setWorkflowError(message);
+    }
+  };
+
+  const applyBulkCommentAction = async (status: Comment['status']) => {
+    if (!canEdit) {
+      setWorkflowError('You do not have permission for bulk comment moderation.');
+      return;
+    }
+    if (!siteApiId || !hasSelectableBulkScope) return;
+
+    const isBulkAllScope = commentBulkScopeMode === 'all';
+    if (isBulkAllScope && !commentBulkHasScopeFilters()) {
+      setWorkflowError('All-scope bulk actions require at least one filter.');
+      return;
+    }
+
+    const targetCount = isBulkAllScope
+      ? await estimateBulkCommentMatchCount()
+      : state.selectedCommentIds.length;
+    if (!targetCount) {
+      setWorkflowError('No comments match the selected moderation scope.');
+      return;
+    }
+
+    if (targetCount > COMMENT_BULK_MODERATION_HARD_LIMIT) {
+      const actionType = isBulkAllScope ? 'scope' : 'selection';
+      const verb = isBulkAllScope ? 'matches' : 'entries';
+      setWorkflowError(
+        `Bulk ${BULK_STATUS_TEXT[status]} is blocked: the ${actionType} contains ${targetCount} comment ${verb}.`
+        + ` The hard limit is ${COMMENT_BULK_MODERATION_HARD_LIMIT}.`,
+      );
+      return;
+    }
+
+    const requiresConfirmation = isBulkAllScope || targetCount > COMMENT_BULK_MODERATION_CONFIRM_THRESHOLD;
+    const isDestructive = status === 'rejected' || status === 'spam' || status === 'blocked';
+    if (requiresConfirmation) {
+      const scopeText = isBulkAllScope
+        ? `all matching filters (${buildCommentBulkScopeLabel()})`
+        : `${targetCount} selected`;
+      const impactText = isDestructive
+        ? `${BULK_STATUS_TEXT[status]} moderation for comment(s)`
+        : 'approval restore moderation';
+      const extraText = status === 'blocked'
+        ? ' this will create matching identity blocks for each entry.'
+        : '';
+
+      if (
+        !window.confirm(
+          `Apply ${impactText} to ${targetCount} comments in ${scopeText}?${extraText} This action is hard to reverse.`,
+        )
+      ) {
+        return;
+      }
+    }
+
+    setActionBusyId('bulk-comment');
+    try {
+      const requestPayload = {
+        commentIds: isBulkAllScope ? [] : state.selectedCommentIds,
+        all: isBulkAllScope,
+        scope: isBulkAllScope ? buildCommentBulkScope() : undefined,
+        status,
+        reviewedBy: 'admin',
+        actor: 'admin',
+        blockReason: status === 'blocked' ? commentBlockReason : undefined,
+        requestId: isBulkAllScope ? commentRequestId.trim() || undefined : undefined,
+        blockDurationMinutes: status === 'blocked' ? parseCommentBlockDuration() : undefined,
+      };
+
+      const response = await callBackyAdminApi(`/api/sites/${siteApiId}/comments`, {
+        method: 'PATCH',
+        headers: { 'Content-Type': 'application/json' },
+        body: JSON.stringify(requestPayload),
+      });
+
+      if (!response.ok) {
+        const payload = await parseApiJson(response, 'applyBulkCommentAction error', null);
+        const message = typeof payload?.error === 'string'
+          ? payload.error
+          : typeof response.statusText === 'string' && response.statusText.length
+            ? response.statusText
+            : 'Unable to apply bulk comment moderation.';
+        throw new Error(message);
+      }
+
+      const payload = await parseApiJson(response, 'applyBulkCommentAction', null);
+      const updatedCount = typeof payload?.updatedCount === 'number' ? payload.updatedCount : 0;
+      const serverTargetCount = typeof payload?.targetCount === 'number' ? payload.targetCount : targetCount;
+      const missingIds = Array.isArray(payload?.missingIds) ? payload.missingIds : [];
+
+      if (missingIds.length > 0) {
+        const skipped = serverTargetCount - updatedCount;
+        setWorkflowError(
+          `Bulk action applied to ${updatedCount} of ${serverTargetCount} comments; ${skipped} were skipped because they changed before this action.`,
+        );
+      } else {
+        setWorkflowError(null);
+      }
+
+      await Promise.all([loadComments(), loadCommentAnalytics(), loadCommentBlocks()]);
+      if (!isBulkAllScope) {
+        clearCommentSelection();
+      }
+    } catch (error) {
+      const message = error instanceof Error ? error.message : 'Unable to apply bulk comment moderation.';
+      setWorkflowError(message);
+    } finally {
+      setActionBusyId(null);
+    }
+  };
+
+  const createCommentBlock = async () => {
+    if (!canEdit) {
+      setWorkflowError('You do not have permission to create comment blocks.');
+      return;
+    }
+    if (!siteApiId) return;
+    const value = commentBlockForm.value.trim();
+    if (!value) {
+      setWorkflowError('Comment block value is required.');
+      return;
+    }
 
+    setActionBusyId('create-comment-block');
     try {
-      const baseQuery = buildCommentFilterQuery();
-      let hasMore = true;
-
-      while (hasMore) {
-        const query = new URLSearchParams(baseQuery);
-        query.set('limit', `${limit}`);
-        query.set('offset', `${offset}`);
-
-        const response = await fetch(buildApiUrl(`/api/sites/${siteApiId}/comments?${query.toString()}`));
-        if (!response.ok) {
-          throw new Error('Unable to load comments for export.');
-        }
+      const payload = {
+        blocks: [
+          {
+            type: commentBlockForm.type,
+            value,
+            reason: commentBlockForm.reason || 'manual-block',
+            requestId: commentBlockForm.requestId.trim() || undefined,
+            durationMinutes: parseCommentBlockDuration(),
+          },
+        ],
+      };
 
-        const payload = await response.json();
-        const comments = Array.isArray(payload?.comments) ? payload.comments : [];
-        const count = typeof payload?.count === 'number' ? payload.count : comments.length;
-        allComments.push(...comments);
-        hasMore = offset + comments.length < count;
-        offset += limit;
+      const response = await callBackyAdminApi(`/api/sites/${siteApiId}/comments/blocks`, {
+        method: 'POST',
+        headers: { 'Content-Type': 'application/json' },
+        body: JSON.stringify(payload),
+      });
 
-        if (comments.length === 0) {
-          break;
-        }
+      if (!response.ok) {
+        throw new Error('Unable to create comment block.');
       }
 
-      if (!allComments.length) return;
-
-      const rows = [
-        ['id', 'status', 'targetType', 'targetId', 'parentId', 'requestId', 'authorName', 'authorEmail', 'authorWebsite', 'reportCount', 'reportReasons', 'reviewedBy', 'blockReason', 'rejectionReason', 'createdAt'],
-        ...allComments.map((comment) => [
-          comment.id,
-          comment.status,
-          comment.targetType,
-          comment.targetId,
-          comment.parentId || '',
-          comment.requestId || '',
-          comment.authorName || '',
-          comment.authorEmail || '',
-          comment.authorWebsite || '',
-          typeof comment.reportCount === 'number' ? String(comment.reportCount) : '0',
-          Array.isArray(comment.reportReasons) ? comment.reportReasons.join(';') : '',
-          comment.reviewedBy || '',
-          comment.blockReason || '',
-          comment.rejectionReason || '',
-          comment.createdAt,
-        ]),
-      ];
-      const blob = makeCsvBlob(rows);
-      const fileLabel =
-        commentStatus === 'all' && !commentRequestId ? 'comments' : `${commentStatus}-${commentRequestId || 'all'}`;
-      downloadBlob(`${fileLabel}.csv`, blob);
+      setCommentBlockForm((prev) => ({
+        ...prev,
+        value: '',
+        requestId: '',
+      }));
+      setCommentBlockDurationMinutes('');
+      setWorkflowError(null);
+      await loadCommentBlocks();
     } catch (error) {
-      const message = error instanceof Error ? error.message : 'Unable to export comments.';
+      const message = error instanceof Error ? error.message : 'Unable to create comment block.';
       setWorkflowError(message);
+    } finally {
+      setActionBusyId(null);
     }
   };
 
-  const applyBulkCommentAction = async (status: Comment['status']) => {
-    if (!siteApiId || state.selectedCommentIds.length === 0) return;
-    setActionBusyId('bulk-comment');
+  const deleteCommentBlocks = async () => {
+    if (!canEdit) {
+      setWorkflowError('You do not have permission to delete comment blocks.');
+      return;
+    }
+    if (!siteApiId || state.selectedCommentBlockKeys.length === 0) return;
+    const selectedCount = state.selectedCommentBlockKeys.length;
+    if (!confirm(`Delete ${selectedCount} block entr${selectedCount === 1 ? 'y' : 'ies'}?`)) {
+      return;
+    }
+    setActionBusyId('delete-comment-block');
     try {
-      const response = await fetch(buildApiUrl(`/api/sites/${siteApiId}/comments`), {
-        method: 'PATCH',
+      const blocks = state.commentBlocks
+        .filter((block) => state.selectedCommentBlockKeys.includes(block.key))
+        .map((block) => ({
+          type: block.type,
+          value: block.value,
+        }));
+
+      const response = await callBackyAdminApi(`/api/sites/${siteApiId}/comments/blocks`, {
+        method: 'DELETE',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({
-          commentIds: state.selectedCommentIds,
-          status,
-          reviewedBy: 'admin',
-          actor: 'admin',
-          blockReason: status === 'blocked' ? commentBlockReason : undefined,
-          requestId: commentRequestId || undefined,
+          blocks,
         }),
       });
 
       if (!response.ok) {
-        throw new Error('Unable to apply bulk comment moderation.');
+        throw new Error('Unable to delete comment blocks.');
       }
 
-      await loadComments();
-      clearCommentSelection();
+      setState((prev) => ({ ...prev, selectedCommentBlockKeys: [] }));
+      setWorkflowError(null);
+      await loadCommentBlocks();
     } catch (error) {
-      const message = error instanceof Error ? error.message : 'Unable to apply bulk comment moderation.';
+      const message = error instanceof Error ? error.message : 'Unable to delete comment blocks.';
       setWorkflowError(message);
     } finally {
       setActionBusyId(null);
@@ -755,20 +1880,18 @@ function EditSitePage() {
       let hasMore = true;
 
       while (hasMore) {
-        const response = await fetch(
-          buildApiUrl(
-            `/api/sites/${siteApiId}/events?${new URLSearchParams({
+        const response = await callBackyAdminApi(
+          `/api/sites/${siteApiId}/events?${new URLSearchParams({
               requestId,
               limit: `${limit}`,
               offset: `${offset}`,
             }).toString()}`,
-          ),
         );
         if (!response.ok) {
           throw new Error('Unable to load audit events.');
         }
 
-        const payload = await response.json();
+        const payload = await parseApiJson(response, 'exportCommentEvents', null);
         const events = Array.isArray(payload?.events) ? payload.events : [];
         const count = typeof payload?.count === 'number' ? payload.count : events.length;
         allEvents.push(...events);
@@ -827,10 +1950,34 @@ function EditSitePage() {
   useEffect(() => {
     if (siteApiId) {
       void refreshWorkflow();
+      void loadCommentAntiAbusePolicy();
       void loadCommentReportReasons();
     }
   // eslint-disable-next-line react-hooks/exhaustive-deps
-  }, [siteApiId, submissionStatus, commentStatus, contactStatus, commentSearch, commentRequestId, commentTargetType, commentTargetId]);
+  }, [
+    siteApiId,
+    submissionStatus,
+    commentStatus,
+    contactStatus,
+    commentSearch,
+    commentRequestId,
+    commentTargetType,
+    commentTargetId,
+    commentThreadId,
+    commentParentOnly,
+    commentParentId,
+  ]);
+
+  useEffect(() => {
+    if (!siteApiId) return;
+    void loadCommentBlocks();
+  // eslint-disable-next-line react-hooks/exhaustive-deps
+  }, [
+    siteApiId,
+    commentBlockTypeFilter,
+    commentBlockFilter,
+    commentBlockIncludeExpired,
+  ]);
 
   useEffect(() => {
     if (state.selectedFormId && siteApiId) {
@@ -852,9 +1999,17 @@ function EditSitePage() {
   }, [state.commentReportReasons, commentBlockReason]);
 
   const activeForm = state.forms.find((form) => form.id === state.selectedFormId);
+  const areAllVisibleCommentsSelected = state.comments.length > 0
+    && state.comments.every((comment) => state.selectedCommentIds.includes(comment.id));
+  const areAllVisibleCommentBlocksSelected = state.commentBlocks.length > 0
+    && state.commentBlocks.every((block) => state.selectedCommentBlockKeys.includes(block.key));
 
   const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
     e.preventDefault();
+    if (!canEdit) {
+      setWorkflowError('You do not have permission to edit this site.');
+      return;
+    }
     setIsLoading(true);
     await new Promise((resolve) => setTimeout(resolve, 800));
 
@@ -870,6 +2025,10 @@ function EditSitePage() {
   };
 
   const handleDelete = () => {
+    if (!canEdit) {
+      setWorkflowError('You do not have permission to delete this site.');
+      return;
+    }
     if (confirm('Are you sure you want to delete this site? This action cannot be undone.')) {
       deleteSite(siteId);
       navigate({ to: '/sites' });
@@ -900,6 +2059,11 @@ function EditSitePage() {
       }
     >
       <div className="max-w-6xl mx-auto space-y-8">
+        {!canEdit ? (
+          <div className="rounded-lg border border-border p-3 bg-muted/30 text-sm text-muted-foreground">
+            View-only role: you can review settings and queues but cannot edit this site or run moderation actions.
+          </div>
+        ) : null}
         <div className="bg-card border border-border rounded-xl p-6 flex items-center justify-between shadow-sm">
           <div className="flex items-center gap-4">
             <div className="w-12 h-12 rounded-lg bg-primary/10 flex items-center justify-center">
@@ -986,6 +2150,7 @@ function EditSitePage() {
             <button
               type="button"
               onClick={handleDelete}
+              hidden={!canEdit}
               className="flex items-center gap-2 px-4 py-2.5 rounded-lg text-red-600 hover:bg-red-50 hover:text-red-700 transition-colors"
             >
               <Trash2 className="w-4 h-4" />
@@ -1002,6 +2167,7 @@ function EditSitePage() {
               <button
                 type="submit"
                 disabled={isLoading}
+                hidden={!canEdit}
                 className={cn(
                   'flex items-center gap-2 px-6 py-2.5 rounded-lg',
                   'bg-primary text-primary-foreground font-medium',
@@ -1015,6 +2181,77 @@ function EditSitePage() {
           </div>
         </form>
 
+        {siteApiId ? (
+          <section className="bg-card border border-border rounded-xl p-4 shadow-sm space-y-4">
+            <div className="flex items-start justify-between gap-3">
+              <div>
+                <h2 className="text-lg font-semibold">Public API + comment auth bridge</h2>
+                <p className="text-muted-foreground text-sm">
+                  Integrate Backy comments and forms from any frontend by posting to these endpoints.
+                </p>
+              </div>
+              <StatusBadge status="success" />
+            </div>
+
+            <div className="space-y-3 text-sm">
+              <div>
+                <h3 className="font-medium mb-2">Comment APIs</h3>
+                <p className="text-muted-foreground text-xs">
+                  POST form payload to:
+                </p>
+                <pre className="mt-1 rounded-md bg-muted p-2 text-xs overflow-x-auto">
+{`POST ${pageCommentEndpoint}
+GET  ${pageCommentEndpoint}?status=approved&commentThreadId={threadId}
+POST ${blogCommentEndpoint}
+GET  ${blogCommentEndpoint}?status=approved&commentThreadId={threadId}`}
+                </pre>
+                <p className="text-muted-foreground text-xs mt-2">
+                  Admin endpoints:
+                </p>
+                <pre className="mt-1 rounded-md bg-muted p-2 text-xs overflow-x-auto">
+{`GET  ${publicApiBasePath}/comments?status=pending&targetType=page
+GET  ${publicApiBasePath}/comments?commentThreadId={threadId}
+PATCH ${publicApiBasePath}/comments
+GET  ${publicApiBasePath}/comments/analytics?commentThreadId={threadId}
+GET  ${publicApiBasePath}/comments/report-reasons`}
+                </pre>
+              </div>
+              <div>
+                <h3 className="font-medium mb-2">Identity bootstrap for signed users (query)</h3>
+                <p className="text-muted-foreground text-xs">
+                  Pass any of these params on your page URL:
+                </p>
+                <pre className="mt-1 rounded-md bg-muted p-2 text-xs overflow-x-auto">
+{`?backyCommentUserId=USER_ID&backyCommentUserName=NAME&backyCommentUserEmail=EMAIL`}
+                </pre>
+                <p className="text-muted-foreground text-xs mt-2">
+                  Guests are blocked only when &quot;Allow guests&quot; is off. In that mode, a userId is required.
+                </p>
+              </div>
+              <div>
+                <h3 className="font-medium mb-2">Identity bootstrap (window bridge)</h3>
+                <p className="text-muted-foreground text-xs">
+                  Set this payload before/after page load and trigger refresh:
+                </p>
+                <pre className="mt-1 rounded-md bg-muted p-2 text-xs overflow-x-auto">{commentAuthBridgeSnippet}</pre>
+                <div className="mt-2">
+                  <button
+                    type="button"
+                    onClick={copyCommentAuthBridgeSnippet}
+                    className="px-2 py-1.5 text-xs rounded-md border hover:bg-accent"
+                  >
+                    Copy window bridge snippet
+                  </button>
+                </div>
+              </div>
+              <p className="text-muted-foreground text-xs">
+                Supported headers for server-side POST: <code>x-backy-user-id</code>, <code>x-backy-user-name</code>,{' '}
+                <code>x-backy-user-email</code>, <code>x-backy-user-website</code>.
+              </p>
+            </div>
+          </section>
+        ) : null}
+
         <section className="space-y-4">
           <div className="flex items-start justify-between gap-4">
             <div>
@@ -1040,8 +2277,8 @@ function EditSitePage() {
             <p className="text-sm text-amber-600">
               No public API id is mapped for this site. Add `publicSiteId` in mock site to enable workflow management.
             </p>
-          ) : (
-            <>
+            ) : (
+              <div>
               {state.errorMessage && (
                 <div className="rounded-lg border border-amber-200 bg-amber-50 text-amber-700 px-4 py-3">
                   {state.errorMessage}
@@ -1351,6 +2588,14 @@ function EditSitePage() {
                         <Download className="w-3 h-3" />
                         Export comments (filtered)
                       </button>
+                      <button
+                        type="button"
+                        onClick={toggleVisibleCommentSelection}
+                        className="text-xs px-2 py-1 rounded-md border hover:bg-accent flex items-center gap-1"
+                        disabled={!state.comments.length}
+                      >
+                        {areAllVisibleCommentsSelected ? 'Clear visible' : `Select visible (${state.comments.length})`}
+                      </button>
                       <button
                         type="button"
                         onClick={() => void exportCommentEvents()}
@@ -1362,121 +2607,622 @@ function EditSitePage() {
                       </button>
                     </div>
                   </div>
-                  <div className="grid grid-cols-1 md:grid-cols-6 gap-2">
-                    <label className="text-sm text-muted-foreground">
-                      <span>Status</span>
-                      <select
-                        value={commentStatus}
-                        onChange={(e) => setCommentStatus(e.target.value as CommentStatusFilter)}
-                        className="w-full mt-1 px-3 py-2 rounded-lg border bg-background"
+                  <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 gap-4">
+                    <div className="col-span-2 md:col-span-4 lg:col-span-5 border-b pb-2 mb-2 mt-2 flex items-center gap-2">
+                      <div className="w-1.5 h-4 bg-primary rounded-full" />
+                      <h4 className="text-sm font-semibold tracking-tight">Overview & Queue Info</h4>
+                    </div>
+
+                    <div className="rounded-xl border border-border bg-gradient-to-br from-card to-muted/20 p-4 shadow-sm group hover:shadow-md transition-all">
+                      <p className="text-xs font-semibold text-muted-foreground uppercase tracking-wider mb-2 flex items-center gap-1.5"><Users className="w-3.5 h-3.5" /> Total comments</p>
+                      <p className="text-3xl font-bold tracking-tight text-foreground group-hover:text-primary transition-colors">{state.commentAnalytics.total}</p>
+                    </div>
+
+                    <div className="rounded-xl border border-border bg-gradient-to-br from-card to-muted/20 p-4 shadow-sm group hover:shadow-md transition-all">
+                      <div className="flex items-center justify-between mb-2">
+                        <p className="text-xs font-semibold text-muted-foreground uppercase tracking-wider flex items-center gap-1.5"><RefreshCw className="w-3.5 h-3.5" /> Queue depth</p>
+                        <span className="bg-amber-100 text-amber-800 text-[10px] uppercase font-bold px-1.5 py-0.5 rounded-sm">Pending</span>
+                      </div>
+                      <p className="text-3xl font-bold tracking-tight text-foreground">{state.commentAnalytics.status.pending}</p>
+                      <div className="w-full bg-muted rounded-full h-1.5 overflow-hidden mt-3 flex">
+                         <div className="bg-amber-400 h-full transition-all" style={{ width: `${Math.min(100, (state.commentAnalytics.status.pending / (state.commentAnalytics.total || 1)) * 100)}%` }} />
+                      </div>
+                    </div>
+
+                    <div className="rounded-xl border border-border bg-gradient-to-br from-card to-muted/20 p-4 shadow-sm group hover:shadow-md transition-all">
+                      <p className="text-xs font-semibold text-muted-foreground uppercase tracking-wider mb-2 flex items-center gap-1.5"><ExternalLink className="w-3.5 h-3.5" /> Threads / Replies</p>
+                      <div className="flex items-end gap-2">
+                        <p className="text-3xl font-bold tracking-tight text-foreground">{state.commentAnalytics.threads}</p>
+                        <p className="text-lg text-muted-foreground mb-0.5">/ {state.commentAnalytics.replies}</p>
+                      </div>
+                    </div>
+
+                    <div className="rounded-xl border border-border bg-gradient-to-br from-card to-muted/20 p-4 shadow-sm group hover:shadow-md transition-all">
+                      <p className="text-xs font-semibold text-muted-foreground uppercase tracking-wider mb-2 flex items-center gap-1.5"><Globe className="w-3.5 h-3.5" /> By target</p>
+                      <div className="space-y-1 mt-3">
+                        <div className="flex justify-between text-sm">
+                          <span className="text-muted-foreground font-medium">Pages</span>
+                          <span className="font-semibold">{state.commentAnalytics.byTargetType.page}</span>
+                        </div>
+                        <div className="flex justify-between text-sm">
+                          <span className="text-muted-foreground font-medium">Posts</span>
+                          <span className="font-semibold">{state.commentAnalytics.byTargetType.post}</span>
+                        </div>
+                      </div>
+                    </div>
+
+                    <div className="rounded-xl border border-border bg-gradient-to-br from-amber-50/50 to-amber-100/50 dark:from-amber-950/20 dark:to-amber-900/20 p-4 shadow-sm group hover:shadow-md transition-all">
+                      <p className="text-xs font-semibold text-amber-800 dark:text-amber-400 uppercase tracking-wider mb-2 flex items-center gap-1.5"><CircleSlash className="w-3.5 h-3.5" /> Reported</p>
+                      <p className="text-3xl font-bold tracking-tight text-amber-900 dark:text-amber-300">{state.commentAnalytics.totalReports}</p>
+                      <div className="mt-3 flex flex-wrap gap-1">
+                        {state.commentAnalytics.topReportReasons.length === 0 ? (
+                           <span className="text-xs text-amber-700/60 dark:text-amber-400/60">No reports</span>
+                        ) : state.commentAnalytics.topReportReasons.slice(0, 3).map(item => (
+                           <span key={`${item.reason}-${item.count}`} className="text-[10px] bg-amber-200/50 dark:bg-amber-800/50 text-amber-800 dark:text-amber-200 px-1.5 py-0.5 rounded-sm font-medium">
+                             {item.reason} {item.count}
+                           </span>
+                        ))}
+                      </div>
+                    </div>
+
+                    <div className="col-span-2 md:col-span-4 lg:col-span-5 border-b pb-2 mb-2 mt-4 flex items-center gap-2">
+                      <div className="w-1.5 h-4 bg-rose-500 rounded-full" />
+                      <h4 className="text-sm font-semibold tracking-tight">Anti-Abuse Insights & Signals</h4>
+                    </div>
+
+                    <div className="col-span-2 md:col-span-4 lg:col-span-5 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
+                      <div className="rounded-xl border border-border bg-rose-50/30 dark:bg-rose-950/10 p-4 shadow-sm flex flex-col justify-between">
+                        <div>
+                          <p className="text-xs font-semibold text-rose-800 dark:text-rose-400 uppercase tracking-wider mb-2">Total Signals</p>
+                          <p className="text-3xl font-bold tracking-tight text-rose-900 dark:text-rose-300">{state.commentAnalytics.antiAbuse.totalSignals}</p>
+                          <div className="text-xs text-rose-700/80 dark:text-rose-400/80 mt-2 font-medium">Blocked IDs: {state.commentAnalytics.antiAbuse.blockedByIdentity}</div>
+                        </div>
+                        <div className="grid grid-cols-4 gap-1 mt-4 text-center">
+                          <div className="bg-rose-100 dark:bg-rose-900/40 rounded-md p-1">
+                            <div className="text-[10px] uppercase text-rose-600 dark:text-rose-400 font-bold mb-0.5">Email</div>
+                            <div className="text-sm font-bold text-rose-900 dark:text-rose-200">{state.commentAnalytics.antiAbuse.blockedByType.email}</div>
+                          </div>
+                          <div className="bg-rose-100 dark:bg-rose-900/40 rounded-md p-1">
+                            <div className="text-[10px] uppercase text-rose-600 dark:text-rose-400 font-bold mb-0.5">IP</div>
+                            <div className="text-sm font-bold text-rose-900 dark:text-rose-200">{state.commentAnalytics.antiAbuse.blockedByType.ip}</div>
+                          </div>
+                          <div className="bg-rose-100 dark:bg-rose-900/40 rounded-md p-1">
+                            <div className="text-[10px] uppercase text-rose-600 dark:text-rose-400 font-bold mb-0.5">User</div>
+                            <div className="text-sm font-bold text-rose-900 dark:text-rose-200">{state.commentAnalytics.antiAbuse.blockedByType.user}</div>
+                          </div>
+                          <div className="bg-rose-100 dark:bg-rose-900/40 rounded-md p-1">
+                            <div className="text-[10px] uppercase text-rose-600 dark:text-rose-400 font-bold mb-0.5">Req</div>
+                            <div className="text-sm font-bold text-rose-900 dark:text-rose-200">{state.commentAnalytics.antiAbuse.blockedByType.request}</div>
+                          </div>
+                        </div>
+                      </div>
+
+                      <div className="rounded-xl border border-border bg-card p-4 shadow-sm">
+                        <p className="text-xs font-semibold text-muted-foreground uppercase tracking-wider mb-3">Top Flags</p>
+                        <div className="flex flex-col gap-2 overflow-y-auto max-h-[100px] pr-1">
+                          {state.commentAnalytics.antiAbuse.flags.length === 0 ? (
+                            <span className="text-sm text-muted-foreground italic">No flags recent</span>
+                          ) : state.commentAnalytics.antiAbuse.flags.map((item) => (
+                            <div key={`${item.flag}-${item.count}`} className="flex items-center justify-between text-sm">
+                              <span className="truncate pr-2">{item.flag}</span>
+                              <span className="font-semibold bg-muted px-2 py-0.5 rounded-md">{item.count}</span>
+                            </div>
+                          ))}
+                        </div>
+                      </div>
+
+                      <div className="rounded-xl border border-border bg-card p-4 shadow-sm">
+                        <p className="text-xs font-semibold text-muted-foreground uppercase tracking-wider mb-3">Top Users</p>
+                        <div className="flex flex-col gap-2 overflow-y-auto max-h-[100px] pr-1">
+                          {state.commentAnalytics.antiAbuse.topFlaggedUsers.length === 0 ? (
+                            <span className="text-sm text-muted-foreground italic">Clean logs</span>
+                          ) : state.commentAnalytics.antiAbuse.topFlaggedUsers.map((item) => (
+                            <div key={`${item.userKey}-${item.count}`} className="flex items-center justify-between text-sm">
+                              <span className="truncate pr-2 font-mono text-xs">{item.userKey}</span>
+                              <span className="font-semibold bg-muted px-2 py-0.5 rounded-md text-xs">{item.count}</span>
+                            </div>
+                          ))}
+                        </div>
+                      </div>
+
+                      <div className="rounded-xl border border-border bg-card p-4 shadow-sm flex flex-col pt-3 gap-3">
+                         <div className="flex-1 border p-3 rounded-lg flex flex-col justify-center items-center bg-muted/20">
+                           <p className="text-[10px] font-bold text-muted-foreground uppercase tracking-widest mb-1">Top Requests</p>
+                           <p className="text-lg font-bold">
+                             {state.commentAnalytics.antiAbuse.topRequestIds.length > 0 
+                               ? state.commentAnalytics.antiAbuse.topRequestIds[0].count 
+                               : 0}
+                             <span className="text-xs text-muted-foreground font-normal ml-1">hits from max</span>
+                           </p>
+                         </div>
+                         <div className="flex-1 border p-3 rounded-lg flex flex-col justify-center items-center bg-muted/20">
+                           <p className="text-[10px] font-bold text-muted-foreground uppercase tracking-widest mb-1">Top Block Rsn</p>
+                           <p className="text-sm font-semibold truncate max-w-full px-2" title={state.commentAnalytics.antiAbuse.topBlockReasons[0]?.reasonAlias}>
+                             {state.commentAnalytics.antiAbuse.topBlockReasons.length > 0 
+                               ? state.commentAnalytics.antiAbuse.topBlockReasons[0].reasonAlias 
+                               : "None"}
+                           </p>
+                         </div>
+                      </div>
+                    </div>
+                    <div className="col-span-2 md:col-span-4 lg:col-span-5 border-b pb-2 mb-2 mt-6 flex items-center gap-2">
+                      <div className="w-1.5 h-4 bg-blue-500 rounded-full" />
+                      <h4 className="text-sm font-semibold tracking-tight">Filters & Moderation</h4>
+                    </div>
+                    <div className="bg-muted/30 p-4 rounded-xl border border-border">
+                      <div className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-3">
+                        <div className="space-y-1">
+                          <label className="text-xs font-semibold text-muted-foreground uppercase">Status</label>
+                          <select
+                            value={commentStatus}
+                            onChange={(e) => setCommentStatus(e.target.value as CommentStatusFilter)}
+                            className="w-full px-3 py-2 bg-background border rounded-lg text-sm shadow-sm focus:ring-primary focus:border-primary transition-colors"
+                          >
+                            <option value="all">All Statuses</option>
+                            <option value="pending">Pending</option>
+                            <option value="approved">Approved</option>
+                            <option value="rejected">Rejected</option>
+                            <option value="spam">Spam</option>
+                            <option value="blocked">Blocked</option>
+                          </select>
+                        </div>
+                        <div className="space-y-1">
+                          <label className="text-xs font-semibold text-muted-foreground uppercase">Target</label>
+                          <select
+                            value={commentTargetType}
+                            onChange={(e) => setCommentTargetType(e.target.value as CommentTargetFilter)}
+                            className="w-full px-3 py-2 bg-background border rounded-lg text-sm shadow-sm focus:ring-primary focus:border-primary transition-colors"
+                          >
+                            <option value="all">All Targets</option>
+                            <option value="page">Page</option>
+                            <option value="post">Post</option>
+                          </select>
+                        </div>
+                        <div className="space-y-1">
+                          <label className="text-xs font-semibold text-muted-foreground uppercase">Target ID</label>
+                          <input
+                            value={commentTargetId}
+                            onChange={(event) => setCommentTargetId(event.target.value)}
+                            placeholder="pageId / postId"
+                            className="w-full px-3 py-2 bg-background border rounded-lg text-sm shadow-sm focus:ring-primary focus:border-primary transition-colors"
+                          />
+                        </div>
+                        <div className="space-y-1 lg:col-span-2">
+                          <label className="text-xs font-semibold text-muted-foreground uppercase">Search Content</label>
+                          <input
+                            value={commentSearch}
+                            onChange={(event) => setCommentSearch(event.target.value)}
+                            placeholder="Search by author, email, text..."
+                            className="w-full px-3 py-2 bg-background border rounded-lg text-sm shadow-sm focus:ring-primary focus:border-primary transition-colors"
+                          />
+                        </div>
+                        
+                        {/* Advanced row */}
+                        <div className="space-y-1">
+                          <label className="text-xs font-semibold text-muted-foreground uppercase">Thread ID</label>
+                          <input
+                            value={commentThreadId}
+                            onChange={(event) => setCommentThreadId(event.target.value)}
+                            placeholder="Optional thread"
+                            className="w-full px-3 py-2 bg-background border rounded-lg text-sm shadow-sm focus:ring-primary focus:border-primary transition-colors"
+                          />
+                        </div>
+                        <div className="space-y-1">
+                          <label className="text-xs font-semibold text-muted-foreground uppercase">Parent Level</label>
+                          <label className="flex items-center gap-2 px-3 py-2 bg-background border rounded-lg shadow-sm cursor-pointer hover:bg-muted/50 transition-colors">
+                            <input
+                              type="checkbox"
+                              checked={commentParentOnly}
+                              className="rounded border-gray-300 text-primary focus:ring-primary h-4 w-4"
+                              onChange={(event) => {
+                                setCommentParentOnly(event.target.checked);
+                                if (!event.target.checked) setCommentParentId('');
+                              }}
+                            />
+                            <span className="text-sm font-medium">Top-level only</span>
+                          </label>
+                        </div>
+                        <div className="space-y-1">
+                          <label className="text-xs font-semibold text-muted-foreground uppercase">Parent ID</label>
+                          <input
+                            value={commentParentId}
+                            onChange={(event) => setCommentParentId(event.target.value)}
+                            placeholder="Required if top-level"
+                            disabled={!commentParentOnly}
+                            className="w-full px-3 py-2 bg-background border rounded-lg text-sm shadow-sm disabled:bg-muted/50 disabled:cursor-not-allowed focus:ring-primary focus:border-primary transition-colors"
+                          />
+                        </div>
+                        <div className="space-y-1">
+                          <label className="text-xs font-semibold text-muted-foreground uppercase">Request ID</label>
+                          <input
+                            value={commentRequestId}
+                            onChange={(event) => setCommentRequestId(event.target.value)}
+                            placeholder="Network request id"
+                            className="w-full px-3 py-2 bg-background border rounded-lg text-sm shadow-sm focus:ring-primary focus:border-primary transition-colors"
+                          />
+                        </div>
+                        <div className="space-y-1 flex gap-2">
+                           <div className="flex-1 space-y-1">
+                             <label className="text-xs font-semibold text-muted-foreground uppercase">Block Reason</label>
+                             <select
+                               value={commentBlockReason}
+                               onChange={(event) => setCommentBlockReason(event.target.value as CommentReportReason)}
+                               className="w-full px-3 py-2 bg-background border rounded-lg text-sm shadow-sm focus:ring-primary focus:border-primary transition-colors"
+                             >
+                               {state.commentReportReasons.map((reason) => (
+                                 <option key={reason} value={reason}>{reason}</option>
+                               ))}
+                             </select>
+                           </div>
+                           <div className="w-[100px] space-y-1">
+                             <label className="text-xs font-semibold text-muted-foreground uppercase whitespace-nowrap">Dur (m)</label>
+                             <input
+                               type="number"
+                               min="0"
+                               step="1"
+                               value={commentBlockDurationMinutes}
+                               onChange={(event) => setCommentBlockDurationMinutes(event.target.value)}
+                               placeholder="Opt"
+                               className="w-full px-3 py-2 bg-background border rounded-lg text-sm shadow-sm focus:ring-primary focus:border-primary transition-colors"
+                             />
+                           </div>
+                        </div>
+                      </div>
+                    </div>
+                  <div className="flex flex-col md:flex-row md:items-center justify-between gap-4 bg-muted/20 border border-border rounded-lg p-3">
+                    <div className="flex items-center gap-3">
+                      <div className="flex flex-col">
+                        <span className="text-[10px] uppercase font-bold text-muted-foreground mb-1">Bulk scope</span>
+                        <select
+                          value={commentBulkScopeMode}
+                          onChange={(event) => setCommentBulkScopeMode(event.target.value as CommentBulkScopeMode)}
+                          className="px-2 py-1.5 min-w-[140px] rounded border bg-background text-sm font-medium shadow-sm focus:ring-primary focus:border-primary transition-colors cursor-pointer"
+                        >
+                          <option value="selected">Selected (`${state.selectedCommentIds.length}`)</option>
+                          <option value="all">All matching filters</option>
+                        </select>
+                      </div>
+                      <div className="text-xs text-muted-foreground max-w-[200px] md:max-w-none pt-4">
+                        {commentBulkScopeMode === 'selected'
+                          ? `${state.selectedCommentIds.length} items targeted`
+                          : <span className="truncate block" title={buildCommentBulkScopeLabel()}>Scope: {buildCommentBulkScopeLabel()}</span>}
+                      </div>
+                    </div>
+                    <div className="flex gap-2 flex-wrap items-end self-end md:self-auto">
+                      <button
+                        type="button"
+                        onClick={() => void applyBulkCommentAction('approved')}
+                        disabled={!hasSelectableBulkScope || actionBusyId === 'bulk-comment'}
+                        className="text-sm px-3 py-1.5 rounded-lg border border-emerald-200 bg-emerald-50 text-emerald-700 hover:bg-emerald-100 font-medium transition-colors disabled:opacity-50 flex items-center gap-1.5"
                       >
-                        <option value="all">All</option>
-                        <option value="pending">Pending</option>
-                        <option value="approved">Approved</option>
-                        <option value="rejected">Rejected</option>
-                        <option value="spam">Spam</option>
-                        <option value="blocked">Blocked</option>
-                      </select>
-                    </label>
-                    <label className="text-sm text-muted-foreground">
-                      <span>Target</span>
-                      <select
-                        value={commentTargetType}
-                        onChange={(e) => setCommentTargetType(e.target.value as CommentTargetFilter)}
-                        className="w-full mt-1 px-3 py-2 rounded-lg border bg-background"
+                        <CheckCircle className="w-4 h-4" />
+                        Approve
+                      </button>
+                      <button
+                        type="button"
+                        onClick={() => void applyBulkCommentAction('rejected')}
+                        disabled={!hasSelectableBulkScope || actionBusyId === 'bulk-comment'}
+                        className="text-sm px-3 py-1.5 rounded-lg border border-rose-200 bg-rose-50 text-rose-700 hover:bg-rose-100 font-medium transition-colors disabled:opacity-50 flex items-center gap-1.5"
                       >
-                        <option value="all">All</option>
-                        <option value="page">Page</option>
-                        <option value="post">Post</option>
-                      </select>
-                    </label>
-                    <label className="text-sm text-muted-foreground">
-                      <span>Target ID</span>
-                      <input
-                        value={commentTargetId}
-                        onChange={(event) => setCommentTargetId(event.target.value)}
-                        placeholder="pageId / postId"
-                        className="w-full mt-1 px-3 py-2 rounded-lg border bg-background"
-                      />
-                    </label>
-                    <label className="text-sm text-muted-foreground">
-                      <span>Request ID</span>
-                      <input
-                        value={commentRequestId}
-                        onChange={(event) => setCommentRequestId(event.target.value)}
-                        placeholder="req_..."
-                        className="w-full mt-1 px-3 py-2 rounded-lg border bg-background"
-                      />
-                    </label>
-                    <label className="text-sm text-muted-foreground">
-                      <span>Block reason</span>
-                      <select
-                        value={commentBlockReason}
-                        onChange={(event) => setCommentBlockReason(event.target.value as CommentReportReason)}
-                        className="w-full mt-1 px-3 py-2 rounded-lg border bg-background"
+                        <MinusCircle className="w-4 h-4" />
+                        Reject
+                      </button>
+                      <button
+                        type="button"
+                        onClick={() => void applyBulkCommentAction('spam')}
+                        disabled={!hasSelectableBulkScope || actionBusyId === 'bulk-comment'}
+                        className="text-sm px-3 py-1.5 rounded-lg border border-amber-200 bg-amber-50 text-amber-700 hover:bg-amber-100 font-medium transition-colors disabled:opacity-50 flex items-center gap-1.5"
                       >
-                        {state.commentReportReasons.map((reason) => (
-                          <option key={reason} value={reason}>
-                            {reason}
-                          </option>
+                        <CircleSlash className="w-4 h-4" />
+                        Mark spam
+                      </button>
+                      <button
+                        type="button"
+                        onClick={() => void applyBulkCommentAction('blocked')}
+                        disabled={!hasSelectableBulkScope || actionBusyId === 'bulk-comment'}
+                        className="text-sm px-3 py-1.5 rounded-lg border border-red-200 bg-red-50 text-red-700 hover:bg-red-100 font-medium transition-colors disabled:opacity-50 flex items-center gap-1.5"
+                      >
+                        <CircleSlash className="w-4 h-4" />
+                        Block
+                      </button>
+                      <button
+                        type="button"
+                        onClick={clearCommentSelection}
+                        disabled={!state.selectedCommentIds.length}
+                        className="text-sm px-3 py-1.5 rounded-lg border hover:bg-muted font-medium transition-colors disabled:opacity-50"
+                      >
+                        Clear
+                      </button>
+                    </div>
+                  </div>
+                </div>
+
+                <div className="bg-card border border-border rounded-xl p-6 shadow-sm space-y-6">
+                  <div className="flex items-center justify-between border-b border-border pb-4">
+                    <div>
+                      <h3 className="font-semibold text-lg">Anti-abuse Policy Tuning</h3>
+                      <p className="text-sm text-muted-foreground mt-1">
+                        Configure rate limits and auto-block thresholds to protect your public comment forms.
+                      </p>
+                    </div>
+                    <div className="rounded-lg bg-muted/60 px-3 py-1.5 text-xs text-muted-foreground font-medium border border-border mr-2">
+                       Source: {hasActiveAntiAbusePolicy ? <span className="text-primary font-bold">site override</span> : <span>defaults</span>}
+                    </div>
+                  </div>
+                  <div className="space-y-6">
+                    <div className="flex items-start justify-between gap-2">
+                      <div>
+                        <h4 className="font-medium">Anti-abuse policy tuning</h4>
+                        <p className="text-xs text-muted-foreground">
+                          Tune request-level and user-level throttles and auto-block thresholds used by public comments.
+                        </p>
+                      </div>
+                      <span className="text-xs text-muted-foreground">
+                        Source:
+                        {' '}
+                        {hasActiveAntiAbusePolicy ? 'site override' : 'defaults'}
+                      </span>
+                    </div>
+                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-2">
+                      {COMMENT_ANTI_ABUSE_POLICY_FIELDS.map((field) => (
+                        <label key={field.key} className="text-xs text-muted-foreground">
+                          <span>{field.label}</span>
+                          <input
+                            type="number"
+                            min="0"
+                            step="1"
+                        value={state.commentAntiAbusePolicyForm[field.key]}
+                          onChange={(event) =>
+                            setState((prev) => ({
+                                ...prev,
+                                commentAntiAbusePolicyForm: {
+                                  ...prev.commentAntiAbusePolicyForm,
+                                  [field.key]: event.target.value,
+                                },
+                              }))
+                            }
+                            title={field.hint}
+                            className="w-full mt-1 px-3 py-2 rounded-lg border bg-background"
+                          />
+                        </label>
                         ))}
-                      </select>
-                    </label>
-                    <label className="text-sm text-muted-foreground">
-                      <span>Search</span>
-                      <input
-                        value={commentSearch}
-                        onChange={(event) => setCommentSearch(event.target.value)}
-                        placeholder="author, email, text..."
-                        className="w-full mt-1 px-3 py-2 rounded-lg border bg-background"
-                      />
-                    </label>
+                      </div>
+                      <div className="flex items-center gap-2 flex-wrap">
+                        {COMMENT_ANTI_ABUSE_PRESETS.map((preset) => (
+                          <button
+                            type="button"
+                            key={preset.key}
+                            onClick={() => applyCommentAntiAbusePreset(preset)}
+                            title={preset.description}
+                            className="text-xs px-2 py-1 rounded-md border hover:bg-accent/60"
+                          >
+                            {preset.label}
+                          </button>
+                        ))}
+                      </div>
+                    <div className="flex items-center gap-2">
+                      <button
+                        type="button"
+                        onClick={() => void saveCommentAntiAbusePolicy()}
+                        disabled={actionBusyId === 'comment-anti-abuse-policy' || state.commentAntiAbusePolicyLoading}
+                        className="text-xs px-2 py-1 rounded-md border hover:bg-emerald-50 hover:text-emerald-700"
+                      >
+                        Save policy
+                      </button>
+                      <button
+                        type="button"
+                        onClick={() => void clearCommentAntiAbusePolicy()}
+                        disabled={actionBusyId === 'comment-anti-abuse-policy' || state.commentAntiAbusePolicyLoading}
+                        className="text-xs px-2 py-1 rounded-md border hover:bg-amber-50 hover:text-amber-700"
+                      >
+                        Reset to defaults
+                      </button>
+                      <button
+                        type="button"
+                        onClick={() => void loadCommentAntiAbusePolicy()}
+                        disabled={state.commentAntiAbusePolicyLoading}
+                        className="text-xs px-2 py-1 rounded-md border hover:bg-slate-50"
+                      >
+                        Reload policy
+                      </button>
+                    </div>
                   </div>
-                  <div className="flex gap-2">
-                    <button
-                      type="button"
-                      onClick={() => void applyBulkCommentAction('approved')}
-                      disabled={!state.selectedCommentIds.length || actionBusyId === 'bulk-comment'}
-                      className="text-xs px-2 py-1 rounded-md border hover:bg-emerald-50 hover:text-emerald-700 flex items-center gap-1"
-                    >
-                      <CheckCircle className="w-3.5 h-3.5" />
-                      Approve selected
-                    </button>
-                    <button
-                      type="button"
-                      onClick={() => void applyBulkCommentAction('rejected')}
-                      disabled={!state.selectedCommentIds.length || actionBusyId === 'bulk-comment'}
-                      className="text-xs px-2 py-1 rounded-md border hover:bg-rose-50 hover:text-rose-700 flex items-center gap-1"
-                    >
-                      <MinusCircle className="w-3.5 h-3.5" />
-                      Reject selected
-                    </button>
-                    <button
-                      type="button"
-                      onClick={() => void applyBulkCommentAction('spam')}
-                      disabled={!state.selectedCommentIds.length || actionBusyId === 'bulk-comment'}
-                      className="text-xs px-2 py-1 rounded-md border hover:bg-amber-50 hover:text-amber-700 flex items-center gap-1"
-                    >
-                      <CircleSlash className="w-3.5 h-3.5" />
-                      Mark spam selected
-                    </button>
-                    <button
-                      type="button"
-                      onClick={() => void applyBulkCommentAction('blocked')}
-                      disabled={!state.selectedCommentIds.length || actionBusyId === 'bulk-comment'}
-                      className="text-xs px-2 py-1 rounded-md border hover:bg-red-50 hover:text-red-700 flex items-center gap-1"
-                    >
-                      <CircleSlash className="w-3.5 h-3.5" />
-                      Block selected
-                    </button>
-                    <button
-                      type="button"
-                      onClick={clearCommentSelection}
-                      disabled={!state.selectedCommentIds.length}
-                      className="text-xs px-2 py-1 rounded-md border hover:bg-slate-50"
-                    >
-                      Clear selection
-                    </button>
+                </div>
+
+                <div className="bg-card border border-border rounded-xl p-6 shadow-sm space-y-6">
+                  <div className="flex items-center justify-between border-b pb-4 mb-2">
+                    <div>
+                      <h3 className="font-semibold text-lg">Comment Blocklist</h3>
+                      <p className="text-sm text-muted-foreground mt-1">
+                        Manually block specific emails, IPs, users, or network requests from making comments.
+                      </p>
+                    </div>
+                  </div>
+                  <div className="space-y-5">
+                    <div className="flex items-center justify-between">
+                      <h4 className="font-medium text-sm uppercase text-muted-foreground tracking-widest">Active Entries</h4>
+                      <span className="text-xs text-muted-foreground">
+                        {state.selectedCommentBlockKeys.length > 0
+                          ? `${state.selectedCommentBlockKeys.length} selected`
+                          : `${state.commentBlocks.length} entries`}
+                      </span>
+                    </div>
+                    <div className="grid grid-cols-1 md:grid-cols-6 gap-2">
+                      <label className="text-sm text-muted-foreground">
+                        <span>Type</span>
+                        <select
+                          value={commentBlockTypeFilter}
+                          onChange={(event) =>
+                            setCommentBlockTypeFilter(event.target.value as CommentBlockForm['type'] | 'all')
+                          }
+                          className="w-full mt-1 px-3 py-2 rounded-lg border bg-background"
+                        >
+                          <option value="all">All</option>
+                          <option value="email">Email</option>
+                          <option value="ip">IP</option>
+                          <option value="user">User</option>
+                          <option value="request">Request</option>
+                        </select>
+                      </label>
+                      <label className="text-sm text-muted-foreground md:col-span-5">
+                        <span>Search</span>
+                        <input
+                          value={commentBlockFilter}
+                          onChange={(event) => setCommentBlockFilter(event.target.value)}
+                          className="w-full mt-1 px-3 py-2 rounded-lg border bg-background"
+                          placeholder="value / actor / reason / requestId"
+                        />
+                      </label>
+                    </div>
+                    <div className="grid grid-cols-1 md:grid-cols-6 gap-2">
+                      <label className="text-sm text-muted-foreground">
+                        <span>Show expired blocks</span>
+                        <div className="mt-1 flex items-center gap-2 px-3 py-2 rounded-lg border bg-background">
+                          <input
+                            type="checkbox"
+                            checked={commentBlockIncludeExpired}
+                            onChange={(event) => setCommentBlockIncludeExpired(event.target.checked)}
+                          />
+                          <span className="text-xs">
+                            {commentBlockIncludeExpired ? 'Include expired entries' : 'Hide expired entries'}
+                          </span>
+                        </div>
+                      </label>
+                    </div>
+                    <div className="grid grid-cols-1 md:grid-cols-6 gap-2">
+                      <label className="text-sm text-muted-foreground">
+                        <span>New block type</span>
+                        <select
+                          value={commentBlockForm.type}
+                          onChange={(event) =>
+                            setCommentBlockForm((prev) => ({
+                              ...prev,
+                              type: event.target.value as CommentBlockForm['type'],
+                            }))
+                          }
+                          className="w-full mt-1 px-3 py-2 rounded-lg border bg-background"
+                        >
+                          <option value="email">Email</option>
+                          <option value="ip">IP</option>
+                          <option value="user">User</option>
+                          <option value="request">Request</option>
+                        </select>
+                      </label>
+                      <label className="text-sm text-muted-foreground md:col-span-2">
+                        <span>Identifier</span>
+                        <input
+                          value={commentBlockForm.value}
+                          onChange={(event) =>
+                            setCommentBlockForm((prev) => ({ ...prev, value: event.target.value }))
+                          }
+                          placeholder={
+                            commentBlockForm.type === 'request'
+                              ? 'requestId'
+                              : commentBlockForm.type === 'ip'
+                                ? 'ip hash'
+                                : commentBlockForm.type === 'user'
+                                  ? 'user id'
+                                  : 'email'
+                          }
+                          className="w-full mt-1 px-3 py-2 rounded-lg border bg-background"
+                        />
+                      </label>
+                      <label className="text-sm text-muted-foreground md:col-span-2">
+                        <span>Reason</span>
+                        <input
+                          value={commentBlockForm.reason}
+                          onChange={(event) =>
+                            setCommentBlockForm((prev) => ({ ...prev, reason: event.target.value }))
+                          }
+                          className="w-full mt-1 px-3 py-2 rounded-lg border bg-background"
+                          placeholder="manual-block"
+                        />
+                      </label>
+                      <label className="text-sm text-muted-foreground">
+                        <span>Request ID</span>
+                        <input
+                          value={commentBlockForm.requestId}
+                          onChange={(event) =>
+                            setCommentBlockForm((prev) => ({ ...prev, requestId: event.target.value }))
+                          }
+                          className="w-full mt-1 px-3 py-2 rounded-lg border bg-background"
+                          placeholder="optional"
+                        />
+                      </label>
+                    </div>
+                    <div className="flex items-center gap-2">
+                      <button
+                        type="button"
+                        onClick={() => void createCommentBlock()}
+                        disabled={actionBusyId === 'create-comment-block' || !commentBlockForm.value.trim()}
+                        className="text-xs px-2 py-1 rounded-md border hover:bg-emerald-50 hover:text-emerald-700 flex items-center gap-1"
+                      >
+                        <Download className="w-3 h-3" />
+                        Add block
+                      </button>
+                      <button
+                        type="button"
+                        onClick={() => void toggleVisibleCommentBlockSelection()}
+                        disabled={!state.commentBlocks.length}
+                        className="text-xs px-2 py-1 rounded-md border hover:bg-accent flex items-center gap-1"
+                      >
+                        {areAllVisibleCommentBlocksSelected ? 'Clear visible' : `Select visible (${state.commentBlocks.length})`}
+                      </button>
+                      <button
+                        type="button"
+                        onClick={() => void deleteCommentBlocks()}
+                        disabled={!state.selectedCommentBlockKeys.length}
+                        className="text-xs px-2 py-1 rounded-md border hover:bg-red-50 hover:text-red-700 flex items-center gap-1"
+                      >
+                        <CircleSlash className="w-3 h-3" />
+                        Delete selected
+                      </button>
+                      <button
+                        type="button"
+                        onClick={() => clearCommentBlockSelection()}
+                        disabled={!state.selectedCommentBlockKeys.length}
+                        className="text-xs px-2 py-1 rounded-md border hover:bg-slate-50"
+                      >
+                        Clear selection
+                      </button>
+                    </div>
+                    {state.commentBlocksLoading ? (
+                      <div className="text-sm text-muted-foreground py-3">Loading blocks...</div>
+                    ) : state.commentBlocks.length === 0 ? (
+                      <div className="text-sm text-muted-foreground py-3">
+                        No blocked identifiers found.
+                      </div>
+                    ) : (
+                      <div className="space-y-2">
+                        {state.commentBlocks.map((block) => (
+                          <label
+                            key={block.key}
+                            className="flex items-start gap-2 border rounded-md p-2 border-border bg-card"
+                          >
+                            <input
+                              type="checkbox"
+                              checked={state.selectedCommentBlockKeys.includes(block.key)}
+                              onChange={(event) => toggleCommentBlockSelection(block.key, event.target.checked)}
+                            />
+                            <div className="text-sm">
+                              <div className="text-muted-foreground">
+                                <span className="font-medium">{block.type}</span>
+                                {' '}
+                                {block.value}
+                              </div>
+                              <div className="text-xs text-muted-foreground">
+                                reason:
+                                {' '}
+                                {block.reason || 'manual-block'}
+                                {block.actor ? ` • actor: ${block.actor}` : ''}
+                                {block.requestId ? ` • request: ${block.requestId}` : ''}
+                                {block.expiresAt ? ` • expires: ${formatTime(block.expiresAt)}` : ''}
+                              </div>
+                            </div>
+                          </label>
+                        ))}
+                      </div>
+                    )}
                   </div>
                   {state.commentsLoading ? (
                     <div className="text-sm text-muted-foreground py-4">Loading comments...</div>
@@ -1524,7 +3270,15 @@ function EditSitePage() {
                                 reasons:
                                 {' '}
                                 {(comment.reportReasons?.length ? comment.reportReasons : []).join(', ') || '—'}
+                                {comment.commentThreadId ? ` • thread ${comment.commentThreadId}` : ''}
                               </p>
+                              {comment.spamFlags?.length ? (
+                                <p className="text-xs text-muted-foreground">
+                                  Anti-abuse flags:
+                                  {' '}
+                                  {comment.spamFlags.join(', ')}
+                                </p>
+                              ) : null}
                             </div>
                           </div>
                           <p className="text-sm mt-2">{comment.content}</p>
@@ -1538,6 +3292,19 @@ function EditSitePage() {
                             </p>
                           ) : null}
                           <div className="mt-3 flex gap-2 flex-wrap">
+                            {comment.commentThreadId ? (
+                              <button
+                                onClick={() => {
+                                  setCommentTargetType(comment.targetType);
+                                  setCommentTargetId(comment.targetId);
+                                  setCommentThreadId(comment.commentThreadId || '');
+                                }}
+                                disabled={actionBusyId === comment.id}
+                                className="text-xs px-2 py-1 rounded-md border hover:bg-violet-50 hover:text-violet-700 flex items-center gap-1"
+                              >
+                                Focus thread
+                              </button>
+                            ) : null}
                             <button
                               onClick={() =>
                                 updateCommentStatus(comment, 'approved', undefined, commentRequestId || undefined)}
@@ -1572,6 +3339,7 @@ function EditSitePage() {
                                   'blocked',
                                   commentBlockReason,
                                   commentRequestId || undefined,
+                                  parseCommentBlockDuration(),
                                 )}
                               disabled={actionBusyId === comment.id}
                               className="text-xs px-2 py-1 rounded-md border hover:bg-red-50 hover:text-red-700 flex items-center gap-1"
@@ -1593,9 +3361,10 @@ function EditSitePage() {
                     </div>
                   )}
                 </div>
-              </div>
-            </>
-          )}
+                  </div>
+                </div>
+                </div>
+              )} 
         </section>
       </div>
     </PageShell>
diff --git a/apps/admin/src/routes/sites.new.tsx b/apps/admin/src/routes/sites.new.tsx
index b19c171..725799f 100644
--- a/apps/admin/src/routes/sites.new.tsx
+++ b/apps/admin/src/routes/sites.new.tsx
@@ -8,6 +8,7 @@ import { useState } from 'react';
 import { createFileRoute, useNavigate } from '@tanstack/react-router';
 import { Globe, Save, ArrowLeft } from 'lucide-react';
 import { useStore } from '@/stores/mockStore';
+import { useAuthStore, selectCanEdit } from '@/stores/authStore';
 import { PageShell } from '@/components/layout/PageShell';
 import { cn } from '@/lib/utils';
 
@@ -17,6 +18,7 @@ export const Route = createFileRoute('/sites/new')({
 
 function NewSitePage() {
     const navigate = useNavigate();
+    const canEdit = useAuthStore(selectCanEdit);
     const { addSite } = useStore();
     const [isLoading, setIsLoading] = useState(false);
     const [formData, setFormData] = useState({
@@ -29,6 +31,11 @@ function NewSitePage() {
 
     const handleSubmit = async (e: React.FormEvent) => {
         e.preventDefault();
+        if (!canEdit) {
+            alert('You do not have permission to create sites.');
+            return;
+        }
+
         setIsLoading(true);
 
         // Simulate network delay
@@ -58,6 +65,11 @@ function NewSitePage() {
                 </button>
             }
         >
+            {!canEdit ? (
+                <div className="mb-4 border border-border rounded-lg p-3 bg-muted/30 text-sm text-muted-foreground">
+                    View-only role: you can browse sites but cannot create new ones.
+                </div>
+            ) : null}
             <div className="max-w-2xl mx-auto">
                 <form onSubmit={handleSubmit} className="space-y-6">
                     <div className="bg-card border border-border rounded-xl p-6 space-y-6 shadow-sm">
@@ -148,6 +160,7 @@ function NewSitePage() {
                         <button
                             type="submit"
                             disabled={isLoading || !formData.name}
+                            hidden={!canEdit}
                             className={cn(
                                 'flex items-center gap-2 px-6 py-2.5 rounded-lg',
                                 'bg-primary text-primary-foreground font-medium',
diff --git a/apps/admin/src/routes/sites.tsx b/apps/admin/src/routes/sites.tsx
index cafca08..bc7ca3f 100644
--- a/apps/admin/src/routes/sites.tsx
+++ b/apps/admin/src/routes/sites.tsx
@@ -7,6 +7,7 @@
 import { createFileRoute, Link, useNavigate, Outlet, useRouterState } from '@tanstack/react-router';
 import { Plus, Globe, MoreVertical, Edit, Trash2, ExternalLink, Copy } from 'lucide-react';
 import { useStore, type Site } from '@/stores/mockStore';
+import { useAuthStore, selectCanEdit } from '@/stores/authStore';
 import { useDataTable, type Column } from '@/hooks/useDataTable';
 import { PageShell } from '@/components/layout/PageShell';
 import { DataGrid } from '@/components/ui/DataGrid';
@@ -32,6 +33,7 @@ function SitesLayout() {
 
 function SitesListView() {
   const navigate = useNavigate();
+  const canEdit = useAuthStore(selectCanEdit);
   const { sites, deleteSite } = useStore();
 
   // Define columns
@@ -73,7 +75,7 @@ function SitesListView() {
     {
       key: 'actions',
       label: '',
-      render: (site) => (
+      render: (site) => canEdit ? (
         <div className="flex items-center justify-end gap-2">
           <button
             onClick={() => navigate({ to: '/sites/$siteId', params: { siteId: site.id } })}
@@ -84,6 +86,9 @@ function SitesListView() {
           </button>
           <button
             onClick={() => {
+              if (!canEdit) {
+                return;
+              }
               if (confirm('Are you sure you want to delete this site?')) {
                 deleteSite(site.id);
               }
@@ -94,7 +99,7 @@ function SitesListView() {
             <Trash2 className="w-4 h-4" />
           </button>
         </div>
-      )
+      ) : null
     }
   ];
 
diff --git a/apps/admin/src/routes/users.$userId.tsx b/apps/admin/src/routes/users.$userId.tsx
index 3b7501b..b3201cc 100644
--- a/apps/admin/src/routes/users.$userId.tsx
+++ b/apps/admin/src/routes/users.$userId.tsx
@@ -6,6 +6,7 @@ import { useState, useEffect } from 'react';
 import { createFileRoute, useNavigate } from '@tanstack/react-router';
 import { Save, Trash2, Mail, ShieldAlert } from 'lucide-react';
 import { useStore } from '@/stores/mockStore';
+import { useAuthStore, selectCanAdminister } from '@/stores/authStore';
 import { PageShell } from '@/components/layout/PageShell';
 import { cn } from '@/lib/utils';
 
@@ -16,6 +17,7 @@ export const Route = createFileRoute('/users/$userId')({
 function EditUserPage() {
   const navigate = useNavigate();
   const { userId } = Route.useParams();
+  const canAdminister = useAuthStore(selectCanAdminister);
   const { users, updateUser, deleteUser } = useStore();
   const user = users.find(u => u.id === userId);
 
@@ -52,6 +54,10 @@ function EditUserPage() {
 
   const handleSubmit = async (e: React.FormEvent) => {
     e.preventDefault();
+    if (!canAdminister) {
+      alert('You do not have permission to update users.');
+      return;
+    }
     setIsLoading(true);
     await new Promise(resolve => setTimeout(resolve, 800));
 
@@ -65,20 +71,30 @@ function EditUserPage() {
       description={`Manage settings for ${user.fullName}`}
       action={
         <div className="flex gap-2">
-          <button
-            onClick={() => {
-              if (confirm('Remove user?')) {
-                deleteUser(userId);
-                navigate({ to: '/users' });
-              }
-            }}
-            className="p-2 text-red-600 hover:bg-red-50 rounded-lg"
-          >
-            <Trash2 className="w-5 h-5" />
-          </button>
+          {canAdminister ? (
+            <button
+              onClick={() => {
+                if (!canAdminister) {
+                  return;
+                }
+                if (confirm('Remove user?')) {
+                  deleteUser(userId);
+                  navigate({ to: '/users' });
+                }
+              }}
+              className="p-2 text-red-600 hover:bg-red-50 rounded-lg"
+            >
+              <Trash2 className="w-5 h-5" />
+            </button>
+          ) : null}
         </div>
       }
     >
+      {!canAdminister ? (
+        <div className="mb-4 border border-border rounded-lg p-3 bg-muted/30 text-sm text-muted-foreground">
+          Admin-only role: you do not have permission to edit users.
+        </div>
+      ) : null}
       <div className="max-w-md mx-auto">
         <form onSubmit={handleSubmit} className="space-y-8">
 
@@ -91,6 +107,7 @@ function EditUserPage() {
                 value={formData.fullName}
                 onChange={(e) => setFormData({ ...formData, fullName: e.target.value })}
                 className="w-full px-4 py-2.5 rounded-lg border bg-background focus:outline-none focus:ring-2 focus:ring-ring"
+                disabled={!canAdminister}
               />
             </div>
 
@@ -104,6 +121,7 @@ function EditUserPage() {
                   value={formData.email}
                   onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                   className="w-full pl-10 pr-4 py-2.5 rounded-lg border bg-background focus:outline-none focus:ring-2 focus:ring-ring"
+                  disabled={!canAdminister}
                 />
               </div>
             </div>
@@ -115,6 +133,7 @@ function EditUserPage() {
                 value={formData.role}
                 onChange={(e) => setFormData({ ...formData, role: e.target.value as any })}
                 className="w-full px-4 py-2.5 rounded-lg border bg-background focus:outline-none focus:ring-2 focus:ring-ring"
+                disabled={!canAdminister}
               >
                 <option value="admin">Admin</option>
                 <option value="editor">Editor</option>
@@ -123,19 +142,20 @@ function EditUserPage() {
             </div>
           </div>
 
-          {/* Danger Zone */}
-          <div className="bg-red-50 dark:bg-red-900/10 border border-red-200 dark:border-red-900 rounded-xl p-6">
-            <h3 className="text-red-800 dark:text-red-400 font-semibold flex items-center gap-2 mb-2">
-              <ShieldAlert className="w-4 h-4" />
-              Reset Password
-            </h3>
-            <p className="text-sm text-red-600 dark:text-red-300 mb-4">
-              Send a password reset email to the user.
-            </p>
-            <button type="button" className="px-4 py-2 bg-white dark:bg-transparent border border-red-200 text-red-600 rounded-lg text-sm font-medium hover:bg-red-50">
-              Send Reset Link
-            </button>
-          </div>
+          {canAdminister ? (
+            <div className="bg-red-50 dark:bg-red-900/10 border border-red-200 dark:border-red-900 rounded-xl p-6">
+              <h3 className="text-red-800 dark:text-red-400 font-semibold flex items-center gap-2 mb-2">
+                <ShieldAlert className="w-4 h-4" />
+                Reset Password
+              </h3>
+              <p className="text-sm text-red-600 dark:text-red-300 mb-4">
+                Send a password reset email to the user.
+              </p>
+              <button type="button" className="px-4 py-2 bg-white dark:bg-transparent border border-red-200 text-red-600 rounded-lg text-sm font-medium hover:bg-red-50">
+                Send Reset Link
+              </button>
+            </div>
+          ) : null}
 
           <div className="flex justify-end gap-3">
             <button
@@ -147,6 +167,7 @@ function EditUserPage() {
             </button>
             <button
               type="submit"
+              hidden={!canAdminister}
               disabled={isLoading}
               className={cn(
                 'flex items-center gap-2 px-6 py-2.5 rounded-lg',
diff --git a/apps/admin/src/routes/users.new.tsx b/apps/admin/src/routes/users.new.tsx
index 25344db..5aa2f75 100644
--- a/apps/admin/src/routes/users.new.tsx
+++ b/apps/admin/src/routes/users.new.tsx
@@ -4,8 +4,9 @@
 
 import { useState } from 'react';
 import { createFileRoute, useNavigate } from '@tanstack/react-router';
-import { ArrowLeft, UserPlus, Mail, Lock } from 'lucide-react';
+import { ArrowLeft, UserPlus } from 'lucide-react';
 import { useStore } from '@/stores/mockStore';
+import { useAuthStore, selectCanAdminister } from '@/stores/authStore';
 import { PageShell } from '@/components/layout/PageShell';
 import { cn } from '@/lib/utils';
 
@@ -16,6 +17,7 @@ export const Route = createFileRoute('/users/new')({
 function NewUserPage() {
   const navigate = useNavigate();
   const { addUser } = useStore();
+  const canAdminister = useAuthStore(selectCanAdminister);
   const [isLoading, setIsLoading] = useState(false);
   const [formData, setFormData] = useState({
     fullName: '',
@@ -25,6 +27,11 @@ function NewUserPage() {
 
   const handleSubmit = async (e: React.FormEvent) => {
     e.preventDefault();
+    if (!canAdminister) {
+      alert('You do not have permission to invite users.');
+      return;
+    }
+
     setIsLoading(true);
     await new Promise(resolve => setTimeout(resolve, 800));
 
@@ -42,6 +49,11 @@ function NewUserPage() {
         </button>
       }
     >
+      {!canAdminister ? (
+        <div className="mb-4 border border-border rounded-lg p-3 bg-muted/30 text-sm text-muted-foreground">
+          Admin-only role: you can browse users but cannot invite members.
+        </div>
+      ) : null}
       <div className="max-w-md mx-auto">
         <form onSubmit={handleSubmit} className="space-y-6">
           <div className="bg-card border border-border rounded-xl p-6 space-y-6 shadow-sm">
@@ -55,6 +67,7 @@ function NewUserPage() {
                 onChange={(e) => setFormData({ ...formData, fullName: e.target.value })}
                 placeholder="John Doe"
                 className="w-full px-4 py-2.5 rounded-lg border bg-background focus:outline-none focus:ring-2 focus:ring-ring"
+                disabled={!canAdminister}
                 required
               />
             </div>
@@ -68,6 +81,7 @@ function NewUserPage() {
                 onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                 placeholder="john@example.com"
                 className="w-full px-4 py-2.5 rounded-lg border bg-background focus:outline-none focus:ring-2 focus:ring-ring"
+                disabled={!canAdminister}
                 required
               />
             </div>
@@ -91,6 +105,7 @@ function NewUserPage() {
                       checked={formData.role === role}
                       onChange={(e) => setFormData({ ...formData, role: e.target.value as any })}
                       className="w-4 h-4 text-primary border-gray-300 focus:ring-primary"
+                      disabled={!canAdminister}
                     />
                     <div className="ml-3">
                       <span className="block text-sm font-medium capitalize">{role}</span>
@@ -116,6 +131,7 @@ function NewUserPage() {
             </button>
             <button
               type="submit"
+              hidden={!canAdminister}
               disabled={isLoading || !formData.email}
               className={cn(
                 'flex items-center gap-2 px-6 py-2.5 rounded-lg',
diff --git a/apps/admin/src/routes/users.tsx b/apps/admin/src/routes/users.tsx
index 80ad4bf..68ed9d8 100644
--- a/apps/admin/src/routes/users.tsx
+++ b/apps/admin/src/routes/users.tsx
@@ -5,8 +5,9 @@
  */
 
 import { createFileRoute, Link, useNavigate, Outlet, useRouterState } from '@tanstack/react-router';
-import { Plus, User, MoreVertical, Edit, Trash2, Mail } from 'lucide-react';
+import { Plus, User, Edit, Trash2 } from 'lucide-react';
 import { useStore, type User as UserType } from '@/stores/mockStore';
+import { useAuthStore, selectCanAdminister } from '@/stores/authStore';
 import { useDataTable, type Column } from '@/hooks/useDataTable';
 import { PageShell } from '@/components/layout/PageShell';
 import { DataGrid } from '@/components/ui/DataGrid';
@@ -31,6 +32,7 @@ function UsersLayout() {
 
 function UsersListView() {
   const navigate = useNavigate();
+  const canAdminister = useAuthStore(selectCanAdminister);
   const { users, deleteUser } = useStore();
 
   const columns: Column<UserType>[] = [
@@ -73,7 +75,7 @@ function UsersListView() {
     {
       key: 'actions',
       label: '',
-      render: (user) => (
+      render: (user) => canAdminister ? (
         <div className="flex items-center justify-end gap-2">
           <button
             onClick={() => navigate({ to: '/users/$userId', params: { userId: user.id } })}
@@ -83,6 +85,9 @@ function UsersListView() {
           </button>
           <button
             onClick={() => {
+              if (!canAdminister) {
+                return;
+              }
               if (confirm('Remove this user?')) deleteUser(user.id);
             }}
             className="p-2 text-muted-foreground hover:text-red-600 hover:bg-red-50 rounded-lg transition-colors"
@@ -90,7 +95,7 @@ function UsersListView() {
             <Trash2 className="w-4 h-4" />
           </button>
         </div>
-      )
+      ) : null
     }
   ];
 
@@ -115,15 +120,22 @@ function UsersListView() {
       title="Team Members"
       description="Manage access and roles for your team."
       action={
-        <Link
-          to="/users/new"
-          className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-primary text-primary-foreground font-medium hover:bg-primary/90 transition-colors"
-        >
-          <Plus className="w-4 h-4" />
-          Invite User
-        </Link>
+        canAdminister ? (
+          <Link
+            to="/users/new"
+            className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-primary text-primary-foreground font-medium hover:bg-primary/90 transition-colors"
+          >
+            <Plus className="w-4 h-4" />
+            Invite User
+          </Link>
+        ) : null
       }
     >
+      {!canAdminister ? (
+        <div className="mb-4 border border-border rounded-lg p-3 bg-muted/30 text-sm text-muted-foreground">
+          View-only role: you do not have permission to manage team members.
+        </div>
+      ) : null}
       <div className="flex items-center gap-4 mb-6">
         <div className="relative flex-1 max-w-sm">
           <input
@@ -151,13 +163,19 @@ function UsersListView() {
             title="No users found"
             description="Invite team members to collaborate."
             action={
-              <Link
-                to="/users/new"
-                className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-primary text-primary-foreground font-medium hover:bg-primary/90 mt-4"
-              >
-                <Plus className="w-4 h-4" />
-                Invite User
-              </Link>
+              canAdminister ? (
+                <Link
+                  to="/users/new"
+                  className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-primary text-primary-foreground font-medium hover:bg-primary/90 mt-4"
+                >
+                  <Plus className="w-4 h-4" />
+                  Invite User
+                </Link>
+              ) : (
+                <div className="text-sm text-muted-foreground">
+                  You do not have permission to invite team members.
+                </div>
+              )
             }
           />
         }
diff --git a/apps/admin/src/stores/authStore.ts b/apps/admin/src/stores/authStore.ts
index d3cdf28..28bd4c8 100644
--- a/apps/admin/src/stores/authStore.ts
+++ b/apps/admin/src/stores/authStore.ts
@@ -22,7 +22,7 @@ export interface User {
   id: string;
   email: string;
   fullName: string;
-  role: 'admin' | 'editor' | 'viewer';
+  role: 'owner' | 'admin' | 'editor' | 'viewer';
   avatarUrl?: string;
 }
 
@@ -30,6 +30,8 @@ interface AuthState {
   user: User | null;
   isLoading: boolean;
   error: string | null;
+  sessionExpiresAt: number | null;
+  isHydrated: boolean;
 }
 
 interface AuthActions {
@@ -45,6 +47,15 @@ type AuthStore = AuthState & AuthActions;
 // ============================================
 
 const MOCK_USERS: Record<string, { password: string; user: User }> = {
+  'owner@backy.io': {
+    password: 'owner123',
+    user: {
+      id: '0',
+      email: 'owner@backy.io',
+      fullName: 'Owner User',
+      role: 'owner',
+    },
+  },
   'admin@backy.io': {
     password: 'admin123',
     user: {
@@ -63,8 +74,21 @@ const MOCK_USERS: Record<string, { password: string; user: User }> = {
       role: 'editor',
     },
   },
+  'viewer@backy.io': {
+    password: 'viewer123',
+    user: {
+      id: '3',
+      email: 'viewer@backy.io',
+      fullName: 'Viewer User',
+      role: 'viewer',
+    },
+  },
 };
 
+const isSessionActiveNow = (state: AuthState): boolean => (
+  Boolean(state.user && state.sessionExpiresAt && state.sessionExpiresAt > Date.now())
+);
+
 // ============================================
 // STORE
 // ============================================
@@ -72,12 +96,15 @@ const MOCK_USERS: Record<string, { password: string; user: User }> = {
 export const useAuthStore = create<AuthStore>()(
   persist(
     (set) => ({
-      // ============================================
-      // STATE - isLoading starts FALSE so form works
+    // ============================================
+    // STATE - isLoading starts FALSE so form works
       // ============================================
       user: null,
       isLoading: false,
       error: null,
+      sessionExpiresAt: null,
+      // Start hydrated to avoid permanent loading when storage has no persisted state.
+      isHydrated: true,
 
       // ============================================
       // ACTIONS
@@ -95,12 +122,13 @@ export const useAuthStore = create<AuthStore>()(
           set({
             error: 'Invalid email or password',
             isLoading: false,
-          });
+    });
           throw new Error('Invalid credentials');
         }
 
         set({
           user: mockUser.user,
+          sessionExpiresAt: Date.now() + 8 * 60 * 60 * 1000,
           isLoading: false,
           error: null,
         });
@@ -109,6 +137,7 @@ export const useAuthStore = create<AuthStore>()(
       signOut: () => {
         set({
           user: null,
+          sessionExpiresAt: null,
           isLoading: false,
           error: null,
         });
@@ -119,10 +148,19 @@ export const useAuthStore = create<AuthStore>()(
         set({ error: null });
       },
     }),
-    {
+      {
       name: 'backy-auth-storage',
+      // Ensure hydration completes even when no persisted state exists.
+      onRehydrateStorage: () => (state) => {
+        if (state) {
+          state.isHydrated = true;
+          return;
+        }
+        // no-op: persist callbacks receive undefined when storage is empty in some environments.
+      },
       partialize: (state) => ({
         user: state.user,
+        sessionExpiresAt: state.sessionExpiresAt,
       }),
     }
   )
@@ -133,10 +171,22 @@ export const useAuthStore = create<AuthStore>()(
 // ============================================
 
 export const selectIsAuthenticated = (state: AuthStore): boolean =>
-  !!state.user;
+  isSessionActiveNow(state) && !!state.user;
 
 export const selectIsAdmin = (state: AuthStore): boolean =>
-  state.user?.role === 'admin';
+  isSessionActiveNow(state) && (state.user?.role === 'admin' || state.user?.role === 'owner');
 
 export const selectCanEdit = (state: AuthStore): boolean =>
-  state.user?.role === 'admin' || state.user?.role === 'editor';
+  isSessionActiveNow(state) && (state.user?.role === 'admin' || state.user?.role === 'owner' || state.user?.role === 'editor');
+
+export const selectCanPublish = (state: AuthStore): boolean =>
+  isSessionActiveNow(state) && (state.user?.role === 'admin' || state.user?.role === 'owner' || state.user?.role === 'editor');
+
+export const selectCanAdminister = (state: AuthStore): boolean =>
+  isSessionActiveNow(state) && (state.user?.role === 'admin' || state.user?.role === 'owner');
+
+export const selectIsSessionActive = (state: AuthStore): boolean =>
+  isSessionActiveNow(state);
+
+export const selectSessionExpiresAt = (state: AuthStore): number | null =>
+  state.sessionExpiresAt;
diff --git a/apps/admin/src/stores/mockStore.ts b/apps/admin/src/stores/mockStore.ts
index f53d485..4983600 100644
--- a/apps/admin/src/stores/mockStore.ts
+++ b/apps/admin/src/stores/mockStore.ts
@@ -288,7 +288,16 @@ export const useStore = create<AppState>()(
             })),
 
             updatePage: (id, updates) => set((state) => ({
-                pages: state.pages.map(p => p.id === id ? { ...p, ...updates, lastUpdated: new Date().toISOString() } : p)
+                pages: state.pages.map(p => p.id === id
+                  ? {
+                      ...p,
+                      ...updates,
+                      lastUpdated: (typeof updates.lastUpdated === 'string' && updates.lastUpdated)
+                        ? updates.lastUpdated
+                        : new Date().toISOString(),
+                    }
+                  : p
+                )
             })),
 
             // Post Actions
diff --git a/apps/admin/src/types/editor.ts b/apps/admin/src/types/editor.ts
index 3e86839..9aac7e3 100644
--- a/apps/admin/src/types/editor.ts
+++ b/apps/admin/src/types/editor.ts
@@ -116,7 +116,7 @@ export interface ElementProps {
   [key: string]: unknown;
 
   // Text/Heading
-  content?: string;
+  content?: string | unknown[];
   level?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
   fontSize?: number | string;
   fontStyle?: string;
@@ -218,6 +218,12 @@ export interface ElementProps {
   commentRequireEmail?: boolean;
   commentAllowReplies?: boolean;
   commentSortOrder?: 'newest' | 'oldest';
+  commentAntiAbuseRateLimit?: number;
+  commentAntiAbuseRateWindowMs?: number;
+  commentAntiAbuseSignatureWindowMs?: number;
+  commentAntiAbuseMinFillMs?: number;
+  commentAntiAbuseAutoBlockSpamCount?: number;
+  commentAntiAbuseAutoBlockDurationMinutes?: number;
 }
 
 export interface ComponentDefinition {
diff --git a/apps/public/src/app/api/sites/[siteId]/blog/[postId]/comments/route.ts b/apps/public/src/app/api/sites/[siteId]/blog/[postId]/comments/route.ts
index 26ca527..6c5e34b 100644
--- a/apps/public/src/app/api/sites/[siteId]/blog/[postId]/comments/route.ts
+++ b/apps/public/src/app/api/sites/[siteId]/blog/[postId]/comments/route.ts
@@ -7,6 +7,13 @@ import {
   getSiteByIdOrSlug,
   validateAndClassifyComment,
 } from '@/lib/backyStore';
+import {
+  type BackyCommentIdentity,
+  mergeBackyCommentIdentities,
+  hasSignedInBackyCommentIdentity,
+  readBackyCommentIdentityFromQuery,
+  readBackyCommentIdentityFromHeaders,
+} from '@/lib/backyAuthBridge';
 
 interface RouteParams {
   params: Promise<{
@@ -34,12 +41,24 @@ function parseSort(raw: string | null) {
   return raw === 'oldest' ? 'oldest' : 'newest';
 }
 
-function parseModerationMode(raw: unknown): 'manual' | 'auto-approve' {
-  return raw === 'auto-approve' ? 'auto-approve' : 'manual';
+function parseTextInput(raw: unknown) {
+  if (typeof raw === 'string') {
+    return raw.trim();
+  }
+
+  if (typeof raw === 'number' && Number.isFinite(raw)) {
+    return String(raw);
+  }
+
+  return '';
 }
 
-function parseTextInput(raw: unknown) {
-  return typeof raw === 'string' ? raw.trim() : '';
+function toRecord(value: unknown): Record<string, unknown> | null {
+  if (!value || typeof value !== 'object' || Array.isArray(value)) {
+    return null;
+  }
+
+  return value as Record<string, unknown>;
 }
 
 function parseBoolean(raw: unknown): boolean | undefined {
@@ -65,6 +84,254 @@ function parseBoolean(raw: unknown): boolean | undefined {
   return undefined;
 }
 
+function parseNumber(raw: unknown): number | undefined {
+  if (typeof raw === 'number' && Number.isFinite(raw)) {
+    return Math.trunc(raw);
+  }
+
+  if (typeof raw === 'string') {
+    const parsed = Number.parseFloat(raw.trim());
+    return Number.isFinite(parsed) ? Math.trunc(parsed) : undefined;
+  }
+
+  return undefined;
+}
+
+function readNumberField(source: Record<string, unknown>, keys: string[]): number | undefined {
+  for (const key of keys) {
+    if (!(key in source)) {
+      continue;
+    }
+
+    const value = parseNumber(source[key]);
+    if (value !== undefined) {
+      return value;
+    }
+  }
+
+  return undefined;
+}
+
+function readCommentAntiAbusePolicy(body: Record<string, unknown>) {
+  const nested = toRecord(body.commentAntiAbuse) || toRecord(body.antiAbuse);
+  const sources: Array<Record<string, unknown>> = [];
+
+  if (nested) {
+    sources.push(nested);
+  }
+
+  sources.push(body);
+
+  const merged = Object.fromEntries(sources.flatMap(Object.entries));
+  const policy = {
+    rateLimit: readNumberField({ ...merged, ...(nested || {}) }, ['rateLimit', 'commentRateLimit', 'commentAntiAbuseRateLimit', 'antiAbuseRateLimit']),
+    rateWindowMs: readNumberField(
+      { ...merged, ...(nested || {}) },
+      ['rateWindowMs', 'commentRateWindowMs', 'commentAntiAbuseRateWindowMs', 'antiAbuseRateWindowMs'],
+    ),
+    signatureWindowMs: readNumberField(
+      { ...merged, ...(nested || {}) },
+      ['signatureWindowMs', 'commentSignatureWindowMs', 'commentAntiAbuseSignatureWindowMs', 'antiAbuseSignatureWindowMs'],
+    ),
+    minFillMs: readNumberField(
+      { ...merged, ...(nested || {}) },
+      ['minFillMs', 'commentAntiAbuseMinFillMs', 'antiAbuseMinFillMs'],
+    ),
+    autoBlockSpamCount: readNumberField(
+      { ...merged, ...(nested || {}) },
+      ['autoBlockSpamCount', 'commentAntiAbuseAutoBlockSpamCount', 'antiAbuseAutoBlockSpamCount'],
+    ),
+    autoBlockDurationMinutes: readNumberField(
+      { ...merged, ...(nested || {}) },
+      ['autoBlockDurationMinutes', 'commentAntiAbuseAutoBlockDurationMinutes', 'antiAbuseAutoBlockDurationMinutes'],
+    ),
+    requestRateLimit: readNumberField(
+      { ...merged, ...(nested || {}) },
+      [
+        'requestRateLimit',
+        'commentRequestRateLimit',
+        'commentAntiAbuseRequestRateLimit',
+        'antiAbuseRequestRateLimit',
+      ],
+    ),
+    requestRateWindowMs: readNumberField(
+      { ...merged, ...(nested || {}) },
+      [
+        'requestRateWindowMs',
+        'commentRequestRateWindowMs',
+        'commentAntiAbuseRequestRateWindowMs',
+        'antiAbuseRequestRateWindowMs',
+      ],
+    ),
+    autoBlockUserThreshold: readNumberField(
+      { ...merged, ...(nested || {}) },
+      [
+        'autoBlockUserThreshold',
+        'commentAutoBlockUserThreshold',
+        'commentAntiAbuseAutoBlockUserThreshold',
+        'antiAbuseAutoBlockUserThreshold',
+      ],
+    ),
+    autoBlockRequestThreshold: readNumberField(
+      { ...merged, ...(nested || {}) },
+      [
+        'autoBlockRequestThreshold',
+        'commentAutoBlockRequestThreshold',
+        'commentAntiAbuseAutoBlockRequestThreshold',
+        'antiAbuseAutoBlockRequestThreshold',
+      ],
+    ),
+  };
+
+  const hasValues = Object.values(policy).some((value) => value !== undefined);
+  return hasValues ? policy : undefined;
+}
+
+function readBooleanField(body: Record<string, unknown>, keys: string[]): boolean | undefined {
+  for (const key of keys) {
+    if (!(key in body)) {
+      continue;
+    }
+    const parsed = parseBoolean((body as Record<string, unknown>)[key]);
+    if (parsed !== undefined) {
+      return parsed;
+    }
+  }
+
+  return undefined;
+}
+
+function readStringField(body: Record<string, unknown>, keys: string[]): string | undefined {
+  for (const key of keys) {
+    if (!(key in body)) {
+      continue;
+    }
+
+    const value = body[key];
+    if (typeof value === 'string' && value.trim().length > 0) {
+      return value.trim();
+    }
+  }
+
+  return undefined;
+}
+
+function readStringFromSource(value: unknown, keys: string[]): string | undefined {
+  const source = toRecord(value);
+  if (!source) {
+    return undefined;
+  }
+
+  for (const key of keys) {
+    const next = parseTextInput(source[key]);
+    if (next) {
+      return next;
+    }
+  }
+
+  return undefined;
+}
+
+function readIdentityFieldFromSource(value: unknown, keys: string[]): string | undefined {
+  const source = toRecord(value);
+  if (!source) {
+    return undefined;
+  }
+
+  for (const key of keys) {
+    const next = parseTextInput(source[key]);
+    if (next) {
+      return next;
+    }
+  }
+
+  return undefined;
+}
+
+function readCommentIdentityFromPayload(body: Record<string, unknown>): BackyCommentIdentity | null {
+  const nestedIdentity = toRecord(body.identity);
+  const nestedActor = toRecord(body.actor);
+  const nestedAuthor = toRecord(body.author);
+
+  const identity: BackyCommentIdentity = {
+    userId:
+      readStringField(body, ['userId', 'commentUserId', 'authorUserId', 'identityUserId', 'actorId', 'requesterId']) ||
+      readIdentityFieldFromSource(nestedIdentity, ['userId', 'id', 'uid', 'sub', 'user_id', '_id']) ||
+      readIdentityFieldFromSource(nestedActor, ['userId', 'id', 'uid', 'sub', 'user_id', '_id']) ||
+      readIdentityFieldFromSource(nestedAuthor, ['userId', 'id', 'uid', 'sub', 'user_id', '_id']),
+    name:
+      readStringField(body, ['name', 'authorName', 'commentAuthorName', 'fullName', 'userName']) ||
+      readIdentityFieldFromSource(nestedIdentity, ['name', 'fullName', 'userName']) ||
+      readIdentityFieldFromSource(nestedActor, ['name', 'fullName', 'userName']) ||
+      readIdentityFieldFromSource(nestedAuthor, ['name', 'fullName', 'userName']),
+    email:
+      readStringField(body, ['email', 'authorEmail', 'commentAuthorEmail']) ||
+      readIdentityFieldFromSource(nestedIdentity, ['email', 'emailAddress', 'contactEmail']) ||
+      readIdentityFieldFromSource(nestedActor, ['email', 'emailAddress', 'contactEmail']) ||
+      readIdentityFieldFromSource(nestedAuthor, ['email', 'emailAddress', 'contactEmail']),
+    website:
+      readStringField(body, ['website', 'authorWebsite', 'commentAuthorWebsite']) ||
+      readIdentityFieldFromSource(nestedIdentity, ['website', 'websiteUrl', 'url']) ||
+      readIdentityFieldFromSource(nestedActor, ['website', 'websiteUrl', 'url']) ||
+      readIdentityFieldFromSource(nestedAuthor, ['website', 'websiteUrl', 'url']),
+  };
+
+  if (!identity.userId && !identity.name && !identity.email && !identity.website) {
+    return null;
+  }
+
+  return identity;
+}
+
+function readModerationMode(body: Record<string, unknown>): 'manual' | 'auto-approve' {
+  const value = readStringField(body, [
+    'commentModerationMode',
+    'commentModeration',
+    'moderationMode',
+    'mode',
+  ]);
+  return value === 'auto-approve' ? 'auto-approve' : 'manual';
+}
+
+function readAllowGuests(body: Record<string, unknown>): boolean | undefined {
+  return readBooleanField(
+    body,
+    ['commentAllowGuests', 'allowGuests', 'allowGuestComments', 'guestPostingEnabled', 'guestsEnabled'],
+  );
+}
+
+function readAllowReplies(body: Record<string, unknown>): boolean | undefined {
+  return readBooleanField(body, [
+    'commentAllowReplies',
+    'allowReplies',
+    'replyEnabled',
+    'repliesEnabled',
+    'allowRepliesEnabled',
+  ]);
+}
+
+function readRequireName(body: Record<string, unknown>): boolean | undefined {
+  return readBooleanField(body, ['commentRequireName', 'requireName', 'requireAuthorName', 'nameRequired']);
+}
+
+function readRequireEmail(body: Record<string, unknown>): boolean | undefined {
+  return readBooleanField(body, ['commentRequireEmail', 'requireEmail', 'requireAuthorEmail', 'emailRequired']);
+}
+
+function readUserId(body: Record<string, unknown>): string | undefined {
+  const direct = readStringField(body, ['userId', 'commentUserId', 'authorUserId', 'identityUserId', 'actorId', 'requesterId']);
+  if (direct) return direct;
+
+  return (
+    readStringFromSource(body.identity, ['id', 'userId', 'uid', 'sub', 'user_id', '_id']) ||
+    readStringFromSource(body.actor, ['id', 'userId', 'uid', 'sub', 'user_id', '_id']) ||
+    readStringFromSource(body.author, ['id', 'userId', 'uid', 'sub', 'user_id', '_id']) ||
+    readStringFromSource(body.identity, ['actorId', 'authorId', 'requesterId']) ||
+    readStringFromSource(body.actor, ['actorId', 'id', 'userId']) ||
+    readStringFromSource(body.author, ['authorId', 'id', 'userId'])
+  );
+}
+
 function parseStartedAt(raw: unknown): number | undefined {
   if (typeof raw === 'number' && Number.isFinite(raw)) {
     return raw;
@@ -181,26 +448,25 @@ export async function POST(request: NextRequest, { params }: RouteParams) {
       );
     }
 
-    const moderation = parseModerationMode(
-      (body as { commentModerationMode?: unknown }).commentModerationMode ??
-      (body as { moderationMode?: unknown }).moderationMode ??
-      body.mode,
-    );
-    const allowGuests = parseBoolean((body as { commentAllowGuests?: unknown }).commentAllowGuests);
-    const allowReplies = parseBoolean((body as { commentAllowReplies?: unknown }).commentAllowReplies);
-    const requireName = parseBoolean((body as { commentRequireName?: unknown }).commentRequireName);
-    const requireEmail = parseBoolean((body as { commentRequireEmail?: unknown }).commentRequireEmail);
-    const userId = parseTextInput(
-      (body as { userId?: unknown }).userId || (body as { commentUserId?: unknown }).commentUserId,
-    );
+    const payload = body || {};
+    const requestIdentity = readBackyCommentIdentityFromHeaders(request.headers);
+    const queryIdentity = readBackyCommentIdentityFromQuery(new URL(request.url).search);
+    const payloadIdentity = readCommentIdentityFromPayload(payload);
+    const resolvedIdentity = mergeBackyCommentIdentities(payloadIdentity, queryIdentity, requestIdentity);
+    const moderation = readModerationMode(payload);
+    const allowGuests = readAllowGuests(payload);
+    const allowReplies = readAllowReplies(payload);
+    const requireName = readRequireName(payload);
+    const requireEmail = readRequireEmail(payload);
+    const userId = readUserId(body) || resolvedIdentity?.userId;
     const finalAllowGuests = allowGuests !== false;
     const finalAllowReplies = allowReplies !== false;
     const finalRequireName = requireName !== false;
     const finalRequireEmail = requireEmail === true;
 
-    const authorName = parseTextInput(body.authorName);
-    const authorEmail = parseTextInput(body.authorEmail);
-    const authorWebsite = parseTextInput(body.authorWebsite);
+    const authorName = parseTextInput(body.authorName) || resolvedIdentity?.name || '';
+    const authorEmail = parseTextInput(body.authorEmail) || resolvedIdentity?.email || '';
+    const authorWebsite = parseTextInput(body.authorWebsite) || resolvedIdentity?.website || '';
     const parentId = typeof body.parentId === 'string' ? body.parentId : null;
     const commentThreadId = parseTextInput(
       (body as { commentThreadId?: unknown }).commentThreadId || (body as { threadId?: unknown }).threadId,
@@ -208,10 +474,11 @@ export async function POST(request: NextRequest, { params }: RouteParams) {
     const requestId = generateRequestId(parseTextInput(body.requestId) || undefined);
     const startedAt = parseStartedAt(body.startedAt);
     const honeypot = parseTextInput(body.honeypot);
+    const antiAbuse = readCommentAntiAbusePolicy(payload);
     const rateLimitBypass = parseBoolean(body.rateLimitBypass) === true;
     const ipHash = extractIpHash(request);
 
-    if (!finalAllowGuests && !userId) {
+    if (!finalAllowGuests && !hasSignedInBackyCommentIdentity(resolvedIdentity)) {
       return NextResponse.json(
         {
           error: 'Validation failed',
@@ -283,7 +550,9 @@ export async function POST(request: NextRequest, { params }: RouteParams) {
       targetId: postId,
       content,
       authorEmail,
+      userId,
       moderationMode: moderation,
+      antiAbuse,
       honeypot,
       ipHash,
       requestId,
@@ -316,6 +585,7 @@ export async function POST(request: NextRequest, { params }: RouteParams) {
       parentId,
       requestId,
       ipHash,
+      spamFlags: classification.spamFlags,
       status: classification.status,
     });
 
diff --git a/apps/public/src/app/api/sites/[siteId]/comments/[commentId]/report/route.ts b/apps/public/src/app/api/sites/[siteId]/comments/[commentId]/report/route.ts
index 71bd340..9d375c4 100644
--- a/apps/public/src/app/api/sites/[siteId]/comments/[commentId]/report/route.ts
+++ b/apps/public/src/app/api/sites/[siteId]/comments/[commentId]/report/route.ts
@@ -3,6 +3,7 @@ import {
   getCommentById,
   getSiteByIdOrSlug,
   getCommentReportReasons,
+  normalizeReportReason,
   reportComment,
 } from '@/lib/backyStore';
 
@@ -17,15 +18,25 @@ function parseTextInput(raw: unknown): string {
   return typeof raw === 'string' ? raw.trim() : '';
 }
 
+function readFieldAlias(raw: unknown, key: string): unknown {
+  if (!raw || typeof raw !== 'object' || Array.isArray(raw)) {
+    return undefined;
+  }
+
+  const obj = raw as Record<string, unknown>;
+  if (key in obj) {
+    return obj[key];
+  }
+
+  return undefined;
+}
+
 function parseReason(raw: unknown): string {
   const value = parseTextInput(raw);
   if (!value) {
     return '';
   }
-
-  const reasons = getCommentReportReasons();
-  const matched = reasons.find((reason) => reason === value);
-  return matched || '';
+  return normalizeReportReason(value) || '';
 }
 
 function parseBody(raw: unknown): {
@@ -37,9 +48,25 @@ function parseBody(raw: unknown): {
     return null;
   }
 
-  const reason = parseReason((raw as { reason?: unknown }).reason);
-  const actor = parseTextInput((raw as { actor?: unknown }).actor);
-  const requestId = parseTextInput((raw as { requestId?: unknown }).requestId);
+  const reason = parseReason(
+    readFieldAlias(raw, 'reason')
+    || readFieldAlias(raw, 'reasonCode')
+    || readFieldAlias(raw, 'reason_code')
+    || readFieldAlias(raw, 'reportReason')
+    || readFieldAlias(raw, 'code'),
+  );
+  const actor = parseTextInput(
+    readFieldAlias(raw, 'actor')
+    || readFieldAlias(raw, 'reportedBy')
+    || readFieldAlias(raw, 'requester')
+    || readFieldAlias(raw, 'user')
+    || readFieldAlias(raw, 'reviewedBy'),
+  );
+  const requestId = parseTextInput(
+    readFieldAlias(raw, 'requestId')
+    || readFieldAlias(raw, 'request')
+    || readFieldAlias(raw, 'request_id'),
+  );
 
   if (!reason) {
     return null;
@@ -104,7 +131,18 @@ export async function POST(request: NextRequest, { params }: RouteParams) {
       );
     }
 
-    return NextResponse.json({ comment: updated }, { status: 201 });
+    return NextResponse.json(
+        {
+          comment: updated,
+          report: {
+            reason: payload.reason,
+            actor: payload.actor || null,
+            requestId: payload.requestId || null,
+            reportCount: updated.reportCount,
+          },
+      },
+      { status: 201 },
+    );
   } catch (error) {
     console.error('API Error:', error);
     return NextResponse.json(
diff --git a/apps/public/src/app/api/sites/[siteId]/comments/[commentId]/route.ts b/apps/public/src/app/api/sites/[siteId]/comments/[commentId]/route.ts
index fcb41be..5cc91b2 100644
--- a/apps/public/src/app/api/sites/[siteId]/comments/[commentId]/route.ts
+++ b/apps/public/src/app/api/sites/[siteId]/comments/[commentId]/route.ts
@@ -4,6 +4,10 @@ import {
   getSiteByIdOrSlug,
   updateCommentStatus,
 } from '@/lib/backyStore';
+import {
+  hasBackyAdminPermission,
+  readBackyAdminIdentityFromHeaders,
+} from '@/lib/backyAuthBridge';
 import type { Comment } from '@backy-cms/core';
 
 interface RouteParams {
@@ -15,6 +19,18 @@ interface RouteParams {
 
 type CommentStatus = 'pending' | 'approved' | 'rejected' | 'spam' | 'blocked';
 
+function parseTextInput(raw: unknown): string {
+  if (typeof raw === 'string') {
+    return raw.trim();
+  }
+
+  if (typeof raw === 'number' && Number.isFinite(raw)) {
+    return String(raw);
+  }
+
+  return '';
+}
+
 function parseStatus(raw: unknown): CommentStatus | null {
   if (
     raw === 'pending' ||
@@ -29,6 +45,31 @@ function parseStatus(raw: unknown): CommentStatus | null {
   return null;
 }
 
+function readTextAlias(source: unknown, aliases: string[]): string {
+  if (!source || typeof source !== 'object' || Array.isArray(source)) {
+    return '';
+  }
+
+  const record = source as Record<string, unknown>;
+  for (const key of aliases) {
+    const value = parseTextInput(record[key]);
+    if (value) {
+      return value;
+    }
+  }
+
+  return '';
+}
+
+function parseBlockDurationMinutes(raw: unknown): number | undefined {
+  const parsed = Number.parseInt(parseTextInput(raw), 10);
+  if (!Number.isFinite(parsed) || parsed < 0) {
+    return undefined;
+  }
+
+  return parsed;
+}
+
 function parseBody(raw: unknown): {
   status: CommentStatus;
   reviewedBy?: string;
@@ -36,50 +77,47 @@ function parseBody(raw: unknown): {
   rejectionReason?: string;
   blockReason?: string;
   requestId?: string;
+  blockDurationMinutes?: number;
 } | null {
   if (!raw || typeof raw !== 'object') {
     return null;
   }
 
-  const status = parseStatus((raw as { status?: unknown }).status);
+  const status = parseStatus(
+    readTextAlias(raw, ['status', 'commentStatus', 'state']),
+  );
   if (!status) {
     return null;
   }
 
-  const reviewedBy = typeof (raw as { reviewedBy?: unknown }).reviewedBy === 'string'
-    ? (raw as { reviewedBy: string }).reviewedBy.trim()
-    : undefined;
-
-  const actor = typeof (raw as { actor?: unknown }).actor === 'string'
-    ? (raw as { actor: string }).actor.trim()
-    : undefined;
-
-  const rejectionReason = typeof (raw as { rejectionReason?: unknown }).rejectionReason === 'string'
-    ? ((raw as { rejectionReason: string }).rejectionReason.trim() || undefined)
-    : undefined;
-
-  const blockReason = typeof (raw as { blockReason?: unknown }).blockReason === 'string'
-    ? ((raw as { blockReason: string }).blockReason.trim() || undefined)
-    : undefined;
-
-  const requestId = typeof (raw as { requestId?: unknown }).requestId === 'string'
-    ? (raw as { requestId: string }).requestId.trim()
-    : undefined;
+  const reviewedBy = readTextAlias(raw, ['reviewedBy', 'reviewer', 'moderatedBy']);
+  const actor = readTextAlias(raw, ['actor', 'reportedBy', 'requester', 'moderator']);
+  const rejectionReason = readTextAlias(raw, ['rejectionReason', 'reasonCode', 'rejectReason']);
+  const blockReason = readTextAlias(raw, ['blockReason', 'block_reason', 'blockDescription', 'reason']);
+  const requestId = readTextAlias(raw, ['requestId', 'request', 'request_id', 'requestIdFilter']);
+  const blockDurationMinutes = parseBlockDurationMinutes(
+    readTextAlias(raw, ['blockDurationMinutes', 'blockDuration', 'durationMinutes', 'duration']),
+  );
 
   return {
     status,
-    reviewedBy,
-    actor,
-    rejectionReason,
-    blockReason,
+    reviewedBy: reviewedBy || undefined,
+    actor: actor || undefined,
+    rejectionReason: rejectionReason || undefined,
+    blockReason: blockReason || undefined,
     requestId: requestId || undefined,
+    blockDurationMinutes,
   };
 }
 
 export async function GET(_request: NextRequest, { params }: RouteParams) {
   try {
-    const { siteId, commentId } = await params;
+    const adminIdentity = readBackyAdminIdentityFromHeaders(_request.headers);
+    if (!hasBackyAdminPermission(adminIdentity, 'edit')) {
+      return NextResponse.json({ error: 'Unauthorized to read comment.' }, { status: 403 });
+    }
 
+    const { siteId, commentId } = await params;
     const site = getSiteByIdOrSlug(siteId);
     if (!site) {
       return NextResponse.json({ error: 'Site not found' }, { status: 404 });
@@ -104,6 +142,11 @@ export async function PATCH(request: NextRequest, { params }: RouteParams) {
   try {
     const { siteId, commentId } = await params;
 
+    const adminIdentity = readBackyAdminIdentityFromHeaders(request.headers);
+    if (!hasBackyAdminPermission(adminIdentity, 'edit')) {
+      return NextResponse.json({ error: 'Unauthorized to update comment.' }, { status: 403 });
+    }
+
     const site = getSiteByIdOrSlug(siteId);
     if (!site) {
       return NextResponse.json({ error: 'Site not found' }, { status: 404 });
@@ -128,6 +171,7 @@ export async function PATCH(request: NextRequest, { params }: RouteParams) {
       actor: payload.actor,
       rejectionReason: payload.rejectionReason || null,
       blockReason: payload.blockReason || null,
+      blockDurationMinutes: payload.blockDurationMinutes,
       requestId: payload.requestId,
     });
 
diff --git a/apps/public/src/app/api/sites/[siteId]/comments/route.ts b/apps/public/src/app/api/sites/[siteId]/comments/route.ts
index 5c316df..15a9b72 100644
--- a/apps/public/src/app/api/sites/[siteId]/comments/route.ts
+++ b/apps/public/src/app/api/sites/[siteId]/comments/route.ts
@@ -4,6 +4,10 @@ import {
   getSiteByIdOrSlug,
   listComments,
 } from '@/lib/backyStore';
+import {
+  hasBackyAdminPermission,
+  readBackyAdminIdentityFromHeaders,
+} from '@/lib/backyAuthBridge';
 import type { CommentTargetType } from '@backy-cms/core';
 
 interface RouteParams {
@@ -13,6 +17,38 @@ interface RouteParams {
 }
 
 type CommentStatusFilter = 'pending' | 'approved' | 'rejected' | 'spam' | 'blocked' | 'all';
+type CommentStatus = 'pending' | 'approved' | 'rejected' | 'spam' | 'blocked';
+type CommentBulkUpdateScope = {
+  status?: CommentStatusFilter;
+  targetType?: CommentTargetType | 'all';
+  targetId?: string;
+  requestId?: string;
+  q?: string;
+  parentOnly?: boolean;
+  parentId?: string | null;
+  commentThreadId?: string;
+};
+
+type CommentBulkPatchPayload = {
+  status: CommentStatus;
+  commentIds: string[];
+  reviewedBy?: string;
+  actor?: string;
+  rejectionReason?: string;
+  blockReason?: string;
+  blockDurationMinutes?: number;
+  requestId?: string;
+  all: boolean;
+  scope: CommentBulkUpdateScope;
+};
+
+const COMMENT_BULK_CHUNK = 250;
+const COMMENT_BULK_MODERATION_HARD_LIMIT = 2000;
+
+type CommentBulkMatchResult = {
+  ids: string[];
+  truncated: boolean;
+};
 
 function parseStatus(raw: string | null): CommentStatusFilter {
   if (
@@ -29,6 +65,41 @@ function parseStatus(raw: string | null): CommentStatusFilter {
   return 'all';
 }
 
+function parseRequiredStatus(raw: unknown): CommentStatus | null {
+  const value = parseTextInput(raw);
+  if (
+    value === 'pending'
+    || value === 'approved'
+    || value === 'rejected'
+    || value === 'spam'
+    || value === 'blocked'
+  ) {
+    return value;
+  }
+
+  return null;
+}
+
+function parseOptionalStatus(raw: unknown): CommentStatusFilter | undefined {
+  if (raw === null || raw === undefined) {
+    return undefined;
+  }
+
+  const normalized = parseTextInput(raw);
+  if (
+    normalized === 'pending'
+    || normalized === 'approved'
+    || normalized === 'rejected'
+    || normalized === 'spam'
+    || normalized === 'blocked'
+    || normalized === 'all'
+  ) {
+    return normalized;
+  }
+
+  return undefined;
+}
+
 function parseTargetType(raw: string | null): CommentTargetType | 'all' {
   if (raw === 'page' || raw === 'post' || raw === 'all') {
     return raw;
@@ -37,6 +108,19 @@ function parseTargetType(raw: string | null): CommentTargetType | 'all' {
   return 'all';
 }
 
+function parseOptionalTargetType(raw: unknown): CommentTargetType | undefined {
+  const value = parseTextInput(raw);
+  if (value === 'page' || value === 'post') {
+    return value;
+  }
+
+  if (value === 'all') {
+    return 'all';
+  }
+
+  return undefined;
+}
+
 function parseSort(raw: string | null) {
   return raw === 'oldest' ? 'oldest' : 'newest';
 }
@@ -45,11 +129,68 @@ function parseBoolean(raw: string | null): boolean {
   return raw === 'true' || raw === '1';
 }
 
+function parseBooleanInput(raw: unknown): boolean | undefined {
+  if (typeof raw === 'boolean') {
+    return raw;
+  }
+
+  if (typeof raw === 'number' && Number.isFinite(raw)) {
+    return raw !== 0;
+  }
+
+  if (typeof raw === 'string') {
+    const normalized = raw.trim().toLowerCase();
+    if (normalized === 'true' || normalized === '1' || normalized === 'on' || normalized === 'yes') {
+      return true;
+    }
+
+    if (normalized === 'false' || normalized === '0' || normalized === 'off' || normalized === 'no') {
+      return false;
+    }
+  }
+
+  return undefined;
+}
+
+function normalizeOptionalScopeText(raw: unknown): string {
+  const value = parseTextInput(raw);
+  return value.length > 0 ? value : '';
+}
+
+function parseTextInput(raw: unknown): string {
+  if (typeof raw === 'string') {
+    return raw.trim();
+  }
+
+  if (typeof raw === 'number' && Number.isFinite(raw)) {
+    return String(raw);
+  }
+
+  return '';
+}
+
+function parseNumber(raw: unknown): number | undefined {
+  const parsed = typeof raw === 'number' && Number.isFinite(raw)
+    ? Math.trunc(raw)
+    : Number.parseInt(parseTextInput(raw), 10);
+
+  if (!Number.isFinite(parsed)) {
+    return undefined;
+  }
+
+  return parsed;
+}
+
 function parseRequestId(raw: string | null): string | undefined {
   const value = raw ? raw.trim() : '';
   return value.length ? value : undefined;
 }
 
+function parseThreadId(raw: string | null): string | undefined {
+  const value = raw ? raw.trim() : '';
+  return value.length ? value : undefined;
+}
+
 function parseSearchQuery(raw: string | null): string | undefined {
   const value = raw ? raw.trim() : '';
   return value.length ? value : undefined;
@@ -72,16 +213,51 @@ function parseCommentIds(raw: unknown): string[] {
     .filter(Boolean);
 }
 
-function parsePatchPayload(raw: unknown) {
+function parseCommentScope(raw: unknown): CommentBulkUpdateScope {
+  if (!raw || typeof raw !== 'object' || Array.isArray(raw)) {
+    return {};
+  }
+
+  const source = raw as Record<string, unknown>;
+  const statusCandidate = normalizeOptionalScopeText(readFieldAlias(source, 'status'));
+  const targetTypeCandidate = normalizeOptionalScopeText(readFieldAlias(source, 'targetType'));
+  const targetIdCandidate = normalizeOptionalScopeText(readFieldAlias(source, 'targetId'));
+  const requestIdCandidate = normalizeOptionalScopeText(readFieldAlias(source, 'requestId'));
+  const qCandidate = normalizeOptionalScopeText(readFieldAlias(source, 'q'));
+  const parentOnlyCandidate = parseBooleanInput(readFieldAlias(source, 'parentOnly'));
+  const parentIdCandidate = normalizeOptionalScopeText(readFieldAlias(source, 'parentId'));
+  const commentThreadIdCandidate = normalizeOptionalScopeText(
+    readFieldAlias(source, 'commentThreadId') || readFieldAlias(source, 'threadId'),
+  );
+
+  const status = parseOptionalStatus(statusCandidate);
+  const targetType = parseOptionalTargetType(targetTypeCandidate);
+
+  return {
+    status: status || undefined,
+    targetType: targetType || undefined,
+    targetId: targetIdCandidate || undefined,
+    requestId: requestIdCandidate || undefined,
+    q: qCandidate || undefined,
+    parentOnly: parentOnlyCandidate,
+    parentId: parentIdCandidate ? parentIdCandidate : undefined,
+    commentThreadId: commentThreadIdCandidate || undefined,
+  };
+}
+
+function parsePatchPayload(raw: unknown): CommentBulkPatchPayload | null {
   if (!raw || typeof raw !== 'object') {
     return null;
   }
 
-  const status = parseStatus(typeof (raw as { status?: unknown }).status === 'string'
-    ? ((raw as { status?: string }).status)
-    : null);
+  const statusCandidate =
+    parseTextInput(readFieldAlias(raw, 'commentStatus')) || parseTextInput(readFieldAlias(raw, 'status'));
+  const status = parseRequiredStatus(statusCandidate);
+  if (status === null) {
+    return null;
+  }
 
-  const commentIds = parseCommentIds((raw as { commentIds?: unknown }).commentIds);
+  const commentIds = parseCommentIds(readCommentIdsField(raw));
   const reviewedBy = typeof (raw as { reviewedBy?: unknown }).reviewedBy === 'string'
     ? (raw as { reviewedBy: string }).reviewedBy.trim()
     : undefined;
@@ -94,21 +270,137 @@ function parsePatchPayload(raw: unknown) {
   const blockReason = typeof (raw as { blockReason?: unknown }).blockReason === 'string'
     ? (raw as { blockReason: string }).blockReason.trim()
     : undefined;
+  const blockDurationMinutes = parseNumber(readFieldAlias(raw, 'blockDurationMinutes'))
+    || parseNumber(readFieldAlias(raw, 'blockDuration'))
+    || parseNumber(readFieldAlias(raw, 'durationMinutes'))
+    || parseNumber(readFieldAlias(raw, 'duration'));
   const requestId = parseRequestId(typeof (raw as { requestId?: unknown }).requestId === 'string'
     ? (raw as { requestId: string }).requestId
     : null);
+  const all = parseBooleanInput(readFieldAlias(raw, 'all')) || parseBooleanInput(readFieldAlias(raw, 'matchAll')) || false;
+
+  const directScope = parseCommentScope(readFieldAlias(raw, 'scope'));
+  const scopeStatus = parseOptionalStatus(readFieldAlias(raw, 'scopeStatus'));
+  const scopeRequestId = parseRequestId(
+    normalizeOptionalScopeText(readFieldAlias(raw, 'scopeRequestId')),
+  );
+
+  const scope: CommentBulkUpdateScope = {
+    status: directScope.status || scopeStatus,
+    targetType: directScope.targetType,
+    targetId: directScope.targetId,
+    requestId: directScope.requestId || scopeRequestId,
+    q: directScope.q,
+    parentOnly: directScope.parentOnly,
+    parentId: directScope.parentId,
+    commentThreadId: directScope.commentThreadId,
+  };
 
   return {
     status,
-    commentIds,
+    commentIds: commentIds,
     reviewedBy: reviewedBy || undefined,
     actor: actor || undefined,
     rejectionReason: rejectionReason || undefined,
     blockReason: blockReason || undefined,
+    blockDurationMinutes:
+      blockDurationMinutes !== undefined && blockDurationMinutes >= 0 ? blockDurationMinutes : undefined,
     requestId,
+    all,
+    scope: {
+      ...scope,
+      requestId: scope.requestId || requestId,
+    },
   };
 }
 
+function hasScopeCriteria(scope: CommentBulkUpdateScope | null | undefined): boolean {
+  if (!scope) {
+    return false;
+  }
+
+  return [
+    scope.status,
+    scope.targetType,
+    scope.targetId,
+    scope.requestId,
+    scope.q,
+    scope.parentOnly,
+    scope.parentId,
+    scope.commentThreadId,
+  ].some((value) => value !== undefined);
+}
+
+function collectBulkCommentIds(siteId: string, scope: CommentBulkUpdateScope): CommentBulkMatchResult {
+  const matches = new Set<string>();
+  let offset = 0;
+
+  while (true) {
+    const shouldStop = matches.size >= COMMENT_BULK_MODERATION_HARD_LIMIT;
+    if (shouldStop) {
+      return { ids: Array.from(matches), truncated: true };
+    }
+
+    const pageSize = COMMENT_BULK_CHUNK;
+
+    const result = listComments(siteId, {
+      targetType: scope.targetType || 'all',
+      targetId: scope.targetId,
+      status: scope.status || 'all',
+      requestId: scope.requestId,
+      q: scope.q,
+      parentOnly: scope.parentOnly || false,
+      parentId: scope.parentId || null,
+      commentThreadId: scope.commentThreadId,
+      sort: 'newest',
+      limit: pageSize,
+      offset,
+    });
+
+    for (const comment of result.comments) {
+      matches.add(comment.id);
+    }
+
+  if (result.count <= offset + result.comments.length || result.comments.length === 0) {
+    break;
+  }
+
+  offset += result.comments.length;
+}
+
+  return { ids: Array.from(matches), truncated: false };
+}
+
+function readFieldAlias(raw: unknown, key: string): unknown {
+  if (!raw || typeof raw !== 'object' || Array.isArray(raw)) {
+    return undefined;
+  }
+
+  const obj = raw as Record<string, unknown>;
+  if (key in obj) {
+    return obj[key];
+  }
+
+  return undefined;
+}
+
+function readCommentIdsField(raw: unknown): unknown {
+  if (!raw || typeof raw !== 'object' || Array.isArray(raw)) {
+    return undefined;
+  }
+
+  const obj = raw as Record<string, unknown>;
+  if (obj.commentIds !== undefined) {
+    return obj.commentIds;
+  }
+
+  if (obj.ids !== undefined) {
+    return obj.ids;
+  }
+
+  return undefined;
+}
+
 export async function GET(request: NextRequest, { params }: RouteParams) {
   try {
     const { siteId } = await params;
@@ -119,14 +411,26 @@ export async function GET(request: NextRequest, { params }: RouteParams) {
     }
 
     const { searchParams } = new URL(request.url);
-    const status = parseStatus(searchParams.get('status'));
-    const targetType = parseTargetType(searchParams.get('targetType'));
+    const adminIdentity = readBackyAdminIdentityFromHeaders(request.headers);
+    const canAccessAllCommentStatuses = hasBackyAdminPermission(adminIdentity, 'edit');
+    const requestedStatus = parseStatus(searchParams.get('status') || searchParams.get('commentStatus'));
+    const status = canAccessAllCommentStatuses ? requestedStatus : 'approved';
+    const targetType = parseTargetType(
+      searchParams.get('targetType') || searchParams.get('commentTargetType'),
+    );
     const targetId = searchParams.get('targetId') || undefined;
-    const requestId = parseRequestId(searchParams.get('requestId'));
-    const q = parseSearchQuery(searchParams.get('q'));
+    const requestId = parseRequestId(
+      searchParams.get('requestId') || searchParams.get('request') || searchParams.get('requestIdFilter'),
+    );
+    const q = parseSearchQuery(
+      searchParams.get('q') || searchParams.get('search') || searchParams.get('query'),
+    );
     const parentId = searchParams.get('parentId');
     const parentOnly = parseBoolean(searchParams.get('parentOnly'));
     const sort = parseSort(searchParams.get('sort'));
+    const commentThreadId = parseThreadId(
+      searchParams.get('commentThreadId') || searchParams.get('threadId'),
+    );
     const limit = parseInt(searchParams.get('limit') || '20', 10);
     const offset = parseInt(searchParams.get('offset') || '0', 10);
 
@@ -138,6 +442,7 @@ export async function GET(request: NextRequest, { params }: RouteParams) {
       q,
       parentOnly,
       parentId: parentId || null,
+      commentThreadId,
       sort,
       limit: Number.isFinite(limit) ? limit : 20,
       offset: Number.isFinite(offset) ? offset : 0,
@@ -161,27 +466,95 @@ export async function GET(request: NextRequest, { params }: RouteParams) {
 export async function PATCH(request: NextRequest, { params }: RouteParams) {
   try {
     const { siteId } = await params;
+
+    const adminIdentity = readBackyAdminIdentityFromHeaders(request.headers);
+    if (!hasBackyAdminPermission(adminIdentity, 'edit')) {
+      return NextResponse.json(
+        { error: 'Unauthorized to bulk moderate comments.' },
+        { status: 403 },
+      );
+    }
+
     const site = getSiteByIdOrSlug(siteId);
     if (!site) {
       return NextResponse.json({ error: 'Site not found' }, { status: 404 });
     }
 
     const payload = parsePatchPayload(await request.json().catch(() => null));
-    if (!payload || !payload.status || payload.commentIds.length === 0) {
+    if (!payload || !payload.status) {
+      return NextResponse.json(
+        {
+          error:
+            'Invalid payload. status is required and either commentIds or an `all` scope is required.',
+        },
+        { status: 400 },
+      );
+    }
+
+    if (!payload.all && payload.commentIds.length === 0) {
+      return NextResponse.json(
+        {
+          error: 'Invalid payload. commentIds or all scope are required.',
+        },
+        { status: 400 },
+      );
+    }
+
+    if (payload.all && !hasScopeCriteria(payload.scope)) {
       return NextResponse.json(
-        { error: 'Invalid payload. status and commentIds are required.' },
+        {
+          error: 'Invalid payload. all=true requires scope filters or explicit status/target filters.',
+        },
         { status: 400 },
       );
     }
 
+    const commentMatch = payload.all
+      ? collectBulkCommentIds(site.id, payload.scope)
+      : { ids: payload.commentIds, truncated: false };
+
+    if (commentMatch.truncated) {
+      return NextResponse.json(
+        {
+          error:
+            `Unable to apply bulk action: scope contains ${COMMENT_BULK_MODERATION_HARD_LIMIT + 1}+ matches. `
+            + `Refine filters or split into smaller batches (max ${COMMENT_BULK_MODERATION_HARD_LIMIT}).`,
+          limit: COMMENT_BULK_MODERATION_HARD_LIMIT,
+        },
+        { status: 400 },
+      );
+    }
+
+    const resolvedCommentIds = Array.from(new Set(commentMatch.ids));
+
+    if (!payload.all && resolvedCommentIds.length > COMMENT_BULK_MODERATION_HARD_LIMIT) {
+      return NextResponse.json(
+        {
+          error:
+            `Unable to apply bulk action: too many explicit targets (${resolvedCommentIds.length}). `
+            + `Max supported per request is ${COMMENT_BULK_MODERATION_HARD_LIMIT}.`,
+          limit: COMMENT_BULK_MODERATION_HARD_LIMIT,
+        },
+        { status: 400 },
+      );
+    }
+
+    if (!resolvedCommentIds.length) {
+      return NextResponse.json(
+        { error: 'No comments match the requested moderation scope.' },
+        { status: 404 },
+      );
+    }
+
     const result = bulkUpdateCommentStatus({
       siteId: site.id,
-      commentIds: payload.commentIds,
+      commentIds: resolvedCommentIds,
       status: payload.status,
       reviewedBy: payload.reviewedBy,
       actor: payload.actor,
       rejectionReason: payload.rejectionReason,
       blockReason: payload.blockReason,
+      blockDurationMinutes: payload.blockDurationMinutes,
       requestId: payload.requestId,
     });
 
@@ -194,6 +567,8 @@ export async function PATCH(request: NextRequest, { params }: RouteParams) {
       updated: result.updated,
       updatedCount: result.updated.length,
       missingIds: result.missingIds,
+      targetCount: resolvedCommentIds.length,
+      appliedToScope: payload.all ? 'scope' : 'selection',
     });
   } catch (error) {
     console.error('API Error:', error);
diff --git a/apps/public/src/app/api/sites/[siteId]/events/route.ts b/apps/public/src/app/api/sites/[siteId]/events/route.ts
index 6b315a2..77596b7 100644
--- a/apps/public/src/app/api/sites/[siteId]/events/route.ts
+++ b/apps/public/src/app/api/sites/[siteId]/events/route.ts
@@ -1,5 +1,9 @@
 import { NextRequest, NextResponse } from 'next/server';
 import { getSiteByIdOrSlug, listAuditEvents } from '@/lib/backyStore';
+import {
+  hasBackyAdminPermission,
+  readBackyAdminIdentityFromHeaders,
+} from '@/lib/backyAuthBridge';
 
 interface RouteParams {
   params: Promise<{
@@ -40,6 +44,11 @@ function parseTextInput(raw: string | null): string {
 
 export async function GET(request: NextRequest, { params }: RouteParams) {
   try {
+    const adminIdentity = readBackyAdminIdentityFromHeaders(request.headers);
+    if (!hasBackyAdminPermission(adminIdentity, 'edit')) {
+      return NextResponse.json({ error: 'Unauthorized to read audit events.' }, { status: 403 });
+    }
+
     const { siteId } = await params;
     const site = getSiteByIdOrSlug(siteId);
     if (!site) {
diff --git a/apps/public/src/app/api/sites/[siteId]/forms/[formId]/contacts/[contactId]/route.ts b/apps/public/src/app/api/sites/[siteId]/forms/[formId]/contacts/[contactId]/route.ts
index 09dfd54..1a513a7 100644
--- a/apps/public/src/app/api/sites/[siteId]/forms/[formId]/contacts/[contactId]/route.ts
+++ b/apps/public/src/app/api/sites/[siteId]/forms/[formId]/contacts/[contactId]/route.ts
@@ -7,6 +7,10 @@ import {
   trackWebhookEvent,
   updateContactStatus,
 } from '@/lib/backyStore';
+import {
+  hasBackyAdminPermission,
+  readBackyAdminIdentityFromHeaders,
+} from '@/lib/backyAuthBridge';
 
 interface RouteParams {
   params: Promise<{
@@ -119,6 +123,11 @@ function parseBody(raw: unknown): { status: ContactStatus } | null {
 
 export async function PATCH(request: NextRequest, { params }: RouteParams) {
   try {
+    const adminIdentity = readBackyAdminIdentityFromHeaders(request.headers);
+    if (!hasBackyAdminPermission(adminIdentity, 'edit')) {
+      return NextResponse.json({ error: 'Unauthorized to update contact.' }, { status: 403 });
+    }
+
     const { siteId, formId, contactId } = await params;
     const site = getSiteByIdOrSlug(siteId);
     if (!site) {
diff --git a/apps/public/src/app/api/sites/[siteId]/forms/[formId]/contacts/route.ts b/apps/public/src/app/api/sites/[siteId]/forms/[formId]/contacts/route.ts
index 981eed2..a6c373b 100644
--- a/apps/public/src/app/api/sites/[siteId]/forms/[formId]/contacts/route.ts
+++ b/apps/public/src/app/api/sites/[siteId]/forms/[formId]/contacts/route.ts
@@ -4,6 +4,10 @@ import {
   getSiteByIdOrSlug,
   listFormContacts,
 } from '@/lib/backyStore';
+import {
+  hasBackyAdminPermission,
+  readBackyAdminIdentityFromHeaders,
+} from '@/lib/backyAuthBridge';
 
 interface RouteParams {
   params: Promise<{
@@ -14,6 +18,11 @@ interface RouteParams {
 
 export async function GET(request: NextRequest, { params }: RouteParams) {
   try {
+    const adminIdentity = readBackyAdminIdentityFromHeaders(request.headers);
+    if (!hasBackyAdminPermission(adminIdentity, 'edit')) {
+      return NextResponse.json({ error: 'Unauthorized to list contacts.' }, { status: 403 });
+    }
+
     const { siteId, formId } = await params;
     const site = getSiteByIdOrSlug(siteId);
     if (!site) {
diff --git a/apps/public/src/app/api/sites/[siteId]/forms/[formId]/submissions/[submissionId]/route.ts b/apps/public/src/app/api/sites/[siteId]/forms/[formId]/submissions/[submissionId]/route.ts
index 9939f29..49c2f60 100644
--- a/apps/public/src/app/api/sites/[siteId]/forms/[formId]/submissions/[submissionId]/route.ts
+++ b/apps/public/src/app/api/sites/[siteId]/forms/[formId]/submissions/[submissionId]/route.ts
@@ -7,6 +7,10 @@ import {
   buildContactShareFromSubmission,
   trackWebhookEvent,
 } from '@/lib/backyStore';
+import {
+  hasBackyAdminPermission,
+  readBackyAdminIdentityFromHeaders,
+} from '@/lib/backyAuthBridge';
 import type { FormSubmission } from '@backy-cms/core';
 
 interface RouteParams {
@@ -162,6 +166,11 @@ async function notifyContactWebhook(params: {
 
 export async function GET(_request: NextRequest, { params }: RouteParams) {
   try {
+    const adminIdentity = readBackyAdminIdentityFromHeaders(_request.headers);
+    if (!hasBackyAdminPermission(adminIdentity, 'edit')) {
+      return NextResponse.json({ error: 'Unauthorized to view submission.' }, { status: 403 });
+    }
+
     const { siteId, formId, submissionId } = await params;
     const site = getSiteByIdOrSlug(siteId);
     if (!site) {
@@ -187,6 +196,11 @@ export async function GET(_request: NextRequest, { params }: RouteParams) {
 
 export async function PATCH(request: NextRequest, { params }: RouteParams) {
   try {
+    const adminIdentity = readBackyAdminIdentityFromHeaders(request.headers);
+    if (!hasBackyAdminPermission(adminIdentity, 'edit')) {
+      return NextResponse.json({ error: 'Unauthorized to update submission.' }, { status: 403 });
+    }
+
     const { siteId, formId, submissionId } = await params;
     const site = getSiteByIdOrSlug(siteId);
     if (!site) {
diff --git a/apps/public/src/app/api/sites/[siteId]/forms/[formId]/submissions/route.ts b/apps/public/src/app/api/sites/[siteId]/forms/[formId]/submissions/route.ts
index cb519ca..3164416 100644
--- a/apps/public/src/app/api/sites/[siteId]/forms/[formId]/submissions/route.ts
+++ b/apps/public/src/app/api/sites/[siteId]/forms/[formId]/submissions/route.ts
@@ -8,6 +8,10 @@ import {
   trackWebhookEvent,
   validateAndClassifyFormSubmission,
 } from '@/lib/backyStore';
+import {
+  hasBackyAdminPermission,
+  readBackyAdminIdentityFromHeaders,
+} from '@/lib/backyAuthBridge';
 
 interface RouteParams {
   params: Promise<{
@@ -25,6 +29,245 @@ interface ContactShareOverridePayload {
   dedupeByEmail?: boolean;
 }
 
+function parseBoolean(raw: unknown): boolean | undefined {
+  if (typeof raw === 'boolean') {
+    return raw;
+  }
+
+  if (typeof raw === 'number' && Number.isFinite(raw)) {
+    return raw !== 0;
+  }
+
+  if (typeof raw === 'string') {
+    const normalized = raw.trim().toLowerCase();
+    if (normalized === 'true' || normalized === '1' || normalized === 'on' || normalized === 'yes') {
+      return true;
+    }
+
+    if (normalized === 'false' || normalized === '0' || normalized === 'off' || normalized === 'no') {
+      return false;
+    }
+  }
+
+  return undefined;
+}
+
+function toRecord(value: unknown): Record<string, unknown> | null {
+  if (!value || typeof value !== 'object' || Array.isArray(value)) {
+    return null;
+  }
+
+  return value as Record<string, unknown>;
+}
+
+function tryParseJSON(raw: unknown): unknown | undefined {
+  if (typeof raw !== 'string') {
+    return undefined;
+  }
+
+  try {
+    return JSON.parse(raw);
+  } catch {
+    return undefined;
+  }
+}
+
+function parseTextLike(raw: unknown): string {
+  if (typeof raw === 'string') {
+    return raw.trim();
+  }
+
+  if (typeof raw === 'number' && Number.isFinite(raw)) {
+    return String(raw);
+  }
+
+  return '';
+}
+
+function readValuesFromRecord(raw: Record<string, unknown> | null): Record<string, unknown> {
+  if (!raw) {
+    return {};
+  }
+
+  const next: Record<string, unknown> = {};
+  Object.entries(raw).forEach(([key, value]) => {
+    const parsed = tryParseJSON(value);
+    if (parsed !== undefined && parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
+      next[key] = parsed;
+      return;
+    }
+
+    next[key] = value;
+  });
+
+  return next;
+}
+
+function flattenFormData(formData: FormData): Record<string, unknown> {
+  const result: Record<string, unknown> = {};
+
+  const keys = new Set(formData.keys());
+  keys.forEach((rawKey) => {
+    const key = typeof rawKey === 'string' ? rawKey : String(rawKey);
+    const all = formData.getAll(rawKey).map((entry) => {
+      if (typeof entry === 'string') {
+        return entry;
+      }
+      return '[file]';
+    });
+
+    if (all.length === 1) {
+      const next = all[0];
+      const parsed = tryParseJSON(next);
+      result[key] = parsed ?? next;
+      return;
+    }
+
+    result[key] = all;
+  });
+
+  return result;
+}
+
+async function parseIncomingPayload(request: NextRequest): Promise<Record<string, unknown> | null> {
+  const contentType = request.headers.get('content-type') || '';
+  const isFormPayload = contentType.includes('application/x-www-form-urlencoded')
+    || contentType.includes('multipart/form-data');
+
+  if (isFormPayload) {
+    const formData = await request.formData().catch(() => null);
+    if (!formData) {
+      return null;
+    }
+
+    return flattenFormData(formData);
+  }
+
+  return (await request.json().catch(() => null)) as Record<string, unknown> | null;
+}
+
+function readString(raw: unknown, keys: string[], fallback = ''): string {
+  for (const key of keys) {
+    const value = toRecord(raw)?.[key];
+    const parsed = parseTextLike(value);
+    if (parsed.length > 0) {
+      return parsed;
+    }
+  }
+
+  return fallback;
+}
+
+function readBoolean(raw: unknown, keys: string[]): boolean | undefined {
+  for (const key of keys) {
+    const parsed = parseBoolean(toRecord(raw)?.[key]);
+    if (parsed !== undefined) {
+      return parsed;
+    }
+  }
+
+  return undefined;
+}
+
+function readFormValues(raw: Record<string, unknown>): Record<string, unknown> {
+  const primary = toRecord((raw as { values?: unknown }).values);
+  const candidateAliases = [
+    primary,
+    toRecord((raw as { data?: unknown }).data),
+    toRecord((raw as { fields?: unknown }).fields),
+    toRecord((raw as { payload?: unknown }).payload),
+    toRecord((raw as { form?: unknown }).form),
+    toRecord((raw as { formData?: unknown }).formData),
+    toRecord((raw as { submission?: unknown }).submission),
+  ];
+
+  for (const candidate of candidateAliases) {
+    if (candidate && Object.keys(candidate).length > 0) {
+      return candidate;
+    }
+  }
+
+  const values: Record<string, unknown> = {};
+  const reserved = new Set([
+    'values',
+    'data',
+    'fields',
+    'payload',
+    'form',
+    'formData',
+    'submission',
+    'contactShareOverride',
+    'contactShare',
+    'contact_share',
+    'contactShareConfig',
+    'honeypot',
+    'pageId',
+    'page_id',
+    'postId',
+    'post_id',
+    'requestId',
+    'request_id',
+    'rid',
+    'rateLimitBypass',
+    'rate_limit_bypass',
+    'bypassRateLimit',
+    'skipRateLimit',
+    'startedAt',
+    'started_at',
+    'timestamp',
+    'x-backy-user-id',
+    'x-backy-user-name',
+    'x-backy-user-email',
+    'x-backy-user-website',
+  ]);
+
+  Object.entries(raw).forEach(([key, value]) => {
+    if (!reserved.has(key)) {
+      values[key] = value;
+    }
+  });
+
+  return values;
+}
+
+function parseContactShareOverride(raw: Record<string, unknown>): ContactShareOverridePayload | null {
+  const source = toRecord(
+    (raw as {
+      contactShareOverride?: unknown;
+      contactShare?: unknown;
+      contact_share?: unknown;
+      contactShareConfig?: unknown;
+    }),
+  );
+  if (!source) {
+    return null;
+  }
+
+  const contactShare = toRecord(source.contactShareOverride)
+    || toRecord(source.contactShare)
+    || toRecord(source.contact_share)
+    || toRecord(source.contactShareConfig);
+
+  if (!contactShare) {
+    return null;
+  }
+
+  const payload: ContactShareOverridePayload = {
+    enabled: typeof contactShare.enabled === 'boolean' ? (contactShare.enabled as boolean) : undefined,
+    nameField: parseTextLike(contactShare.nameField),
+    emailField: parseTextLike(contactShare.emailField),
+    phoneField: parseTextLike(contactShare.phoneField),
+    notesField: parseTextLike(contactShare.notesField),
+    dedupeByEmail: parseBoolean(contactShare.dedupeByEmail),
+  };
+
+  if (Object.values(payload).filter((value) => value !== undefined).length === 0) {
+    return null;
+  }
+
+  return payload;
+}
+
 const SUBMISSION_STATUSES = ['pending', 'approved', 'rejected', 'spam'] as const;
 
 type SubmissionStatus = (typeof SUBMISSION_STATUSES)[number];
@@ -66,58 +309,20 @@ function parseRequestBody(raw: unknown) {
     return null;
   }
 
-  const values = typeof (raw as { values?: unknown }).values === 'object'
-    && (raw as { values?: unknown }).values !== null
-      ? ((raw as { values?: Record<string, unknown> }).values as Record<string, unknown>)
-      : {};
-
-  const contactShare = typeof (raw as { contactShareOverride?: unknown }).contactShareOverride === 'object'
-    ? ((raw as { contactShareOverride?: Record<string, unknown> }).contactShareOverride || null)
-    : null;
-
-  const contactShareOverride: ContactShareOverridePayload | null = contactShare
-    ? {
-      enabled: typeof (contactShare as { enabled?: unknown }).enabled === 'boolean'
-        ? (contactShare as { enabled: boolean }).enabled
-        : undefined,
-      nameField: typeof (contactShare as { nameField?: unknown }).nameField === 'string'
-        ? (contactShare as { nameField: string }).nameField
-        : undefined,
-      emailField: typeof (contactShare as { emailField?: unknown }).emailField === 'string'
-        ? (contactShare as { emailField: string }).emailField
-        : undefined,
-      phoneField: typeof (contactShare as { phoneField?: unknown }).phoneField === 'string'
-        ? (contactShare as { phoneField: string }).phoneField
-        : undefined,
-      notesField: typeof (contactShare as { notesField?: unknown }).notesField === 'string'
-        ? (contactShare as { notesField: string }).notesField
-        : undefined,
-      dedupeByEmail: typeof (contactShare as { dedupeByEmail?: unknown }).dedupeByEmail === 'boolean'
-        ? (contactShare as { dedupeByEmail: boolean }).dedupeByEmail
-        : undefined,
-    }
-    : null;
+  const record = raw as Record<string, unknown>;
+
+  const values = readFormValues(record);
+  const contactShareOverride = parseContactShareOverride(record);
 
   return {
     values,
-    honeypot: typeof (raw as { honeypot?: unknown }).honeypot === 'string'
-      ? (raw as { honeypot: string }).honeypot
-      : '',
-    pageId: typeof (raw as { pageId?: unknown }).pageId === 'string'
-      ? (raw as { pageId: string }).pageId
-      : null,
-    postId: typeof (raw as { postId?: unknown }).postId === 'string'
-      ? (raw as { postId: string }).postId
-      : null,
-    requestId: typeof (raw as { requestId?: unknown }).requestId === 'string'
-      ? (raw as { requestId: string }).requestId
-      : undefined,
-    rateLimitBypass: (raw as { rateLimitBypass?: unknown }).rateLimitBypass === true,
-    startedAt: typeof (raw as { startedAt?: unknown }).startedAt === 'number'
-      ? (raw as { startedAt: number }).startedAt
-      : typeof (raw as { startedAt?: unknown }).startedAt === 'string'
-        ? (raw as { startedAt: string }).startedAt
-        : undefined,
+    honeypot: readString(record, ['honeypot', 'hp', 'honeypotField'], ''),
+    pageId: readString(record, ['pageId', 'page_id', 'page', 'pageIdOverride'], null),
+    postId: readString(record, ['postId', 'post_id', 'post', 'postIdOverride'], null),
+    requestId: readString(record, ['requestId', 'request_id', 'rid'], '' ) || undefined,
+    rateLimitBypass: readBoolean(record, ['rateLimitBypass', 'bypassRateLimit', 'skipRateLimit', 'rate_limit_bypass'])
+      || false,
+    startedAt: readString(record, ['startedAt', 'started_at', 'timestamp']) || undefined,
     contactShareOverride: contactShareOverride && Object.keys(contactShareOverride).length > 0
       ? contactShareOverride
       : undefined,
@@ -224,6 +429,11 @@ async function notifyContactWebhook(params: {
 
 export async function GET(request: NextRequest, { params }: RouteParams) {
   try {
+    const adminIdentity = readBackyAdminIdentityFromHeaders(request.headers);
+    if (!hasBackyAdminPermission(adminIdentity, 'edit')) {
+      return NextResponse.json({ error: 'Unauthorized to list form submissions.' }, { status: 403 });
+    }
+
     const { siteId, formId } = await params;
     const site = getSiteByIdOrSlug(siteId);
     if (!site) {
@@ -275,7 +485,7 @@ export async function POST(request: NextRequest, { params }: RouteParams) {
       return NextResponse.json({ error: 'Form is not active' }, { status: 400 });
     }
 
-    const parsed = parseRequestBody(await request.json().catch(() => null));
+    const parsed = parseRequestBody(await parseIncomingPayload(request));
     if (!parsed) {
       return NextResponse.json({ error: 'Invalid payload' }, { status: 400 });
     }
diff --git a/apps/public/src/app/api/sites/[siteId]/pages/[pageId]/comments/route.ts b/apps/public/src/app/api/sites/[siteId]/pages/[pageId]/comments/route.ts
index c2096e9..b1f5347 100644
--- a/apps/public/src/app/api/sites/[siteId]/pages/[pageId]/comments/route.ts
+++ b/apps/public/src/app/api/sites/[siteId]/pages/[pageId]/comments/route.ts
@@ -5,8 +5,16 @@ import {
   getCommentsByTarget,
   getPageSummary,
   getSiteByIdOrSlug,
+  getSiteCommentAntiAbusePolicy,
   validateAndClassifyComment,
 } from '@/lib/backyStore';
+import {
+  type BackyCommentIdentity,
+  mergeBackyCommentIdentities,
+  hasSignedInBackyCommentIdentity,
+  readBackyCommentIdentityFromQuery,
+  readBackyCommentIdentityFromHeaders,
+} from '@/lib/backyAuthBridge';
 
 interface RouteParams {
   params: Promise<{
@@ -39,7 +47,23 @@ function parseModerationMode(raw: unknown): 'manual' | 'auto-approve' {
 }
 
 function parseTextInput(raw: unknown) {
-  return typeof raw === 'string' ? raw.trim() : '';
+  if (typeof raw === 'string') {
+    return raw.trim();
+  }
+
+  if (typeof raw === 'number' && Number.isFinite(raw)) {
+    return String(raw);
+  }
+
+  return '';
+}
+
+function toRecord(value: unknown): Record<string, unknown> | null {
+  if (!value || typeof value !== 'object' || Array.isArray(value)) {
+    return null;
+  }
+
+  return value as Record<string, unknown>;
 }
 
 function parseBoolean(raw: unknown): boolean | undefined {
@@ -65,6 +89,266 @@ function parseBoolean(raw: unknown): boolean | undefined {
   return undefined;
 }
 
+function parseNumber(raw: unknown): number | undefined {
+  if (typeof raw === 'number' && Number.isFinite(raw)) {
+    return Math.trunc(raw);
+  }
+
+  if (typeof raw === 'string') {
+    const parsed = Number.parseFloat(raw.trim());
+    return Number.isFinite(parsed) ? Math.trunc(parsed) : undefined;
+  }
+
+  return undefined;
+}
+
+function readNumberField(source: Record<string, unknown>, keys: string[]): number | undefined {
+  for (const key of keys) {
+    if (!(key in source)) {
+      continue;
+    }
+
+    const value = parseNumber(source[key]);
+    if (value !== undefined) {
+      return value;
+    }
+  }
+
+  return undefined;
+}
+
+function readCommentAntiAbusePolicy(body: Record<string, unknown>) {
+  const nested = toRecord(body.commentAntiAbuse) || toRecord(body.antiAbuse);
+  const sources: Array<Record<string, unknown>> = [];
+
+  if (nested) {
+    sources.push(nested);
+  }
+
+  sources.push(body);
+
+  const policy = {
+    rateLimit: readNumberField(
+      { ...Object.fromEntries(sources.flatMap(Object.entries)), ...sources[0] },
+      ['rateLimit', 'commentRateLimit', 'commentAntiAbuseRateLimit', 'antiAbuseRateLimit'],
+    ),
+    rateWindowMs: readNumberField(
+      { ...Object.fromEntries(sources.flatMap(Object.entries)), ...sources[0] },
+      ['rateWindowMs', 'commentRateWindowMs', 'commentAntiAbuseRateWindowMs', 'antiAbuseRateWindowMs'],
+    ),
+    signatureWindowMs: readNumberField(
+      { ...Object.fromEntries(sources.flatMap(Object.entries)), ...sources[0] },
+      ['signatureWindowMs', 'commentSignatureWindowMs', 'commentAntiAbuseSignatureWindowMs', 'antiAbuseSignatureWindowMs'],
+    ),
+    minFillMs: readNumberField(
+      { ...Object.fromEntries(sources.flatMap(Object.entries)), ...sources[0] },
+      ['minFillMs', 'commentAntiAbuseMinFillMs', 'antiAbuseMinFillMs'],
+    ),
+    autoBlockSpamCount: readNumberField(
+      { ...Object.fromEntries(sources.flatMap(Object.entries)), ...sources[0] },
+      ['autoBlockSpamCount', 'commentAntiAbuseAutoBlockSpamCount', 'antiAbuseAutoBlockSpamCount'],
+    ),
+    autoBlockDurationMinutes: readNumberField(
+      { ...Object.fromEntries(sources.flatMap(Object.entries)), ...sources[0] },
+      [
+        'autoBlockDurationMinutes',
+        'commentAntiAbuseAutoBlockDurationMinutes',
+        'antiAbuseAutoBlockDurationMinutes',
+      ],
+    ),
+    requestRateLimit: readNumberField(
+      { ...Object.fromEntries(sources.flatMap(Object.entries)), ...sources[0] },
+      ['requestRateLimit', 'commentRequestRateLimit', 'commentAntiAbuseRequestRateLimit', 'antiAbuseRequestRateLimit'],
+    ),
+    requestRateWindowMs: readNumberField(
+      { ...Object.fromEntries(sources.flatMap(Object.entries)), ...sources[0] },
+      ['requestRateWindowMs', 'commentRequestRateWindowMs', 'commentAntiAbuseRequestRateWindowMs', 'antiAbuseRequestRateWindowMs'],
+    ),
+    autoBlockUserThreshold: readNumberField(
+      { ...Object.fromEntries(sources.flatMap(Object.entries)), ...sources[0] },
+      ['autoBlockUserThreshold', 'commentAutoBlockUserThreshold', 'commentAntiAbuseAutoBlockUserThreshold', 'antiAbuseAutoBlockUserThreshold'],
+    ),
+    autoBlockRequestThreshold: readNumberField(
+      { ...Object.fromEntries(sources.flatMap(Object.entries)), ...sources[0] },
+      ['autoBlockRequestThreshold', 'commentAutoBlockRequestThreshold', 'commentAntiAbuseAutoBlockRequestThreshold', 'antiAbuseAutoBlockRequestThreshold'],
+    ),
+  };
+
+  const hasValues = Object.values(policy).some((value) => value !== undefined);
+  return hasValues ? policy : undefined;
+}
+
+function getMergedCommentAntiAbusePolicy(siteId: string, body: Record<string, unknown>) {
+  const sitePolicy = getSiteCommentAntiAbusePolicy(siteId);
+  const requestPolicy = readCommentAntiAbusePolicy(body);
+
+  if (!sitePolicy && !requestPolicy) {
+    return undefined;
+  }
+
+  return {
+    ...(sitePolicy || {}),
+    ...(requestPolicy || {}),
+  };
+}
+
+function readBooleanField(body: Record<string, unknown>, keys: string[]): boolean | undefined {
+  for (const key of keys) {
+    if (!(key in body)) {
+      continue;
+    }
+    const parsed = parseBoolean((body as Record<string, unknown>)[key]);
+    if (parsed !== undefined) {
+      return parsed;
+    }
+  }
+  return undefined;
+}
+
+function readStringField(body: Record<string, unknown>, keys: string[]): string | undefined {
+  for (const key of keys) {
+    if (!(key in body)) {
+      continue;
+    }
+
+    const value = body[key];
+    if (typeof value === 'string' && value.trim().length > 0) {
+      return value.trim();
+    }
+  }
+  return undefined;
+}
+
+function readStringFromSource(value: unknown, keys: string[]): string | undefined {
+  const source = toRecord(value);
+  if (!source) {
+    return undefined;
+  }
+
+  for (const key of keys) {
+    const next = parseTextInput(source[key]);
+    if (next) {
+      return next;
+    }
+  }
+
+  return undefined;
+}
+
+function readIdentityFieldFromSource(value: unknown, keys: string[]): string | undefined {
+  const source = toRecord(value);
+  if (!source) {
+    return undefined;
+  }
+
+  for (const key of keys) {
+    const next = parseTextInput(source[key]);
+    if (next) {
+      return next;
+    }
+  }
+
+  return undefined;
+}
+
+function readCommentIdentityFromPayload(body: Record<string, unknown>): BackyCommentIdentity | null {
+  const nestedIdentity = toRecord(body.identity);
+  const nestedActor = toRecord(body.actor);
+  const nestedAuthor = toRecord(body.author);
+
+  const identity: BackyCommentIdentity = {
+    userId:
+      readStringField(body, ['userId', 'commentUserId', 'authorUserId', 'identityUserId', 'actorId', 'requesterId']) ||
+      readIdentityFieldFromSource(nestedIdentity, ['userId', 'id', 'uid', 'sub', 'user_id', '_id']) ||
+      readIdentityFieldFromSource(nestedActor, ['userId', 'id', 'uid', 'sub', 'user_id', '_id']) ||
+      readIdentityFieldFromSource(nestedAuthor, ['userId', 'id', 'uid', 'sub', 'user_id', '_id']),
+    name:
+      readStringField(body, ['name', 'authorName', 'commentAuthorName', 'fullName', 'userName']) ||
+      readIdentityFieldFromSource(nestedIdentity, ['name', 'fullName', 'userName']) ||
+      readIdentityFieldFromSource(nestedActor, ['name', 'fullName', 'userName']) ||
+      readIdentityFieldFromSource(nestedAuthor, ['name', 'fullName', 'userName']),
+    email:
+      readStringField(body, ['email', 'authorEmail', 'commentAuthorEmail']) ||
+      readIdentityFieldFromSource(nestedIdentity, ['email', 'emailAddress', 'contactEmail']) ||
+      readIdentityFieldFromSource(nestedActor, ['email', 'emailAddress', 'contactEmail']) ||
+      readIdentityFieldFromSource(nestedAuthor, ['email', 'emailAddress', 'contactEmail']),
+    website:
+      readStringField(body, ['website', 'authorWebsite', 'commentAuthorWebsite']) ||
+      readIdentityFieldFromSource(nestedIdentity, ['website', 'websiteUrl', 'url']) ||
+      readIdentityFieldFromSource(nestedActor, ['website', 'websiteUrl', 'url']) ||
+      readIdentityFieldFromSource(nestedAuthor, ['website', 'websiteUrl', 'url']),
+  };
+
+  if (!identity.userId && !identity.name && !identity.email && !identity.website) {
+    return null;
+  }
+
+  return identity;
+}
+
+function readModerationMode(raw: Record<string, unknown>): 'manual' | 'auto-approve' {
+  const mode = readStringField(raw, [
+    'commentModerationMode',
+    'commentModeration',
+    'moderationMode',
+    'mode',
+  ]);
+  return mode === 'auto-approve' ? 'auto-approve' : 'manual';
+}
+
+function readAllowGuests(body: Record<string, unknown>): boolean | undefined {
+  return readBooleanField(
+    body,
+    ['commentAllowGuests', 'allowGuests', 'allowGuestComments', 'guestPostingEnabled', 'guestsEnabled'],
+  );
+}
+
+function readAllowReplies(body: Record<string, unknown>): boolean | undefined {
+  return readBooleanField(body, [
+    'commentAllowReplies',
+    'allowReplies',
+    'replyEnabled',
+    'repliesEnabled',
+    'allowRepliesEnabled',
+  ]);
+}
+
+function readRequireName(body: Record<string, unknown>): boolean | undefined {
+  return readBooleanField(body, [
+    'commentRequireName',
+    'requireName',
+    'requireAuthorName',
+    'nameRequired',
+  ]);
+}
+
+function readRequireEmail(body: Record<string, unknown>): boolean | undefined {
+  return readBooleanField(body, [
+    'commentRequireEmail',
+    'requireEmail',
+    'requireAuthorEmail',
+    'emailRequired',
+  ]);
+}
+
+function readUserId(body: Record<string, unknown>): string | undefined {
+  const direct = readStringField(body, ['userId', 'commentUserId', 'authorUserId', 'identityUserId', 'actorId', 'requesterId']);
+  if (direct) return direct;
+
+  const nestedIdentity = toRecord(body.identity);
+  const nestedActor = toRecord(body.actor);
+  const nestedAuthor = toRecord(body.author);
+
+  return (
+    readStringFromSource(body.identity, ['id', 'userId', 'uid', 'sub', 'user_id', '_id']) ||
+    readStringFromSource(body.actor, ['id', 'userId', 'uid', 'sub', 'user_id', '_id']) ||
+    readStringFromSource(body.author, ['id', 'userId', 'uid', 'sub', 'user_id', '_id']) ||
+    readStringFromSource(nestedIdentity, ['actorId', 'authorId', 'requesterId']) ||
+    readStringFromSource(nestedActor, ['actorId', 'id', 'userId']) ||
+    readStringFromSource(nestedAuthor, ['authorId', 'id', 'userId'])
+  );
+}
+
 function parseStartedAt(raw: unknown): number | undefined {
   if (typeof raw === 'number' && Number.isFinite(raw)) {
     return raw;
@@ -182,26 +466,25 @@ export async function POST(request: NextRequest, { params }: RouteParams) {
       );
     }
 
-    const moderation = parseModerationMode(
-      (body as { commentModerationMode?: unknown }).commentModerationMode ??
-      (body as { moderationMode?: unknown }).moderationMode ??
-      body.mode,
-    );
-    const allowGuests = parseBoolean((body as { commentAllowGuests?: unknown }).commentAllowGuests);
-    const allowReplies = parseBoolean((body as { commentAllowReplies?: unknown }).commentAllowReplies);
-    const requireName = parseBoolean((body as { commentRequireName?: unknown }).commentRequireName);
-    const requireEmail = parseBoolean((body as { commentRequireEmail?: unknown }).commentRequireEmail);
-    const userId = parseTextInput(
-      (body as { userId?: unknown }).userId || (body as { commentUserId?: unknown }).commentUserId,
-    );
+    const payload = body || {};
+    const requestIdentity = readBackyCommentIdentityFromHeaders(request.headers);
+    const queryIdentity = readBackyCommentIdentityFromQuery(new URL(request.url).search);
+    const payloadIdentity = readCommentIdentityFromPayload(payload);
+    const resolvedIdentity = mergeBackyCommentIdentities(payloadIdentity, queryIdentity, requestIdentity);
+    const moderation = readModerationMode(payload);
+    const allowGuests = readAllowGuests(payload);
+    const allowReplies = readAllowReplies(payload);
+    const requireName = readRequireName(payload);
+    const requireEmail = readRequireEmail(payload);
+    const userId = readUserId(body) || resolvedIdentity?.userId;
     const finalAllowGuests = allowGuests !== false;
     const finalAllowReplies = allowReplies !== false;
     const finalRequireName = requireName !== false;
     const finalRequireEmail = requireEmail === true;
 
-    const authorName = parseTextInput(body.authorName);
-    const authorEmail = parseTextInput(body.authorEmail);
-    const authorWebsite = parseTextInput(body.authorWebsite);
+    const authorName = parseTextInput(body.authorName) || resolvedIdentity?.name || '';
+    const authorEmail = parseTextInput(body.authorEmail) || resolvedIdentity?.email || '';
+    const authorWebsite = parseTextInput(body.authorWebsite) || resolvedIdentity?.website || '';
     const parentId = typeof body.parentId === 'string' ? body.parentId : null;
     const commentThreadId = parseTextInput(
       (body as { commentThreadId?: unknown }).commentThreadId || (body as { threadId?: unknown }).threadId,
@@ -209,10 +492,11 @@ export async function POST(request: NextRequest, { params }: RouteParams) {
     const requestId = generateRequestId(parseTextInput(body.requestId) || undefined);
     const startedAt = parseStartedAt(body.startedAt);
     const honeypot = parseTextInput(body.honeypot);
+    const antiAbuse = getMergedCommentAntiAbusePolicy(site.id, payload);
     const rateLimitBypass = parseBoolean(body.rateLimitBypass) === true;
     const ipHash = extractIpHash(request);
 
-    if (!finalAllowGuests && !userId) {
+    if (!finalAllowGuests && !hasSignedInBackyCommentIdentity(resolvedIdentity)) {
       return NextResponse.json(
         {
           error: 'Validation failed',
@@ -284,7 +568,9 @@ export async function POST(request: NextRequest, { params }: RouteParams) {
       targetId: pageId,
       content,
       authorEmail,
+      userId,
       moderationMode: moderation,
+      antiAbuse,
       honeypot,
       ipHash,
       requestId,
@@ -317,6 +603,7 @@ export async function POST(request: NextRequest, { params }: RouteParams) {
       parentId,
       requestId,
       ipHash,
+      spamFlags: classification.spamFlags,
       status: classification.status,
     });
 
diff --git a/apps/public/src/app/sites/[subdomain]/[[...path]]/page.tsx b/apps/public/src/app/sites/[subdomain]/[[...path]]/page.tsx
index 5957ecf..f4fe888 100644
--- a/apps/public/src/app/sites/[subdomain]/[[...path]]/page.tsx
+++ b/apps/public/src/app/sites/[subdomain]/[[...path]]/page.tsx
@@ -16,6 +16,10 @@ import {
 import { PageRenderer } from '@/components/PageRenderer';
 import AnimationHydrator from '@/components/AnimationHydrator';
 import type { Metadata } from 'next';
+import {
+  readBackyCommentIdentityFromQuery,
+  type BackyAuthBridgeOptions,
+} from '@/lib/backyAuthBridge';
 
 async function getSite(subdomain: string) {
     return getSiteByIdOrSlug(subdomain);
@@ -34,8 +38,31 @@ interface PageProps {
         subdomain: string;
         path?: string[];
     }>;
+    searchParams?: Record<string, string | string[] | undefined>;
 }
 
+const buildCommentAuthBridgeQuery = (
+  searchParams?: Record<string, string | string[] | undefined>,
+): string | undefined => {
+  if (!searchParams) {
+    return undefined;
+  }
+
+  const entries = Object.entries(searchParams)
+    .flatMap(([key, value]) => {
+      const normalized =
+        value === undefined
+          ? []
+          : Array.isArray(value)
+            ? value.filter(Boolean)
+            : [value];
+
+      return normalized.map((entry) => `${encodeURIComponent(key)}=${encodeURIComponent(entry)}`);
+    });
+
+  return entries.length > 0 ? `?${entries.join('&')}` : undefined;
+};
+
 export async function generateMetadata({ params }: PageProps): Promise<Metadata> {
     const { subdomain, path } = await params;
     const pageSlug = path?.join('/') || 'index';
@@ -69,7 +96,7 @@ export async function generateMetadata({ params }: PageProps): Promise<Metadata>
     };
 }
 
-export default async function SitePage({ params }: PageProps) {
+export default async function SitePage({ params, searchParams = {} }: PageProps) {
     const { subdomain, path } = await params;
     const pageSlug = path?.join('/') || 'index';
 
@@ -84,6 +111,19 @@ export default async function SitePage({ params }: PageProps) {
         notFound();
     }
 
+    const commentAuthBridgeQuery = buildCommentAuthBridgeQuery(searchParams);
+    const commentAuthBridgeOptions: BackyAuthBridgeOptions | undefined = commentAuthBridgeQuery
+      ? {
+          query: commentAuthBridgeQuery,
+          includeUrlQuery: true,
+          includeWindowBridge: true,
+          includeLocalIdentityStorage: true,
+          includeBackyAuthStorage: true,
+          refreshEvent: 'backy:identity:refresh',
+        }
+      : undefined;
+    const commentIdentity = readBackyCommentIdentityFromQuery(commentAuthBridgeQuery);
+
     return (
         <>
             {/* SEO head handled by generateMetadata */}
@@ -95,6 +135,8 @@ export default async function SitePage({ params }: PageProps) {
                 siteId={site.id}
                 pageId={page.id}
                 pageSlug={page.slug}
+                commentIdentity={commentIdentity}
+                commentAuthBridgeOptions={commentAuthBridgeOptions}
             />
 
             {/* Client-side animation hydration */}
diff --git a/apps/public/src/components/PageRenderer.tsx b/apps/public/src/components/PageRenderer.tsx
index 51aa6ae..780a584 100644
--- a/apps/public/src/components/PageRenderer.tsx
+++ b/apps/public/src/components/PageRenderer.tsx
@@ -12,6 +12,13 @@
 'use client';
 
 import React, { useEffect, useRef, useState } from 'react';
+import { useBackyAuthBridge } from '@/hooks/useBackyAuthBridge';
+import {
+  type BackyAuthBridgeOptions,
+  type BackyCommentIdentity,
+  mergeBackyCommentIdentities,
+  hasSignedInBackyCommentIdentity,
+} from '@/lib/backyAuthBridge';
 
 // ============================================================================
 // TYPES (matching page builder editor types)
@@ -124,68 +131,21 @@ interface CommentFormPayload {
   allowGuests: boolean;
   allowReplies: boolean;
   sort: 'newest' | 'oldest';
+  antiAbuse?: {
+    rateLimit?: number;
+    rateWindowMs?: number;
+    signatureWindowMs?: number;
+    minFillMs?: number;
+    autoBlockSpamCount?: number;
+    autoBlockDurationMinutes?: number;
+    requestRateLimit?: number;
+    requestRateWindowMs?: number;
+    autoBlockUserThreshold?: number;
+    autoBlockRequestThreshold?: number;
+  };
 }
 
-interface CommentIdentity {
-  userId?: string;
-  name?: string;
-  email?: string;
-  website?: string;
-}
-
-function readCommentIdentityFromBackyAuthStorage(): CommentIdentity | null {
-  if (typeof window === 'undefined') {
-    return null;
-  }
-
-  const raw = window.localStorage.getItem('backy-auth-storage');
-  if (!raw) {
-    return null;
-  }
-
-  try {
-    const parsed = JSON.parse(raw) as {
-      state?: {
-        user?: {
-          id?: unknown;
-          email?: unknown;
-          fullName?: unknown;
-          name?: unknown;
-          userId?: unknown;
-        };
-      };
-      user?: {
-        id?: unknown;
-        email?: unknown;
-        fullName?: unknown;
-        name?: unknown;
-        userId?: unknown;
-      };
-    };
-
-    const user = parsed?.state?.user || parsed?.user;
-    if (!user || typeof user !== 'object') {
-      return null;
-    }
-
-    const userId = parseStringValue((user as { id?: unknown }).id || (user as { userId?: unknown }).userId);
-    const email = parseStringValue((user as { email?: unknown }).email);
-    const fullName = parseStringValue((user as { fullName?: unknown }).fullName);
-    const name = parseStringValue((user as { name?: unknown }).name);
-
-    if (!userId && !email && !name && !fullName) {
-      return null;
-    }
-
-    return {
-      userId: userId || undefined,
-      name: fullName || name || undefined,
-      email: email || undefined,
-    };
-  } catch {
-    return null;
-  }
-}
+type CommentIdentity = BackyCommentIdentity;
 
 function extractApiErrorMessage(
   payload: unknown,
@@ -226,112 +186,6 @@ function extractApiErrorMessage(
   return fallback;
 }
 
-function parseStringValue(raw: unknown): string {
-  return typeof raw === 'string' ? raw.trim() : '';
-}
-
-function readCommentIdentityFromStorage(): CommentIdentity | null {
-  if (typeof window === 'undefined') {
-    return null;
-  }
-
-  const raw = window.localStorage.getItem('backy-comment-identity');
-  if (!raw) {
-    return null;
-  }
-
-  try {
-    const parsed = JSON.parse(raw) as {
-      userId?: unknown;
-      id?: unknown;
-      name?: unknown;
-      email?: unknown;
-      website?: unknown;
-    };
-
-    if (!parsed || typeof parsed !== 'object') {
-      return null;
-    }
-
-    const userId = parseStringValue(parsed.userId) || parseStringValue(parsed.id);
-    const name = parseStringValue(parsed.name);
-    const email = parseStringValue(parsed.email);
-    const website = parseStringValue(parsed.website);
-
-    if (!userId && !name && !email && !website) {
-      return null;
-    }
-
-    return {
-      userId: userId || undefined,
-      name: name || undefined,
-      email: email || undefined,
-      website: website || undefined,
-    };
-  } catch {
-    return null;
-  }
-}
-
-function readCommentIdentityFromQuery(): CommentIdentity | null {
-  if (typeof window === 'undefined') {
-    return null;
-  }
-
-  const searchParams = new URLSearchParams(window.location.search);
-  const userId = parseStringValue(searchParams.get('backyCommentUserId') || searchParams.get('commentUserId'));
-  const name = parseStringValue(searchParams.get('backyCommentUserName') || searchParams.get('name'));
-  const email = parseStringValue(searchParams.get('backyCommentUserEmail') || searchParams.get('email'));
-  const website = parseStringValue(
-    searchParams.get('backyCommentUserWebsite') || searchParams.get('website'),
-  );
-
-  if (!userId && !name && !email && !website) {
-    return null;
-  }
-
-  return {
-    userId: userId || undefined,
-    name: name || undefined,
-    email: email || undefined,
-    website: website || undefined,
-  };
-}
-
-function readCommentIdentity(): CommentIdentity | null {
-  const queryIdentity = readCommentIdentityFromQuery();
-  if (queryIdentity) {
-    if (typeof window !== 'undefined') {
-      window.localStorage.setItem('backy-comment-identity', JSON.stringify(queryIdentity));
-    }
-    return queryIdentity;
-  }
-
-  const storedIdentity = readCommentIdentityFromStorage();
-  const authIdentity = readCommentIdentityFromBackyAuthStorage();
-
-  if (!storedIdentity && !authIdentity) {
-    return null;
-  }
-
-  if (!storedIdentity) {
-    return authIdentity;
-  }
-
-  const mergedIdentity: CommentIdentity = {
-    userId: storedIdentity.userId || authIdentity?.userId,
-    name: storedIdentity.name || authIdentity?.name,
-    email: storedIdentity.email || authIdentity?.email,
-    website: storedIdentity.website || authIdentity?.website,
-  };
-
-  if (typeof window !== 'undefined' && (mergedIdentity.userId || mergedIdentity.name || mergedIdentity.email || mergedIdentity.website)) {
-    window.localStorage.setItem('backy-comment-identity', JSON.stringify(mergedIdentity));
-  }
-
-  return mergedIdentity;
-}
-
 const normalizeRendererType = (value: string): KnownElementType => {
   const normalized = typeof value === 'string' ? value.trim().toLowerCase().replace(/[^a-z0-9]+/g, '') : '';
 
@@ -449,6 +303,8 @@ interface ElementRendererContext {
   siteId?: string;
   pageId?: string;
   postId?: string;
+  commentIdentity?: BackyCommentIdentity | null;
+  commentAuthBridgeOptions?: BackyAuthBridgeOptions;
 }
 
 interface ElementRendererProps extends ElementRendererContext {
@@ -473,7 +329,7 @@ function getBoolean(value: unknown): boolean {
   return Boolean(value);
 }
 
-function parseBooleanSetting(value: unknown, fallback: boolean): boolean {
+function parseOptionalBoolean(value: unknown): boolean | undefined {
   if (typeof value === 'boolean') {
     return value;
   }
@@ -493,19 +349,144 @@ function parseBooleanSetting(value: unknown, fallback: boolean): boolean {
     }
   }
 
+  return undefined;
+}
+
+function parseOptionalNumber(value: unknown): number | undefined {
+  if (typeof value === 'number' && Number.isFinite(value)) {
+    return Math.trunc(value);
+  }
+
+  if (typeof value === 'string') {
+    const parsed = Number.parseFloat(value.trim());
+    return Number.isFinite(parsed) ? Math.trunc(parsed) : undefined;
+  }
+
+  return undefined;
+}
+
+function readCommentSettingBoolean(props: Record<string, unknown>, keys: string[], fallback: boolean): boolean {
+  for (const key of keys) {
+    if (!(key in props)) {
+      continue;
+    }
+
+    const value = parseOptionalBoolean(props[key]);
+    if (value !== undefined) {
+      return value;
+    }
+  }
+
   return fallback;
 }
 
+function readCommentSettingString(props: Record<string, unknown>, keys: string[]): string | undefined {
+  for (const key of keys) {
+    if (!(key in props)) {
+      continue;
+    }
+
+    const value = getNameClass(props[key]);
+    if (value.length > 0) {
+      return value;
+    }
+  }
+
+  return undefined;
+}
+
+function getCommentAntiAbusePolicy(props: Record<string, unknown>) {
+  const nested = typeof props.commentAntiAbuse === 'object' && props.commentAntiAbuse !== null
+    ? props.commentAntiAbuse as Record<string, unknown>
+    : typeof props.antiAbuse === 'object' && props.antiAbuse !== null
+      ? props.antiAbuse as Record<string, unknown>
+      : null;
+
+  const merged = {
+    ...props,
+    ...(nested || {}),
+    ...(typeof nested === 'object' ? nested : {}),
+  };
+
+  const antiAbuse = {
+    rateLimit: parseOptionalNumber(merged.commentAntiAbuseRateLimit ?? merged.antiAbuseRateLimit ?? merged.rateLimit),
+    rateWindowMs: parseOptionalNumber(
+      merged.commentAntiAbuseRateWindowMs ?? merged.antiAbuseRateWindowMs ?? merged.rateWindowMs,
+    ),
+    signatureWindowMs: parseOptionalNumber(
+      merged.commentAntiAbuseSignatureWindowMs
+        ?? merged.antiAbuseSignatureWindowMs
+        ?? merged.signatureWindowMs,
+    ),
+    minFillMs: parseOptionalNumber(merged.commentAntiAbuseMinFillMs ?? merged.antiAbuseMinFillMs ?? merged.minFillMs),
+    requestRateLimit: parseOptionalNumber(
+      merged.commentAntiAbuseRequestRateLimit ?? merged.antiAbuseRequestRateLimit ?? merged.requestRateLimit,
+    ),
+    requestRateWindowMs: parseOptionalNumber(
+      merged.commentAntiAbuseRequestRateWindowMs
+        ?? merged.antiAbuseRequestRateWindowMs
+        ?? merged.requestRateWindowMs,
+    ),
+    autoBlockSpamCount: parseOptionalNumber(
+      merged.commentAntiAbuseAutoBlockSpamCount
+        ?? merged.antiAbuseAutoBlockSpamCount
+        ?? merged.autoBlockSpamCount,
+    ),
+    autoBlockUserThreshold: parseOptionalNumber(
+      merged.commentAntiAbuseAutoBlockUserThreshold
+        ?? merged.autoBlockUserThreshold
+        ?? merged.antiAbuseAutoBlockUserThreshold,
+    ),
+    autoBlockRequestThreshold: parseOptionalNumber(
+      merged.commentAntiAbuseAutoBlockRequestThreshold
+        ?? merged.autoBlockRequestThreshold
+        ?? merged.antiAbuseAutoBlockRequestThreshold,
+    ),
+    autoBlockDurationMinutes: parseOptionalNumber(
+      merged.commentAntiAbuseAutoBlockDurationMinutes
+        ?? merged.antiAbuseAutoBlockDurationMinutes
+        ?? merged.autoBlockDurationMinutes,
+    ),
+  };
+
+  const hasValues = Object.values(antiAbuse).some((value) => value !== undefined);
+  return hasValues ? antiAbuse : undefined;
+}
+
 function parseCommentPayload(props: Record<string, unknown>): CommentFormPayload {
-  const moderationValue = getNameClass(props.commentModerationMode);
+  const moderationValue = readCommentSettingString(props, [
+    'commentModerationMode',
+    'commentModeration',
+    'moderationMode',
+    'mode',
+  ]);
 
   return {
     moderationMode: moderationValue === 'auto-approve' ? 'auto-approve' : 'manual',
-    requireName: parseBooleanSetting(props.commentRequireName, true),
-    requireEmail: parseBooleanSetting(props.commentRequireEmail, false),
-    allowGuests: parseBooleanSetting(props.commentAllowGuests, true),
-    allowReplies: parseBooleanSetting(props.commentAllowReplies, true),
-    sort: getNameClass(props.commentSortOrder) === 'oldest' ? 'oldest' : 'newest',
+    requireName: readCommentSettingBoolean(
+      props,
+      ['commentRequireName', 'requireName', 'requireAuthorName', 'nameRequired'],
+      true,
+    ),
+    requireEmail: readCommentSettingBoolean(
+      props,
+      ['commentRequireEmail', 'requireEmail', 'requireAuthorEmail', 'emailRequired'],
+      false,
+    ),
+    allowGuests: readCommentSettingBoolean(
+      props,
+      ['commentAllowGuests', 'allowGuests', 'allowGuestComments', 'guestPostingEnabled', 'guestsEnabled'],
+      true,
+    ),
+    allowReplies: readCommentSettingBoolean(
+      props,
+      ['commentAllowReplies', 'allowReplies', 'replyEnabled', 'repliesEnabled'],
+      true,
+    ),
+    sort: readCommentSettingString(props, ['commentSortOrder', 'commentSort', 'sortOrder']) === 'oldest'
+      ? 'oldest'
+      : 'newest',
+    antiAbuse: getCommentAntiAbusePolicy(props),
   };
 }
 
@@ -626,6 +607,41 @@ function parseNumericAttribute(value: unknown): number | undefined {
   return Number.isFinite(parsed) ? parsed : undefined;
 }
 
+type SerializedFileValue = {
+  fileName: string;
+  fileSize?: number;
+  size?: number;
+  fileType?: string;
+  type?: string;
+};
+
+function normalizeFormSubmissionValue(
+  value: FormDataEntryValue,
+): string | SerializedFileValue | null {
+  if (typeof value === 'string') {
+    return value;
+  }
+
+  if (value instanceof File) {
+    if (!value.name && value.size === 0 && !value.type) {
+      return null;
+    }
+
+    const size = Number.isFinite(value.size) ? value.size : undefined;
+    const type = value.type || '';
+
+    return {
+      fileName: value.name,
+      fileSize: size,
+      size: size,
+      fileType: type || undefined,
+      type: type || undefined,
+    };
+  }
+
+  return null;
+}
+
 function toFormInputValueList(raw: unknown): string[] {
   if (Array.isArray(raw)) {
     return raw
@@ -1002,7 +1018,15 @@ function ButtonElement({ element }: ElementRendererProps) {
 /**
  * Render a container/section element
  */
-function ContainerElement({ element, isPreview, siteId, pageId, postId }: ElementRendererProps) {
+function ContainerElement({
+  element,
+  isPreview,
+  siteId,
+  pageId,
+  postId,
+  commentIdentity,
+  commentAuthBridgeOptions,
+}: ElementRendererProps) {
   const { props, styles, children } = element;
 
   return (
@@ -1031,6 +1055,8 @@ function ContainerElement({ element, isPreview, siteId, pageId, postId }: Elemen
           siteId={siteId}
           pageId={pageId}
           postId={postId}
+          commentIdentity={commentIdentity}
+          commentAuthBridgeOptions={commentAuthBridgeOptions}
         />
       ))}
     </div>
@@ -1178,7 +1204,15 @@ function LinkElement({ element, siteId, pageId, postId }: ElementRendererProps)
 /**
  * Render a form element
  */
-function FormElement({ element, isPreview, siteId, pageId, postId }: ElementRendererProps) {
+function FormElement({
+  element,
+  isPreview,
+  siteId,
+  pageId,
+  postId,
+  commentIdentity,
+  commentAuthBridgeOptions,
+}: ElementRendererProps) {
   const { props, styles, children } = element;
   const [submitState, setSubmitState] = useState<'idle' | 'submitting' | 'success' | 'error'>('idle');
   const [submitMessage, setSubmitMessage] = useState('');
@@ -1231,21 +1265,23 @@ function FormElement({ element, isPreview, siteId, pageId, postId }: ElementRend
     const startedAt = startedAtRef.current;
 
     formData.forEach((value, key) => {
-      const normalized = key;
-      const valueAsText = value.toString();
-      const existing = values[normalized];
+      const normalizedValue = normalizeFormSubmissionValue(value);
+      if (normalizedValue === null) {
+        return;
+      }
 
+      const existing = values[key];
       if (existing === undefined) {
-        values[normalized] = valueAsText;
+        values[key] = normalizedValue;
         return;
       }
 
       if (Array.isArray(existing)) {
-        existing.push(valueAsText);
+        existing.push(normalizedValue);
         return;
       }
 
-      values[normalized] = [existing as string, valueAsText];
+      values[key] = [existing, normalizedValue];
     });
 
     const body = {
@@ -1369,6 +1405,8 @@ function FormElement({ element, isPreview, siteId, pageId, postId }: ElementRend
             siteId={siteId}
             pageId={pageId}
             postId={postId}
+            commentIdentity={commentIdentity}
+            commentAuthBridgeOptions={commentAuthBridgeOptions}
           />
         ))}
       </form>
@@ -1395,7 +1433,16 @@ function FormElement({ element, isPreview, siteId, pageId, postId }: ElementRend
 /**
  * Render a comment thread block
  */
-function CommentThreadElement({ element, isPreview, siteId, pageId, postId }: ElementRendererProps) {
+function CommentThreadElement({
+  element,
+  isPreview,
+  siteId,
+  pageId,
+  postId,
+  commentIdentity,
+  commentAuthBridgeOptions,
+}: ElementRendererProps) {
+  
   const { props, styles } = element;
   const [comments, setComments] = useState<CommentItem[]>([]);
   const [loading, setLoading] = useState(false);
@@ -1412,45 +1459,50 @@ function CommentThreadElement({ element, isPreview, siteId, pageId, postId }: El
   const [reportReasons, setReportReasons] = useState<string[]>([...DEFAULT_COMMENT_REPORT_REASONS]);
   const [reportReasonByCommentId, setReportReasonByCommentId] = useState<Record<string, string>>({});
   const [reportingCommentId, setReportingCommentId] = useState<string | null>(null);
-  const [commenterIdentity, setCommenterIdentity] = useState<CommentIdentity | null>(readCommentIdentity());
+  const bridgeIdentity = useBackyAuthBridge({
+    storageKey: commentAuthBridgeOptions?.storageKey || 'backy-comment-identity',
+    backyAuthStorageKey: commentAuthBridgeOptions?.backyAuthStorageKey || 'backy-auth-storage',
+    includeWindowBridge: commentAuthBridgeOptions?.includeWindowBridge !== false,
+    includeUrlQuery: commentAuthBridgeOptions?.includeUrlQuery !== false,
+    includeBackyAuthStorage: commentAuthBridgeOptions?.includeBackyAuthStorage !== false,
+    includeLocalIdentityStorage: commentAuthBridgeOptions?.includeLocalIdentityStorage !== false,
+    persist: commentAuthBridgeOptions?.persist === true,
+    source: commentAuthBridgeOptions?.source,
+    query: commentAuthBridgeOptions?.query,
+    storage: commentAuthBridgeOptions?.storage,
+  });
+  const commenterIdentity = mergeBackyCommentIdentities(commentIdentity, bridgeIdentity);
   const requestIdRef = useRef<string>(`c-${Math.random().toString(36).slice(2, 10)}-${Date.now()}`);
   const startedAtRef = useRef<number>(Date.now());
 
   const commentApiPath = getCommentApiPath(siteId, pageId, postId);
   const policy = parseCommentPayload(props as Record<string, unknown>);
-  const canSubmitAsSignedIn = Boolean(commenterIdentity?.userId);
+  const canSubmitAsSignedIn = hasSignedInBackyCommentIdentity(commenterIdentity);
   const canSubmitComments = policy.allowGuests || canSubmitAsSignedIn;
   const canSubmitReplies = policy.allowReplies && canSubmitComments;
+  const identityHelpMessage = 'Sign-in required to post. Pass a user identity with userId (query or window bridge), e.g. backyCommentUserId, backyCommentUserName, backyCommentUserEmail, or window.backyAuth.';
+  const signedInIdentityLabel = canSubmitAsSignedIn
+    ? [commenterIdentity?.name, commenterIdentity?.email, commenterIdentity?.userId].find(Boolean)
+    : undefined;
+  const policySummary = `Moderation: ${policy.moderationMode} • Replies: ${policy.allowReplies ? 'on' : 'off'} • Guests: ${policy.allowGuests ? 'on' : 'off'} • Name required: ${policy.requireName ? 'on' : 'off'} • Email required: ${policy.requireEmail ? 'on' : 'off'}`;
 
   useEffect(() => {
     requestIdRef.current = `c-${Math.random().toString(36).slice(2, 10)}-${Date.now()}`;
     startedAtRef.current = Date.now();
-
-    const syncIdentity = () => {
-      const identity = readCommentIdentity();
-      setCommenterIdentity(identity);
-
-      if (identity?.name) {
-        setAuthorName((current) => current || identity.name || '');
-      }
-      if (identity?.email) {
-        setAuthorEmail((current) => current || identity.email || '');
-      }
-      if (identity?.website) {
-        setAuthorWebsite((current) => current || identity.website || '');
-      }
-    };
-
-    syncIdentity();
-    window.addEventListener('storage', syncIdentity);
-    window.addEventListener('popstate', syncIdentity);
-
-    return () => {
-      window.removeEventListener('storage', syncIdentity);
-      window.removeEventListener('popstate', syncIdentity);
-    };
   }, [siteId, pageId, postId]);
 
+  useEffect(() => {
+    if (commenterIdentity?.name) {
+      setAuthorName((current) => current || commenterIdentity.name || '');
+    }
+    if (commenterIdentity?.email) {
+      setAuthorEmail((current) => current || commenterIdentity.email || '');
+    }
+    if (commenterIdentity?.website) {
+      setAuthorWebsite((current) => current || commenterIdentity.website || '');
+    }
+  }, [commenterIdentity?.userId, commenterIdentity?.name, commenterIdentity?.email, commenterIdentity?.website]);
+
   const fetchComments = async () => {
     if (!commentApiPath || isPreview) {
       return;
@@ -1627,7 +1679,9 @@ function CommentThreadElement({ element, isPreview, siteId, pageId, postId }: El
       commentRequireEmail: policy.requireEmail,
       commentAllowGuests: policy.allowGuests,
       commentAllowReplies: policy.allowReplies,
+      antiAbuse: policy.antiAbuse,
       userId: commenterIdentity?.userId,
+      identity: commenterIdentity,
       authorName: resolvedAuthorName,
       authorEmail: resolvedAuthorEmail,
       authorWebsite: resolvedAuthorWebsite,
@@ -1806,6 +1860,23 @@ function CommentThreadElement({ element, isPreview, siteId, pageId, postId }: El
   return (
     <section style={{ ...styles }}>
       <h4 style={{ margin: '0 0 12px' }}>{props.commentTitle || 'Comments'}</h4>
+      <p
+        style={{
+          margin: '0 0 12px',
+          fontSize: '12px',
+          color: '#334155',
+          lineHeight: 1.4,
+        }}
+      >
+        {policySummary}
+      </p>
+      {signedInIdentityLabel ? (
+        <p style={{ margin: '0 0 12px', fontSize: '12px', color: '#065f46' }}>
+          Posting as:
+          {' '}
+          {signedInIdentityLabel}
+        </p>
+      ) : null}
       {isPreview ? (
         <p style={{ color: '#64748b', fontSize: '12px' }}>
           Preview mode: comment thread data is not refreshed.
@@ -1821,11 +1892,11 @@ function CommentThreadElement({ element, isPreview, siteId, pageId, postId }: El
       </div>
 
       <form onSubmit={submitTopLevel} style={{ marginTop: '12px', display: 'flex', flexDirection: 'column', gap: '8px' }}>
-            {!canSubmitComments ? (
-              <p style={{ margin: 0, color: '#b91c1c' }}>
-                Guest posting is disabled for this comment thread. Sign in is required for this form.
-              </p>
-            ) : null}
+        {!canSubmitComments ? (
+          <p style={{ margin: 0, color: '#b91c1c' }}>
+            Guest posting is disabled for this comment thread. {identityHelpMessage}
+          </p>
+        ) : null}
         <textarea
           placeholder="Write a comment"
           value={content}
@@ -1909,6 +1980,8 @@ function InputElement({ element }: ElementRendererProps) {
   const fieldName = getNameClass(props.name) || `field-${element.id}`;
   const minLength = parseNumericAttribute(props.minLength);
   const maxLength = parseNumericAttribute(props.maxLength);
+  const accept = getNameClass(props.accept);
+  const allowMultiple = getBoolean(props.multiple);
 
   return (
     <input
@@ -1923,6 +1996,8 @@ function InputElement({ element }: ElementRendererProps) {
       disabled={getBoolean(props.disabled)}
       minLength={Number.isFinite(minLength) ? minLength : undefined}
       maxLength={maxLength}
+      accept={accept || undefined}
+      multiple={allowMultiple}
       defaultValue={getNameClass(props.defaultValue)}
       style={{
         padding: '12px 16px',
@@ -2006,7 +2081,7 @@ function SelectElement({ element }: ElementRendererProps) {
 /**
  * Render checkbox list and single checkbox/radio inputs
  */
-function CheckboxOrRadioElement({ element, isPreview }: ElementRendererProps) {
+function CheckboxOrRadioElement({ element, isPreview, commentIdentity, commentAuthBridgeOptions }: ElementRendererProps) {
   const { props, styles, children } = element;
   const inputType = element.type === 'checkbox' ? 'checkbox' : 'radio';
   const name = getNameClass(props.name) || `field-${element.id}`;
@@ -2054,6 +2129,8 @@ function CheckboxOrRadioElement({ element, isPreview }: ElementRendererProps) {
             key={child.id}
             element={child}
             isPreview={Boolean(isPreview)}
+            commentIdentity={commentIdentity}
+            commentAuthBridgeOptions={commentAuthBridgeOptions}
           />
         ))}
       </div>
@@ -2095,6 +2172,8 @@ function CheckboxOrRadioElement({ element, isPreview }: ElementRendererProps) {
             key={child.id}
             element={child}
             isPreview={Boolean(isPreview)}
+            commentIdentity={commentIdentity}
+            commentAuthBridgeOptions={commentAuthBridgeOptions}
           />
         ))}
       </div>
@@ -2172,7 +2251,15 @@ const ELEMENT_RENDERERS: Record<
 /**
  * Main element renderer - routes to specific element renderers
  */
-export function ElementRenderer({ element, isPreview, siteId, pageId, postId }: ElementRendererProps) {
+export function ElementRenderer({
+  element,
+  isPreview,
+  siteId,
+  pageId,
+  postId,
+  commentIdentity,
+  commentAuthBridgeOptions,
+}: ElementRendererProps) {
   const normalizedType = normalizeRendererType(element.type);
   const Renderer = ELEMENT_RENDERERS[normalizedType];
 
@@ -2223,6 +2310,8 @@ export function ElementRenderer({ element, isPreview, siteId, pageId, postId }:
         siteId={siteId}
         pageId={pageId}
         postId={postId}
+        commentIdentity={commentIdentity}
+        commentAuthBridgeOptions={commentAuthBridgeOptions}
       />
     </div>
   );
@@ -2240,6 +2329,8 @@ interface PageRendererProps {
   pageId?: string;
   postId?: string;
   pageSlug?: string;
+  commentIdentity?: BackyCommentIdentity | null;
+  commentAuthBridgeOptions?: BackyAuthBridgeOptions;
 }
 
 /**
@@ -2254,6 +2345,8 @@ export function PageRenderer({
   siteId,
   pageId,
   postId,
+  commentIdentity,
+  commentAuthBridgeOptions,
 }: PageRendererProps) {
   const { elements, canvasSize, customCSS } = content;
   const [scale, setScale] = useState(1);
@@ -2351,6 +2444,8 @@ export function PageRenderer({
               siteId={siteId}
               pageId={pageId}
               postId={postId}
+              commentIdentity={commentIdentity}
+              commentAuthBridgeOptions={commentAuthBridgeOptions}
             />
           ))}
         </div>
diff --git a/apps/public/src/lib/backyStore.ts b/apps/public/src/lib/backyStore.ts
index 7490291..4da8215 100644
--- a/apps/public/src/lib/backyStore.ts
+++ b/apps/public/src/lib/backyStore.ts
@@ -1,6 +1,7 @@
 import { DEFAULT_THEME } from '@backy-cms/core';
 import type {
   Comment,
+  CommentAntiAbusePolicy,
   CommentTargetType,
   FormFieldDefinition,
   FormDefinition,
@@ -128,6 +129,78 @@ interface Pagination {
   hasMore: boolean;
 }
 
+interface CommentModerationAnalytics {
+  siteId: string;
+  total: number;
+  status: {
+    pending: number;
+    approved: number;
+    rejected: number;
+    spam: number;
+    blocked: number;
+  };
+  byTargetType: {
+    page: number;
+    post: number;
+  };
+  threads: number;
+  replies: number;
+  totalReports: number;
+  topReportReasons: Array<{ reason: string; count: number }>;
+  antiAbusePolicy?: Required<CommentAntiAbusePolicy> | null;
+  antiAbuse: {
+    totalSignals: number;
+    flags: Array<{ flag: string; count: number }>;
+    topFlaggedUsers: Array<{ userKey: string; count: number }>;
+    topRequestIds: Array<{ requestId: string; count: number }>;
+    topBlockReasons: Array<{ reasonAlias: string; count: number }>;
+    blockedByIdentity: number;
+    blockedByType: {
+      email: number;
+      ip: number;
+      user: number;
+      request: number;
+    };
+  };
+}
+
+interface CommentAntiAbuseIdentityBlock {
+  type: CommentBlockKind;
+  value: string;
+  reason: string;
+  actor?: string;
+  requestId?: string;
+  createdAt: string;
+  expiresAt?: string;
+  reasonAlias?: string;
+}
+
+interface CommentBlockEntryPayload {
+  type: CommentBlockKind;
+  value: string;
+  reason: string;
+  actor?: string;
+  requestId?: string;
+  createdAt: string;
+  expiresAt?: string;
+  reasonAlias?: string;
+  key: string;
+}
+
+interface CommentAntiAbuseCounters {
+  totalSignals: number;
+  flags: Map<string, number>;
+  users: Map<string, number>;
+  requests: Map<string, number>;
+  blockedByIdentity: number;
+  blockedByType: {
+    email: number;
+    ip: number;
+    user: number;
+    request: number;
+  };
+}
+
 interface SubmissionValidationDetail {
   field: string;
   message: string;
@@ -829,10 +902,22 @@ const COMMENT_LIST: Comment[] = [
 
 const FORM_SUBMISSIONS: FormSubmission[] = [];
 const CONTACT_LIST: Contact[] = [];
-const COMMENT_REPORT_BLOCKLIST = new Map<
-  string,
-  { type: 'email' | 'ip'; value: string; reason: string; actor?: string; requestId?: string; createdAt: string; }
->();
+type CommentBlockKind = 'email' | 'ip' | 'user' | 'request';
+
+interface CommentBlockEntry {
+  type: CommentBlockKind;
+  value: string;
+  reason: string;
+  actor?: string;
+  requestId?: string;
+  createdAt: string;
+  expiresAt?: string;
+  reasonAlias?: string;
+}
+
+const COMMENT_REPORT_BLOCKLIST = new Map<string, CommentBlockEntry>();
+const COMMENT_ANTI_ABUSE_STATS = new Map<string, CommentAntiAbuseCounters>();
+const COMMENT_ANTI_ABUSE_SITE_POLICIES = new Map<string, Required<CommentAntiAbusePolicy>>();
 const SUBMISSION_RATE_WINDOWS = new Map<string, SubmissionRateState>();
 const SUBMISSION_SIGNATURE_WINDOW_MS = 10 * 60 * 1000;
 const SUBMISSION_RATE_WINDOW_MS = 60 * 1000;
@@ -840,11 +925,26 @@ const SUBMISSION_RATE_LIMIT = 8;
 const FORM_SUBMISSION_SIGNATURES = new Map<string, number[]>();
 const FORM_SUBMISSION_MIN_FILL_MS = 900;
 const COMMENT_RATE_WINDOWS = new Map<string, SubmissionRateState>();
+const COMMENT_REQUEST_RATE_WINDOWS = new Map<string, SubmissionRateState>();
 const COMMENT_SIGNATURE_WINDOW_MS = 5 * 60 * 1000;
 const COMMENT_RATE_WINDOW_MS = 45 * 1000;
 const COMMENT_RATE_LIMIT = 12;
+const COMMENT_REQUEST_RATE_WINDOW_MS = 60 * 1000;
+const COMMENT_REQUEST_RATE_LIMIT = 30;
 const COMMENT_SIGNATURES = new Map<string, number[]>();
 const COMMENT_MIN_FILL_MS = 900;
+const COMMENT_ANTI_ABUSE_DEFAULTS = {
+  rateLimit: COMMENT_RATE_LIMIT,
+  rateWindowMs: COMMENT_RATE_WINDOW_MS,
+  signatureWindowMs: COMMENT_SIGNATURE_WINDOW_MS,
+  minFillMs: COMMENT_MIN_FILL_MS,
+  autoBlockSpamCount: 5,
+  autoBlockDurationMinutes: 60,
+  requestRateLimit: COMMENT_REQUEST_RATE_LIMIT,
+  requestRateWindowMs: COMMENT_REQUEST_RATE_WINDOW_MS,
+  autoBlockUserThreshold: 5,
+  autoBlockRequestThreshold: 5,
+};
 const AUDIT_EVENTS: AuditEvent[] = [];
 
 let commentStore: Comment[] = [...COMMENT_LIST];
@@ -872,40 +972,176 @@ function normalizeIdentifier(value: string) {
   return value.trim().toLowerCase();
 }
 
-function normalizeReportReason(raw: string | null | undefined): string | null {
-  const normalized = (raw || '').trim().toLowerCase();
-  if (!normalized) {
-    return null;
+function parsePositiveIntInput(raw: unknown, fallback: number): number {
+  const parsed = typeof raw === 'number' && Number.isFinite(raw) ? Math.floor(raw) : Number.parseInt(String(raw), 10);
+  if (!Number.isFinite(parsed)) {
+    return fallback;
   }
+  return parsed < 0 ? fallback : parsed;
+}
 
-  if (COMMENT_REPORT_REASONS.includes(normalized as CommentReportReason)) {
-    return normalized as CommentReportReason;
+function resolveAntiAbuseThreshold(raw: number, fallback: number): number {
+  if (raw === 0) {
+    return 0;
   }
 
-  if (normalized === 'off topic' || normalized === 'off-topic' || normalized === 'offtopic') {
-    return 'off-topic';
+  if (Number.isFinite(raw) && raw > 0) {
+    return raw;
   }
 
-  if (normalized === 'hate' || normalized === 'hatespeech') {
-    return 'hate-speech';
+  return fallback;
+}
+
+function ensureAntiAbuseCounters(siteId: string): CommentAntiAbuseCounters {
+  const existing = COMMENT_ANTI_ABUSE_STATS.get(siteId);
+  if (existing) {
+    return existing;
   }
 
-  if (normalized === 'abusive' || normalized === 'threat') {
-    return 'abuse';
+  const created: CommentAntiAbuseCounters = {
+    totalSignals: 0,
+    flags: new Map(),
+    users: new Map(),
+    requests: new Map(),
+    blockedByIdentity: 0,
+    blockedByType: {
+      email: 0,
+      ip: 0,
+      user: 0,
+      request: 0,
+    },
+  };
+
+  COMMENT_ANTI_ABUSE_STATS.set(siteId, created);
+  return created;
+}
+
+function toAntiAbusePolicy(raw?: CommentAntiAbusePolicy): Required<CommentAntiAbusePolicy> {
+  return {
+    rateLimit: parsePositiveIntInput(raw?.rateLimit, COMMENT_ANTI_ABUSE_DEFAULTS.rateLimit),
+    rateWindowMs: parsePositiveIntInput(raw?.rateWindowMs, COMMENT_ANTI_ABUSE_DEFAULTS.rateWindowMs),
+    signatureWindowMs: parsePositiveIntInput(raw?.signatureWindowMs, COMMENT_ANTI_ABUSE_DEFAULTS.signatureWindowMs),
+    minFillMs: parsePositiveIntInput(raw?.minFillMs, COMMENT_ANTI_ABUSE_DEFAULTS.minFillMs),
+    autoBlockSpamCount: parsePositiveIntInput(raw?.autoBlockSpamCount, COMMENT_ANTI_ABUSE_DEFAULTS.autoBlockSpamCount),
+    autoBlockDurationMinutes: parsePositiveIntInput(
+      raw?.autoBlockDurationMinutes,
+      COMMENT_ANTI_ABUSE_DEFAULTS.autoBlockDurationMinutes,
+    ),
+    requestRateLimit: parsePositiveIntInput(
+      raw?.requestRateLimit,
+      COMMENT_ANTI_ABUSE_DEFAULTS.requestRateLimit,
+    ),
+    requestRateWindowMs: parsePositiveIntInput(
+      raw?.requestRateWindowMs,
+      COMMENT_ANTI_ABUSE_DEFAULTS.requestRateWindowMs,
+    ),
+    autoBlockUserThreshold: resolveAntiAbuseThreshold(
+      typeof raw?.autoBlockUserThreshold === 'number' ? raw.autoBlockUserThreshold : Number.NaN,
+      parsePositiveIntInput(
+        raw?.autoBlockUserThreshold,
+        COMMENT_ANTI_ABUSE_DEFAULTS.autoBlockUserThreshold,
+      ),
+    ),
+    autoBlockRequestThreshold: resolveAntiAbuseThreshold(
+      typeof raw?.autoBlockRequestThreshold === 'number' ? raw.autoBlockRequestThreshold : Number.NaN,
+      parsePositiveIntInput(
+        raw?.autoBlockRequestThreshold,
+        COMMENT_ANTI_ABUSE_DEFAULTS.autoBlockRequestThreshold,
+      ),
+    ),
+  };
+}
+
+export function getSiteCommentAntiAbusePolicy(siteId: string): Required<CommentAntiAbusePolicy> | null {
+  const policy = COMMENT_ANTI_ABUSE_SITE_POLICIES.get(siteId);
+  return policy ? clone(policy) : null;
+}
+
+export function setSiteCommentAntiAbusePolicy(
+  siteId: string,
+  policy: Partial<CommentAntiAbusePolicy>,
+): Required<CommentAntiAbusePolicy> {
+  const merged = toAntiAbusePolicy({
+    ...(COMMENT_ANTI_ABUSE_SITE_POLICIES.get(siteId) || {}),
+    ...policy,
+  });
+
+  COMMENT_ANTI_ABUSE_SITE_POLICIES.set(siteId, merged);
+  return clone(merged);
+}
+
+export function clearSiteCommentAntiAbusePolicy(siteId: string): void {
+  COMMENT_ANTI_ABUSE_SITE_POLICIES.delete(siteId);
+}
+
+function resolveExpiryDate(minutes: number | undefined): string | undefined {
+  if (!minutes || minutes <= 0) {
+    return undefined;
   }
 
-  if (normalized === 'other') {
-    return 'other';
+  return new Date(Date.now() + minutes * 60 * 1000).toISOString();
+}
+
+function isCommentBlockExpired(entry: {
+  expiresAt?: string;
+}): boolean {
+  if (!entry.expiresAt) {
+    return false;
   }
 
-  return 'other';
+  const expiresAt = Date.parse(entry.expiresAt);
+  if (Number.isNaN(expiresAt)) {
+    return true;
+  }
+
+  return Date.now() >= expiresAt;
 }
 
-function getCommentBlockKey(siteId: string, kind: 'email' | 'ip', value: string) {
-  return `${siteId}:${kind}:${normalizeIdentifier(value)}`;
+function removeExpiredCommentBlocks(siteId: string): void {
+  const sitePrefix = `${siteId}:`;
+  const activeBlockEntries: Array<CommentBlockEntry> = [];
+
+  for (const [key, item] of COMMENT_REPORT_BLOCKLIST.entries()) {
+    if (!key.startsWith(sitePrefix)) {
+      continue;
+    }
+
+    if (isCommentBlockExpired(item)) {
+      COMMENT_REPORT_BLOCKLIST.delete(key);
+    } else {
+      activeBlockEntries.push(item);
+    }
+  }
+
+  const counter = ensureAntiAbuseCounters(siteId);
+  counter.blockedByIdentity = activeBlockEntries.length;
+  counter.blockedByType = {
+    email: 0,
+    ip: 0,
+    user: 0,
+    request: 0,
+  };
+
+  activeBlockEntries.forEach((entry) => {
+    counter.blockedByType[entry.type] = counter.blockedByType[entry.type] + 1;
+  });
 }
 
-function isCommentBlockedByIdentity(siteId: string, params: { email?: string | null; ipHash?: string | null }) {
+function getCommentBlocklistEntry(
+  siteId: string,
+  params: { email?: string | null; ipHash?: string | null; userId?: string | null; requestId?: string | null },
+): ({
+  type: 'email' | 'ip' | 'user' | 'request';
+  value: string;
+  reason: string;
+  actor?: string;
+  requestId?: string;
+  createdAt: string;
+  expiresAt?: string;
+  reasonAlias?: string;
+}) | null {
+  removeExpiredCommentBlocks(siteId);
+
   const blockedEmailKey = params.email
     ? COMMENT_REPORT_BLOCKLIST.get(getCommentBlockKey(siteId, 'email', params.email))
     : null;
@@ -921,9 +1157,115 @@ function isCommentBlockedByIdentity(siteId: string, params: { email?: string | n
     }
   }
 
+  const blockedUser = params.userId
+    ? COMMENT_REPORT_BLOCKLIST.get(getCommentBlockKey(siteId, 'user', params.userId))
+    : null;
+
+  if (blockedUser) {
+    return blockedUser;
+  }
+
+  if (params.requestId) {
+    const blockedRequest = COMMENT_REPORT_BLOCKLIST.get(
+      getCommentBlockKey(siteId, 'request', params.requestId),
+    );
+
+    if (blockedRequest) {
+      return blockedRequest;
+    }
+  }
+
   return null;
 }
 
+function updateAntiAbuseCounter(siteId: string, updates: {
+  flags: string[];
+  requestId?: string | null;
+  userKey?: string | null;
+}): void {
+  if (updates.flags.length === 0) {
+    return;
+  }
+
+  const counters = ensureAntiAbuseCounters(siteId);
+  counters.totalSignals += updates.flags.length;
+
+  updates.flags.forEach((flag) => {
+    counters.flags.set(flag, (counters.flags.get(flag) || 0) + 1);
+  });
+
+  if (updates.userKey) {
+    counters.users.set(updates.userKey, (counters.users.get(updates.userKey) || 0) + 1);
+  }
+
+  if (updates.requestId) {
+    counters.requests.set(
+      updates.requestId,
+      (counters.requests.get(updates.requestId) || 0) + 1,
+    );
+  }
+}
+
+function resolveAbuseUserKey(raw: {
+  authorUserId?: string | null;
+  authorEmail?: string | null;
+  ipHash?: string | null;
+}): string {
+  if (raw.authorUserId) {
+    return `user:${normalizeIdentifier(raw.authorUserId)}`;
+  }
+
+  if (raw.authorEmail) {
+    return `email:${normalizeIdentifier(raw.authorEmail)}`;
+  }
+
+  if (raw.ipHash) {
+    return `ip:${normalizeIdentifier(raw.ipHash)}`;
+  }
+
+  return 'anon';
+}
+
+export function normalizeReportReason(raw: string | null | undefined): string | null {
+  const normalized = (raw || '').trim().toLowerCase();
+  if (!normalized) {
+    return null;
+  }
+
+  if (COMMENT_REPORT_REASONS.includes(normalized as CommentReportReason)) {
+    return normalized as CommentReportReason;
+  }
+
+  if (normalized === 'off topic' || normalized === 'off-topic' || normalized === 'offtopic') {
+    return 'off-topic';
+  }
+
+  if (normalized === 'hate' || normalized === 'hatespeech') {
+    return 'hate-speech';
+  }
+
+  if (normalized === 'abusive' || normalized === 'threat') {
+    return 'abuse';
+  }
+
+  if (normalized === 'other') {
+    return 'other';
+  }
+
+  return 'other';
+}
+
+function getCommentBlockKey(siteId: string, kind: CommentBlockKind, value: string) {
+  return `${siteId}:${kind}:${normalizeIdentifier(value)}`;
+}
+
+function isCommentBlockedByIdentity(
+  siteId: string,
+  params: { email?: string | null; ipHash?: string | null; userId?: string | null; requestId?: string | null },
+) {
+  return getCommentBlocklistEntry(siteId, params);
+}
+
 function getRequestKey(siteId: string, formId: string, ipHash?: string | null) {
   return `${siteId}:${formId}:${ipHash || 'anonymous'}`;
 }
@@ -1073,6 +1415,23 @@ function parseNumberValue(value: unknown): number | undefined {
   return Number.isFinite(parsed) ? parsed : undefined;
 }
 
+function parseBooleanValue(value: unknown): boolean | undefined {
+  if (typeof value === 'boolean') {
+    return value;
+  }
+
+  const normalized = sanitizeString(value).toLowerCase();
+  if (normalized === 'true' || normalized === '1' || normalized === 'on' || normalized === 'yes') {
+    return true;
+  }
+
+  if (normalized === 'false' || normalized === '0' || normalized === 'off' || normalized === 'no') {
+    return false;
+  }
+
+  return undefined;
+}
+
 function parseFieldOptions(rawOptions: unknown): string[] {
   if (!rawOptions) {
     return [];
@@ -1108,6 +1467,101 @@ function parseFieldOptions(rawOptions: unknown): string[] {
   return [];
 }
 
+interface FileUploadValue {
+  name: string;
+  size?: number;
+  type?: string;
+}
+
+function parseFileUploadValue(value: unknown): FileUploadValue | null {
+  if (!value || typeof value !== 'object') {
+    return null;
+  }
+
+  const source = value as Record<string, unknown>;
+  const fileName = extractFileSubmissionName(source);
+  if (!fileName) {
+    return null;
+  }
+
+  const size = parseNumberValue(source.size ?? source.fileSize ?? source.bytes ?? source.length);
+  const type = sanitizeString(source.type || source.fileType || source.mimeType || source.mime);
+
+  return {
+    name: fileName,
+    size: Number.isFinite(size) ? size : undefined,
+    type: type.length > 0 ? type : undefined,
+  };
+}
+
+function parseFileUploadValues(raw: unknown): FileUploadValue[] {
+  if (raw == null) {
+    return [];
+  }
+
+  if (Array.isArray(raw)) {
+    return raw.flatMap((entry) => {
+      const parsed = parseFileUploadValue(entry);
+      return parsed ? [parsed] : [];
+    });
+  }
+
+  const parsed = parseFileUploadValue(raw);
+  return parsed ? [parsed] : [];
+}
+
+function parseAcceptedFileTypes(value: unknown): string[] {
+  return parseFieldOptions(value)
+    .map((item) => item.toLowerCase().trim())
+    .filter(Boolean);
+}
+
+function isFileTypeAccepted(file: FileUploadValue, acceptedTypes: string[]): boolean {
+  if (acceptedTypes.length === 0) {
+    return true;
+  }
+
+  const normalizedType = sanitizeString(file.type).toLowerCase();
+  const normalizedName = file.name.toLowerCase();
+  const normalizedExtension = normalizedName.includes('.')
+    ? normalizedName.split('.').pop() || ''
+    : '';
+
+  return acceptedTypes.some((acceptedType) => {
+    if (!acceptedType) {
+      return true;
+    }
+
+    const normalizedAcceptedType = acceptedType.toLowerCase();
+
+    if (normalizedAcceptedType === '*/*' || normalizedAcceptedType === '*') {
+      return true;
+    }
+
+    if (normalizedAcceptedType.includes('/*')) {
+      return Boolean(normalizedType) && normalizedType.startsWith(`${normalizedAcceptedType.split('/')[0]}/`);
+    }
+
+    if (normalizedAcceptedType.includes('/')) {
+      return Boolean(normalizedType) && normalizedType === normalizedAcceptedType;
+    }
+
+    const extension = normalizedAcceptedType.startsWith('.')
+      ? normalizedAcceptedType.slice(1)
+      : normalizedAcceptedType;
+
+    if (normalizedExtension && normalizedExtension === extension) {
+      return true;
+    }
+
+    if (normalizedName) {
+      return normalizedName.endsWith(`.${extension}`);
+    }
+
+    return false;
+  });
+}
+
 function parseOptionValue(value: unknown): string {
   return sanitizeString(value).toLowerCase();
 }
@@ -1118,6 +1572,32 @@ function normalizeFieldOptions(rawOptions: unknown): string[] {
     .filter(Boolean);
 }
 
+function parseDateValue(raw: unknown): number | undefined {
+  if (typeof raw === 'number' && Number.isFinite(raw)) {
+    return raw;
+  }
+
+  if (typeof raw === 'string') {
+    const trimmed = raw.trim();
+    if (!trimmed) {
+      return undefined;
+    }
+
+    const parsed = Date.parse(trimmed);
+    return Number.isNaN(parsed) ? undefined : parsed;
+  }
+
+  return undefined;
+}
+
+function extractFileSubmissionName(value: Record<string, unknown>): string {
+  const fileName = sanitizeString(
+    value.fileName || value.name || value.filename || value.originalName,
+  );
+
+  return fileName;
+}
+
 function parseSubmissionValues(value: unknown): string[] {
   if (value === null || value === undefined) {
     return [];
@@ -1135,7 +1615,39 @@ function parseSubmissionValues(value: unknown): string[] {
     return [value ? 'on' : 'off'];
   }
 
-  return sanitizeString(value).split(',').map((entry) => entry.trim()).filter(Boolean);
+  if (typeof value === 'object') {
+    if (typeof File !== 'undefined' && value instanceof File) {
+      return value.name ? [value.name] : [];
+    }
+
+    const normalized = extractFileSubmissionName(value as Record<string, unknown>);
+    if (normalized) {
+      return [normalized];
+    }
+
+    const nestedValue = sanitizeString((value as { value?: unknown }).value);
+    if (nestedValue) {
+      return [nestedValue];
+    }
+
+    return [];
+  }
+
+  const normalized = sanitizeString(value);
+  return normalized.length > 0 ? [normalized] : [];
+}
+
+function isFalseyCheckboxValue(value: string): boolean {
+  const normalized = sanitizeString(value).trim().toLowerCase();
+  return !normalized || normalized === 'off' || normalized === 'false' || normalized === '0' || normalized === 'no';
+}
+
+function hasCheckboxSelection(values: readonly string[]): boolean {
+  if (values.length === 0) {
+    return false;
+  }
+
+  return values.some((value) => !isFalseyCheckboxValue(value));
 }
 
 function buildDynamicValidationRules(
@@ -1147,6 +1659,8 @@ function buildDynamicValidationRules(
   const maxLength = parseNumberValue(props.maxLength);
   const minValue = parseNumberValue(props.min);
   const maxValue = parseNumberValue(props.max);
+  const minDateValue = fieldType === 'date' ? parseDateValue(props.min) : undefined;
+  const maxDateValue = fieldType === 'date' ? parseDateValue(props.max) : undefined;
   const pattern = sanitizeString(props.pattern);
 
   if (typeof minLength === 'number' && fieldType !== 'checkbox') {
@@ -1181,6 +1695,22 @@ function buildDynamicValidationRules(
     });
   }
 
+  if (typeof minDateValue === 'number') {
+    rules.push({
+      type: 'min',
+      value: minDateValue,
+      message: `${fieldType} should be at least ${new Date(minDateValue).toLocaleDateString()}`,
+    });
+  }
+
+  if (typeof maxDateValue === 'number') {
+    rules.push({
+      type: 'max',
+      value: maxDateValue,
+      message: `${fieldType} should be no later than ${new Date(maxDateValue).toLocaleDateString()}`,
+    });
+  }
+
   if (pattern.length > 0) {
     rules.push({
       type: 'pattern',
@@ -1227,6 +1757,9 @@ function buildDynamicFieldFromElement(
     options: ['select', 'checkbox', 'radio'].includes(fieldType)
       ? parseFieldOptions(node.props.options)
       : undefined,
+    acceptedFileTypes: fieldType === 'file' ? parseAcceptedFileTypes(node.props.accept) : undefined,
+    maxFileSizeMb: fieldType === 'file' ? parseNumberValue(node.props.maxFileSizeMb) : undefined,
+    multiple: fieldType === 'file' ? parseBooleanValue(node.props.multiple) : undefined,
     validation: buildDynamicValidationRules(fieldType, node.props),
   };
 }
@@ -1432,17 +1965,51 @@ function getValueAsString(values: Record<string, unknown>, key: string): string
   return sanitizeString(values[key] || '');
 }
 
-function evaluateValidationRule(
-  fieldLabel: string,
-  fieldType: string,
-  rule: { type: string; value?: string | number; message?: string },
-  value: unknown,
-): SubmissionValidationDetail | null {
-  const trimmed = sanitizeString(value);
+function isValidEmailAddress(value: string): boolean {
+  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
+}
 
-  if (rule.type === 'required') {
-    if (trimmed.length === 0) {
-      return {
+function isValidUrlValue(raw: string): boolean {
+  if (raw.startsWith('/')) {
+    return true;
+  }
+
+  if (/^(mailto:|tel:)/i.test(raw)) {
+    return true;
+  }
+
+  try {
+    const parsed = new URL(raw);
+    return parsed.protocol === 'http:' || parsed.protocol === 'https:';
+  } catch {
+    return false;
+  }
+}
+
+function isValidPhoneValue(raw: string): boolean {
+  return /^(\+?[0-9][0-9.\-\s()]{6,})$/.test(raw);
+}
+
+function evaluateValidationRule(
+  fieldLabel: string,
+  fieldType: string,
+  rule: { type: string; value?: string | number; message?: string },
+  value: unknown,
+): SubmissionValidationDetail | null {
+  const trimmed = sanitizeString(value);
+  const trimmedValue = trimmed.trim();
+  const normalizedType = fieldType.toLowerCase();
+  const asNumber = Number(trimmedValue);
+  const dateValue = parseDateValue(trimmedValue);
+  const rawRuleValue = rule.value;
+  const compareNumber = typeof rawRuleValue === 'number'
+    ? rawRuleValue
+    : Number(rawRuleValue);
+  const compareDate = parseDateValue(rawRuleValue);
+
+  if (rule.type === 'required') {
+    if (!trimmed.length) {
+      return {
         field: fieldLabel,
         message: rule.message || `${fieldLabel} is required`,
       };
@@ -1501,32 +2068,70 @@ function evaluateValidationRule(
   }
 
   if (rule.type === 'min' || rule.type === 'max') {
-    const numeric = Number(trimmed);
-    const compare = Number(rule.value);
+    if (normalizedType === 'date') {
+      if (!Number.isFinite(dateValue as number)) {
+        return {
+          field: fieldLabel,
+          message: rule.message || `${fieldLabel} must be a valid date`,
+        };
+      }
+
+      if (
+        rule.type === 'min'
+        && Number.isFinite(compareDate as number)
+        && (dateValue as number) < (compareDate as number)
+      ) {
+        return {
+          field: fieldLabel,
+          message:
+            rule.message || `${fieldLabel} should be on or after ${new Date(compareDate!).toLocaleDateString()}`,
+        };
+      }
+
+      if (
+        rule.type === 'max'
+        && Number.isFinite(compareDate as number)
+        && (dateValue as number) > (compareDate as number)
+      ) {
+        return {
+          field: fieldLabel,
+          message:
+            rule.message || `${fieldLabel} should be no later than ${new Date(compareDate!).toLocaleDateString()}`,
+        };
+      }
+
+      return null;
+    }
 
-    if (!Number.isFinite(numeric) || !Number.isFinite(compare)) {
+    if (!Number.isFinite(compareNumber)) {
       return null;
     }
 
-    if (rule.type === 'min' && numeric < compare) {
+    if (!Number.isFinite(asNumber)) {
+      return {
+        field: fieldLabel,
+        message: rule.message || `${fieldLabel} must be a valid number`,
+      };
+    }
+
+    if (rule.type === 'min' && asNumber < compareNumber) {
       return {
         field: fieldLabel,
-        message: rule.message || `${fieldLabel} must be at least ${compare}`,
+        message: rule.message || `${fieldLabel} must be at least ${compareNumber}`,
       };
     }
 
-    if (rule.type === 'max' && numeric > compare) {
+    if (rule.type === 'max' && asNumber > compareNumber) {
       return {
         field: fieldLabel,
-        message: rule.message || `${fieldLabel} must be no more than ${compare}`,
+        message: rule.message || `${fieldLabel} must be no more than ${compareNumber}`,
       };
     }
     return null;
   }
 
   if (fieldType === 'email' && trimmed.length > 0) {
-    const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-    if (!emailPattern.test(trimmed)) {
+    if (!isValidEmailAddress(trimmed)) {
       return {
         field: fieldLabel,
         message: `${fieldLabel} must be a valid email`,
@@ -1534,6 +2139,39 @@ function evaluateValidationRule(
     }
   }
 
+  if (normalizedType === 'number' && trimmed.length > 0 && !Number.isFinite(asNumber)) {
+    return {
+      field: fieldLabel,
+      message: `${fieldLabel} must be a number`,
+    };
+  }
+
+  if (normalizedType === 'date' && trimmed.length > 0 && !Number.isFinite(dateValue as number)) {
+    return {
+      field: fieldLabel,
+      message: `${fieldLabel} must be a valid date`,
+    };
+  }
+
+  if (normalizedType === 'url') {
+    const normalizedUrl = trimmed.toLowerCase();
+    if (!isValidUrlValue(normalizedUrl)) {
+      return {
+        field: fieldLabel,
+        message: rule.message || `${fieldLabel} must be a valid URL`,
+      };
+    }
+  }
+
+  if (normalizedType === 'tel' && trimmed.length > 0) {
+    if (!isValidPhoneValue(trimmed)) {
+      return {
+        field: fieldLabel,
+        message: `${fieldLabel} must be a valid phone number`,
+      };
+    }
+  }
+
   return null;
 }
 
@@ -1550,12 +2188,21 @@ function validateSubmissionValues(
   form.fields.forEach((field) => {
     const fieldLabel = field.label || field.key;
     const fieldValue = values[field.key];
-    const sanitized = sanitizeString(fieldValue);
+    const parsedValues = parseSubmissionValues(fieldValue);
+    const normalizedValueText = sanitizeString(fieldValue);
+    const normalizedType = (field.type || 'text').toLowerCase();
+    const hasValue = parsedValues.length > 0;
+    const uploadedFiles = normalizedType === 'file' ? parseFileUploadValues(fieldValue) : [];
     const normalizedAllowedOptions = normalizeFieldOptions(field.options);
-    const submittedValues = parseSubmissionValues(fieldValue).map(sanitizeString);
+    const submittedValues = parsedValues.map(sanitizeString);
     const normalizedSubmittedValues = submittedValues.map((value) => value.toLowerCase());
+    const effectiveHasValue = normalizedType === 'checkbox'
+      ? hasCheckboxSelection(normalizedSubmittedValues)
+      : normalizedType === 'file'
+        ? uploadedFiles.length > 0
+        : hasValue;
 
-    if (field.required && sanitized.length === 0) {
+    if (field.required && !effectiveHasValue) {
       details.push({
         field: fieldLabel,
         message: `${fieldLabel} is required`,
@@ -1563,7 +2210,23 @@ function validateSubmissionValues(
       return;
     }
 
-    if ((field.type === 'select' || field.type === 'radio') && normalizedSubmittedValues.length > 0) {
+    if (normalizedType === 'select' && hasValue) {
+      if (parsedValues.length > 1) {
+        details.push({
+          field: fieldLabel,
+          message: `${fieldLabel} only supports one selected option`,
+        });
+        return;
+      }
+
+      if (normalizedAllowedOptions.length === 0) {
+        details.push({
+          field: fieldLabel,
+          message: `${fieldLabel} has no available options`,
+        });
+        return;
+      }
+
       const selectedValue = normalizedSubmittedValues[0] || '';
       const matched = normalizedAllowedOptions.includes(selectedValue);
       if (!matched) {
@@ -1574,54 +2237,120 @@ function validateSubmissionValues(
       }
     }
 
-    if ((field.type === 'checkbox') && normalizedSubmittedValues.length > 0 && normalizedAllowedOptions.length > 0) {
-      const invalid = normalizedSubmittedValues.filter((value) => !normalizedAllowedOptions.includes(value));
-      if (invalid.length > 0) {
+    if (normalizedType === 'radio' && hasValue) {
+      if (parsedValues.length > 1) {
+        details.push({
+          field: fieldLabel,
+          message: `${fieldLabel} only allows one option`,
+        });
+        return;
+      }
+
+      if (normalizedAllowedOptions.length === 0) {
+        details.push({
+          field: fieldLabel,
+          message: `${fieldLabel} has no available options`,
+        });
+        return;
+      }
+
+      const selectedValue = normalizedSubmittedValues[0] || '';
+      const matched = normalizedAllowedOptions.includes(selectedValue);
+      if (!matched) {
         details.push({
           field: fieldLabel,
-          message: `${fieldLabel} has invalid option selections`,
+          message: `${fieldLabel} value is not a valid option`,
         });
       }
     }
 
-    if (field.type === 'select' && field.required && normalizedAllowedOptions.length === 0) {
+    if (normalizedType === 'checkbox' && hasValue) {
+      if (normalizedAllowedOptions.length > 0) {
+        const invalid = normalizedSubmittedValues.filter((value) => !normalizedAllowedOptions.includes(value));
+        if (invalid.length > 0) {
+          details.push({
+            field: fieldLabel,
+            message: `${fieldLabel} has invalid option selections`,
+          });
+        }
+      }
+    }
+
+    if (normalizedType === 'email' && normalizedValueText.length > 0 && !isValidEmailAddress(normalizedValueText)) {
       details.push({
         field: fieldLabel,
-        message: `${fieldLabel} has no available options`,
+        message: `${fieldLabel} must be a valid email`,
       });
-      return;
     }
 
-    if (field.type === 'radio' && submittedValues.length > 0 && normalizedAllowedOptions.length === 0) {
+    if (
+      normalizedType === 'number' &&
+      normalizedValueText.length > 0 &&
+      !Number.isFinite(Number(normalizedValueText))
+    ) {
       details.push({
         field: fieldLabel,
-        message: `${fieldLabel} has no available options`,
+        message: `${fieldLabel} must be a valid number`,
       });
-      return;
     }
 
-    if (field.type === 'checkbox' && normalizedAllowedOptions.length === 0 && field.required && sanitized.length > 0) {
+    if (
+      normalizedType === 'date' &&
+      normalizedValueText.length > 0 &&
+      !Number.isFinite(parseDateValue(normalizedValueText) as number)
+    ) {
       details.push({
         field: fieldLabel,
-        message: `${fieldLabel} has no available options`,
+        message: `${fieldLabel} must be a valid date`,
       });
-      return;
     }
 
-    if (!field.validation || field.validation.length === 0) {
-      if (field.type === 'email' && sanitized.length > 0) {
-        const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-        if (!emailPattern.test(sanitized)) {
-          details.push({
-            field: fieldLabel,
-            message: `${fieldLabel} must be a valid email`,
-          });
+    if (normalizedType === 'url' && normalizedValueText.length > 0 && !isValidUrlValue(normalizedValueText)) {
+      details.push({
+        field: fieldLabel,
+        message: `${fieldLabel} must be a valid URL`,
+      });
+    }
+
+    if (normalizedType === 'tel' && normalizedValueText.length > 0 && !isValidPhoneValue(normalizedValueText)) {
+      details.push({
+        field: fieldLabel,
+        message: `${fieldLabel} must be a valid phone number`,
+      });
+    }
+
+    if (normalizedType === 'file') {
+      const maxFileSizeMb = parseNumberValue(field.maxFileSizeMb);
+      if (uploadedFiles.length > 0) {
+        const maxSizeBytes = typeof maxFileSizeMb === 'number'
+          ? maxFileSizeMb * 1024 * 1024
+          : undefined;
+
+        for (const uploaded of uploadedFiles) {
+          if (typeof maxSizeBytes === 'number' && uploaded.size && uploaded.size > maxSizeBytes) {
+            details.push({
+              field: fieldLabel,
+              message: `${fieldLabel} exceeds max file size (${maxFileSizeMb} MB)`,
+            });
+            break;
+          }
+
+          if (
+            Array.isArray(field.acceptedFileTypes)
+            && field.acceptedFileTypes.length > 0
+            && !isFileTypeAccepted(uploaded, field.acceptedFileTypes)
+          ) {
+            details.push({
+              field: fieldLabel,
+              message: `${fieldLabel} has unsupported file type`,
+            });
+            break;
+          }
         }
       }
-      return;
     }
 
-    for (const validation of field.validation) {
+    for (const validation of field.validation || []) {
       const violation = evaluateValidationRule(
         fieldLabel,
         field.type || 'text',
@@ -1735,46 +2464,63 @@ function checkCommentSpamSignals(
     targetId: string;
     content: string;
     authorEmail?: string | null;
+    authorUserId?: string | null;
     honeypot?: string;
     ipHash?: string | null;
     startedAt?: string | number | null;
+    antiAbuse?: CommentAntiAbusePolicy;
+    requestId?: string;
     rateLimitBypass?: boolean;
   },
 ): CommentSpamResult {
   const flags: string[] = [];
   const now = Date.now();
   const normalizedContent = sanitizeString(params.content);
+  const antiAbusePolicy = toAntiAbusePolicy(params.antiAbuse);
+  const autoBlockUserThreshold = antiAbusePolicy.autoBlockUserThreshold;
+  const autoBlockRequestThreshold = antiAbusePolicy.autoBlockRequestThreshold;
+  const antiAbuseCounters = ensureAntiAbuseCounters(params.siteId);
+  const userKey = resolveAbuseUserKey({
+    authorUserId: params.authorUserId || null,
+    authorEmail: params.authorEmail || null,
+    ipHash: params.ipHash || null,
+  });
+  const normalizedRequestId = params.requestId?.trim();
+
+  const returnResult = (status: CommentSpamResult['status'], nextFlags: string[], message?: string): CommentSpamResult => {
+    if (status !== 'pending' && status !== 'approved') {
+      updateAntiAbuseCounter(params.siteId, {
+        flags: nextFlags,
+        requestId: normalizedRequestId,
+        userKey,
+      });
+    }
 
-  if (!normalizedContent.length) {
     return {
-      ok: false,
-      status: 'rejected',
-      flags: ['validation'],
-      errors: 'Comment content is required.',
+      ok: status === 'pending' || status === 'approved',
+      status,
+      flags: nextFlags,
+      errors: message,
     };
+  };
+
+  if (!normalizedContent.length) {
+    return returnResult('rejected', ['validation'], 'Comment content is required.');
   }
 
   const blockedActor = isCommentBlockedByIdentity(params.siteId, {
     email: params.authorEmail,
     ipHash: params.ipHash,
+    userId: params.authorUserId,
+    requestId: normalizedRequestId,
   });
 
   if (blockedActor) {
-    return {
-      ok: false,
-      status: 'blocked',
-      flags: ['blocked-actor'],
-      errors: `User blocked: ${blockedActor.reason}`,
-    };
+    return returnResult('blocked', ['blocked-actor'], blockedActor.reason);
   }
 
   if (normalizedContent.length > 5000) {
-    return {
-      ok: false,
-      status: 'rejected',
-      flags: ['validation'],
-      errors: 'Comment content is too long.',
-    };
+    return returnResult('rejected', ['validation'], 'Comment content is too long.');
   }
 
   if (params.rateLimitBypass) {
@@ -1787,12 +2533,7 @@ function checkCommentSpamSignals(
 
   if (params.honeypot && sanitizeString(params.honeypot).length > 0) {
     flags.push('honeypot');
-    return {
-      ok: false,
-      status: 'spam',
-      flags,
-      errors: 'Spam signal detected: honeypot.',
-    };
+    return returnResult('spam', flags, 'Spam signal detected: honeypot.');
   }
 
   const startedAt = typeof params.startedAt === 'number'
@@ -1801,24 +2542,85 @@ function checkCommentSpamSignals(
       ? Date.parse(String(params.startedAt))
       : NaN;
 
-  if (Number.isFinite(startedAt) && now - startedAt < COMMENT_MIN_FILL_MS) {
+  if (Number.isFinite(startedAt) && now - startedAt < antiAbusePolicy.minFillMs) {
     flags.push('timing');
-    return {
-      ok: false,
-      status: 'spam',
-      flags,
-      errors: 'Submission rejected: too quick to be a human response.',
+    return returnResult('spam', flags, 'Submission rejected: too quick to be a human response.');
+  }
+
+  if (normalizedRequestId && antiAbusePolicy.requestRateLimit > 0) {
+    const requestRateKey = `${params.siteId}:${params.targetType}:${params.targetId}:request:${normalizedRequestId}`;
+    const requestRateState = COMMENT_REQUEST_RATE_WINDOWS.get(requestRateKey) || {
+      total: 0,
+      lastSubmissionAt: null,
     };
+
+    const isWithinRequestWindow = requestRateState.lastSubmissionAt !== null
+      ? now - requestRateState.lastSubmissionAt <= antiAbusePolicy.requestRateWindowMs
+      : false;
+
+    if (!isWithinRequestWindow) {
+      requestRateState.total = 0;
+      requestRateState.lastSubmissionAt = now;
+    }
+
+    requestRateState.total += 1;
+    COMMENT_REQUEST_RATE_WINDOWS.set(requestRateKey, requestRateState);
+
+    if (requestRateState.total > antiAbusePolicy.requestRateLimit) {
+      flags.push('request-rate-limit');
+      const antiAbuseResult = returnResult(
+        'spam',
+        flags,
+        `Too many comments from this request. Please wait ${Math.max(
+          10,
+          Math.round(antiAbusePolicy.requestRateWindowMs / 1000),
+        )} seconds.`,
+      );
+      const shouldBlockUser = autoBlockUserThreshold > 0
+        && (antiAbuseCounters.users.get(userKey) || 0) >= autoBlockUserThreshold;
+      const shouldBlockRequest = autoBlockRequestThreshold > 0
+        && !!normalizedRequestId
+        && (antiAbuseCounters.requests.get(normalizedRequestId) || 0) >= autoBlockRequestThreshold;
+
+      if (shouldBlockUser || shouldBlockRequest) {
+        blockCommentIdentity({
+          siteId: params.siteId,
+          reason: 'auto-block: repeated request abuse',
+          reasonAlias: `request-rate-limit:${antiAbusePolicy.requestRateLimit}`,
+          actor: 'system:anti-abuse',
+          requestId: normalizedRequestId,
+          email: params.authorEmail,
+          userId: params.authorUserId,
+          ipHash: params.ipHash,
+          blockRequestId: normalizedRequestId,
+          durationMinutes: antiAbusePolicy.autoBlockDurationMinutes,
+        });
+
+        return {
+          ok: false,
+          status: 'blocked',
+          flags: [...flags, 'auto-block'],
+          errors: 'Request blocked due to repeated anti-abuse activity.',
+        };
+      }
+
+      return antiAbuseResult;
+    }
   }
 
-  const key = getCommentRequestKey(params.siteId, params.targetType, params.targetId, params.ipHash);
+  const key = getCommentRequestKey(
+    params.siteId,
+    params.targetType,
+    params.targetId,
+    `${params.ipHash || params.authorEmail || params.authorUserId || ''}`,
+  );
   const rateState = COMMENT_RATE_WINDOWS.get(key) || {
     total: 0,
     lastSubmissionAt: null,
   };
 
   const isWithinWindow = rateState.lastSubmissionAt !== null
-    ? now - rateState.lastSubmissionAt <= COMMENT_RATE_WINDOW_MS
+    ? now - rateState.lastSubmissionAt <= antiAbusePolicy.rateWindowMs
     : false;
 
   if (!isWithinWindow) {
@@ -1829,31 +2631,87 @@ function checkCommentSpamSignals(
   rateState.total += 1;
   COMMENT_RATE_WINDOWS.set(key, rateState);
 
-  if (rateState.total > COMMENT_RATE_LIMIT) {
+  const blockRateLimit = antiAbusePolicy.rateLimit;
+
+  if (rateState.total > blockRateLimit) {
     flags.push('rate-limit');
-    return {
-      ok: false,
-      status: 'spam',
+    const antiAbuseResult = returnResult(
+      'spam',
       flags,
-      errors: `Too many comments. Please wait ${Math.max(10, Math.round(COMMENT_RATE_WINDOW_MS / 1000))} seconds.`,
-    };
+      `Too many comments. Please wait ${Math.max(10, Math.round(antiAbusePolicy.rateWindowMs / 1000))} seconds.`,
+    );
+    const shouldBlockUser = autoBlockUserThreshold > 0
+      && (antiAbuseCounters.users.get(userKey) || 0) >= autoBlockUserThreshold;
+    const shouldBlockRequest = autoBlockRequestThreshold > 0
+      && !!normalizedRequestId
+      && (antiAbuseCounters.requests.get(normalizedRequestId) || 0) >= autoBlockRequestThreshold;
+
+    if (shouldBlockUser || shouldBlockRequest) {
+      const reasonAlias = `rate-limit:${antiAbusePolicy.rateLimit}`;
+      blockCommentIdentity({
+        siteId: params.siteId,
+        reason: 'auto-block: repeated abuse',
+        reasonAlias,
+        actor: 'system:anti-abuse',
+        requestId: normalizedRequestId,
+        email: params.authorEmail,
+        userId: params.authorUserId,
+        ipHash: params.ipHash,
+        durationMinutes: antiAbusePolicy.autoBlockDurationMinutes,
+        blockRequestId: normalizedRequestId,
+      });
+      return {
+        ok: false,
+        status: 'blocked',
+        flags: [...flags, 'auto-block'],
+        errors: 'User blocked due to repeated anti-abuse activity.',
+      };
+    }
+
+    return antiAbuseResult;
   }
 
   const signature = makeSubmissionSignature({ commentContent: normalizedContent, content: normalizedContent });
   const signatureKey = `${key}:signature:${signature}`;
   const signatures = COMMENT_SIGNATURES.get(signatureKey) || [];
-  const activeSignatures = signatures.filter((value) => now - value <= COMMENT_SIGNATURE_WINDOW_MS);
+  const activeSignatures = signatures.filter(
+    (value) => now - value <= antiAbusePolicy.signatureWindowMs,
+  );
 
   if (activeSignatures.length > 0) {
     activeSignatures.push(now);
     COMMENT_SIGNATURES.set(signatureKey, activeSignatures);
     flags.push('duplicate');
-    return {
-      ok: false,
-      status: 'spam',
-      flags,
-      errors: 'Duplicate comment blocked.',
-    };
+    const antiAbuseResult = returnResult('spam', flags, 'Duplicate comment blocked.');
+
+    const shouldBlockUser = autoBlockUserThreshold > 0
+      && (antiAbuseCounters.users.get(userKey) || 0) >= autoBlockUserThreshold;
+    const shouldBlockRequest = autoBlockRequestThreshold > 0
+      && !!normalizedRequestId
+      && (antiAbuseCounters.requests.get(normalizedRequestId) || 0) >= autoBlockRequestThreshold;
+
+    if (shouldBlockUser || shouldBlockRequest) {
+      blockCommentIdentity({
+        siteId: params.siteId,
+        reason: 'auto-block: repeated abuse',
+        reasonAlias: `duplicate:signature`,
+        actor: 'system:anti-abuse',
+        requestId: normalizedRequestId,
+        email: params.authorEmail,
+        userId: params.authorUserId,
+        ipHash: params.ipHash,
+        durationMinutes: antiAbusePolicy.autoBlockDurationMinutes,
+        blockRequestId: normalizedRequestId,
+      });
+      return {
+        ok: false,
+        status: 'blocked',
+        flags: [...flags, 'auto-block'],
+        errors: 'User blocked due to repeated anti-abuse activity.',
+      };
+    }
+
+    return antiAbuseResult;
   }
 
   activeSignatures.push(now);
@@ -2124,6 +2982,8 @@ export function validateAndClassifyComment(params: {
   content: string;
   moderationMode: 'manual' | 'auto-approve';
   authorEmail?: string;
+  userId?: string;
+  antiAbuse?: CommentAntiAbusePolicy;
   honeypot?: string;
   ipHash?: string | null;
   requestId?: string;
@@ -2140,11 +3000,14 @@ export function validateAndClassifyComment(params: {
     targetType: params.targetType,
     targetId: params.targetId,
     authorEmail: params.authorEmail,
+    authorUserId: params.userId,
+    requestId: params.requestId,
     content: params.content,
     honeypot: params.honeypot,
     ipHash: params.ipHash,
     startedAt: params.startedAt,
     rateLimitBypass: params.rateLimitBypass,
+    antiAbuse: params.antiAbuse,
   });
 
   return {
@@ -2352,9 +3215,16 @@ export function blockCommentIdentity(params: {
   reason: string;
   actor?: string;
   requestId?: string;
+  reasonAlias?: string;
+  blockDurationMinutes?: number;
+  blockRequestId?: string;
   email?: string | null;
   ipHash?: string | null;
+  userId?: string | null;
 }) {
+  removeExpiredCommentBlocks(params.siteId);
+  const expiresAt = resolveExpiryDate(params.blockDurationMinutes);
+
   if (params.email) {
     COMMENT_REPORT_BLOCKLIST.set(getCommentBlockKey(params.siteId, 'email', params.email), {
       type: 'email',
@@ -2363,6 +3233,8 @@ export function blockCommentIdentity(params: {
       actor: params.actor,
       requestId: params.requestId,
       createdAt: new Date().toISOString(),
+      reasonAlias: params.reasonAlias,
+      expiresAt,
     });
   }
 
@@ -2374,8 +3246,125 @@ export function blockCommentIdentity(params: {
       actor: params.actor,
       requestId: params.requestId,
       createdAt: new Date().toISOString(),
+      reasonAlias: params.reasonAlias,
+      expiresAt,
+    });
+  }
+
+  if (params.userId) {
+    COMMENT_REPORT_BLOCKLIST.set(getCommentBlockKey(params.siteId, 'user', params.userId), {
+      type: 'user',
+      value: normalizeIdentifier(params.userId),
+      reason: params.reason,
+      actor: params.actor,
+      requestId: params.requestId,
+      createdAt: new Date().toISOString(),
+      reasonAlias: params.reasonAlias,
+      expiresAt,
+    });
+  }
+
+  if (params.blockRequestId) {
+    COMMENT_REPORT_BLOCKLIST.set(getCommentBlockKey(params.siteId, 'request', params.blockRequestId), {
+      type: 'request',
+      value: normalizeIdentifier(params.blockRequestId),
+      reason: params.reason,
+      actor: params.actor,
+      requestId: params.requestId,
+      createdAt: new Date().toISOString(),
+      reasonAlias: params.reasonAlias,
+      expiresAt,
     });
   }
+
+  removeExpiredCommentBlocks(params.siteId);
+}
+
+export function listCommentBlocks(params: {
+  siteId: string;
+  type?: CommentBlockKind | 'all';
+  q?: string;
+  requestId?: string;
+  includeExpired?: boolean;
+}): { blocks: CommentBlockEntryPayload[]; count: number } {
+  const kindFilter = params.type && params.type !== 'all' ? params.type : 'all';
+  const query = params.q?.trim().toLowerCase() || '';
+  const normalizedRequestId = params.requestId?.trim();
+
+  if (!params.includeExpired) {
+    removeExpiredCommentBlocks(params.siteId);
+  }
+
+  const sitePrefix = `${params.siteId}:`;
+  const matching = Array.from(COMMENT_REPORT_BLOCKLIST.entries())
+    .filter(([key, entry]) => {
+      if (!key.startsWith(sitePrefix)) {
+        return false;
+      }
+
+      if (kindFilter !== 'all' && entry.type !== kindFilter) {
+        return false;
+      }
+
+      if (query) {
+        const haystack = [
+          entry.type,
+          entry.value,
+          entry.reason,
+          entry.actor || '',
+          entry.requestId || '',
+          entry.reasonAlias || '',
+        ]
+          .filter(Boolean)
+          .join(' ')
+          .toLowerCase();
+
+        if (!haystack.includes(query)) {
+          return false;
+        }
+      }
+
+      if (normalizedRequestId) {
+        return entry.requestId === normalizedRequestId || entry.value === normalizeIdentifier(normalizedRequestId);
+      }
+
+      return true;
+    })
+    .map(([key, entry]) => ({
+      ...entry,
+      key,
+    }));
+
+  return {
+    blocks: matching,
+    count: matching.length,
+  };
+}
+
+export function removeCommentBlocks(params: {
+  siteId: string;
+  blocks: Array<{ type: CommentBlockKind; value: string }>;
+}) {
+  if (!Array.isArray(params.blocks) || params.blocks.length === 0) {
+    return { removed: 0 };
+  }
+
+  let removed = 0;
+  const seen = new Set<string>();
+  params.blocks.forEach((block) => {
+    const key = getCommentBlockKey(params.siteId, block.type, block.value);
+    if (seen.has(key)) {
+      return;
+    }
+
+    seen.add(key);
+    if (COMMENT_REPORT_BLOCKLIST.delete(key)) {
+      removed += 1;
+    }
+  });
+
+  removeExpiredCommentBlocks(params.siteId);
+  return { removed };
 }
 
 export function getCommentReportReasons(): CommentReportReason[] {
@@ -2402,6 +3391,19 @@ export function reportComment(params: {
   }
 
   const normalizedReason = normalizeReportReason(params.reason || null);
+  const abuseUserKey = resolveAbuseUserKey({
+    authorUserId: comment.userId || null,
+    authorEmail: comment.authorEmail || null,
+    ipHash: comment.ipHash || null,
+  });
+  const normalizedRequestId = params.requestId || comment.requestId || null;
+  const reportSignal = normalizedReason ? `report:${normalizedReason}` : 'report';
+  updateAntiAbuseCounter(comment.siteId, {
+    flags: [reportSignal],
+    requestId: normalizedRequestId,
+    userKey: abuseUserKey || null,
+  });
+
   const reportCount = (comment.reportCount || 0) + 1;
   const reportReasons = new Set(comment.reportReasons || []);
   if (normalizedReason) {
@@ -2450,6 +3452,7 @@ export function bulkUpdateCommentStatus(params: {
   blockReason?: string | null;
   actor?: string | null;
   requestId?: string;
+  blockDurationMinutes?: number;
 }): { updated: Comment[]; missingIds: string[] } {
   const ids = Array.from(new Set(params.commentIds.map((id) => id.trim()).filter(Boolean)));
   if (ids.length === 0) {
@@ -2485,7 +3488,10 @@ export function bulkUpdateCommentStatus(params: {
         actor: reviewer,
         requestId: resolvedRequestId,
         email: comment.authorEmail,
+        userId: comment.userId,
         ipHash: comment.ipHash,
+        blockDurationMinutes: params.blockDurationMinutes,
+        reasonAlias: 'admin:block',
       });
     } else if (params.status !== 'rejected' && params.status !== 'spam') {
       comment.blockReason = null;
@@ -2743,6 +3749,211 @@ export function listComments(
   };
 }
 
+export function getCommentModerationAnalytics(
+  siteId: string,
+  params: {
+    targetType?: CommentTargetType | 'all';
+    targetId?: string;
+    status?: 'pending' | 'approved' | 'rejected' | 'spam' | 'blocked' | 'all';
+    requestId?: string;
+    commentThreadId?: string;
+    q?: string;
+    parentOnly?: boolean;
+    parentId?: string | null;
+  } = {},
+): CommentModerationAnalytics {
+  const {
+    targetType,
+    targetId,
+    status = 'all',
+    requestId,
+    commentThreadId,
+    q,
+    parentOnly = false,
+    parentId,
+  } = params;
+  const normalizedRequestId = requestId ? requestId.trim() : '';
+  const normalizedThreadId = commentThreadId ? commentThreadId.trim() : '';
+  const normalizedQuery = normalizeCommentSearch(q || '');
+  const normalizedParentId = typeof parentId === 'string' && parentId.trim() ? parentId.trim() : null;
+
+  let records = commentStore.filter((comment) => comment.siteId === siteId);
+
+  if (targetType && targetType !== 'all') {
+    records = records.filter((comment) => comment.targetType === targetType);
+  }
+
+  if (targetId) {
+    records = records.filter((comment) => comment.targetId === targetId);
+  }
+
+  if (status && status !== 'all') {
+    records = records.filter((comment) => comment.status === status);
+  }
+
+  if (normalizedRequestId) {
+    records = records.filter((comment) => comment.requestId === normalizedRequestId);
+  }
+
+    if (normalizedThreadId) {
+      records = records.filter((comment) => comment.commentThreadId === normalizedThreadId);
+    }
+
+    if (normalizedQuery) {
+      records = records.filter((comment) => {
+        const haystack = [
+          comment.content,
+          comment.authorName,
+          comment.authorEmail,
+          comment.authorWebsite,
+          comment.requestId || '',
+          comment.reportReasons?.join(' '),
+        ]
+          .filter(Boolean)
+          .map((value) => (value || '').toLowerCase())
+          .join(' ');
+
+        return haystack.includes(normalizedQuery);
+      });
+    }
+
+    if (parentOnly) {
+      records = records.filter((comment) =>
+        normalizedParentId ? comment.parentId === normalizedParentId : comment.parentId == null,
+      );
+    }
+
+  const statusCounts: {
+    pending: number;
+    approved: number;
+    rejected: number;
+    spam: number;
+    blocked: number;
+  } = {
+    pending: 0,
+    approved: 0,
+    rejected: 0,
+    spam: 0,
+    blocked: 0,
+  };
+
+  const byTargetType = {
+    page: 0,
+    post: 0,
+  };
+
+  let totalReports = 0;
+  let threads = 0;
+  let replies = 0;
+  const reportReasonCounts = new Map<string, number>();
+  const antiAbuseFlags = new Map<string, number>();
+  const antiAbuseUsers = new Map<string, number>();
+  const antiAbuseRequests = new Map<string, number>();
+  const antiAbuseBlockReasonCounts = new Map<string, number>();
+  const sitePolicy = getSiteCommentAntiAbusePolicy(siteId);
+
+  records.forEach((comment) => {
+    statusCounts[comment.status] = statusCounts[comment.status] + 1;
+    byTargetType[comment.targetType] = byTargetType[comment.targetType] + 1;
+
+    if (comment.parentId) {
+      replies += 1;
+    } else {
+      threads += 1;
+    }
+
+    if (comment.reportCount && comment.reportCount > 0) {
+      totalReports += comment.reportCount;
+    }
+
+    (comment.reportReasons || []).forEach((reason) => {
+      reportReasonCounts.set(reason, (reportReasonCounts.get(reason) || 0) + 1);
+    });
+
+    (comment.spamFlags || []).forEach((flag) => {
+      antiAbuseFlags.set(flag, (antiAbuseFlags.get(flag) || 0) + 1);
+    });
+
+    const antiAbuseUserKey = resolveAbuseUserKey({
+      authorUserId: comment.userId || null,
+      authorEmail: comment.authorEmail || null,
+      ipHash: comment.ipHash || null,
+    });
+
+    if (comment.requestId) {
+      antiAbuseRequests.set(comment.requestId, (antiAbuseRequests.get(comment.requestId) || 0) + 1);
+    }
+
+    if (comment.spamFlags?.length) {
+      antiAbuseUsers.set(antiAbuseUserKey, (antiAbuseUsers.get(antiAbuseUserKey) || 0) + 1);
+    }
+  });
+
+  const topReportReasons = Array.from(reportReasonCounts.entries())
+    .map(([reason, count]) => ({ reason, count }))
+    .sort((a, b) => b.count - a.count)
+    .slice(0, 8);
+
+  const topFlags = Array.from(antiAbuseFlags.entries())
+    .map(([flag, count]) => ({ flag, count }))
+    .sort((a, b) => b.count - a.count)
+    .slice(0, 10);
+
+  const topFlaggedUsers = Array.from(antiAbuseUsers.entries())
+    .map(([userKey, count]) => ({ userKey, count }))
+    .sort((a, b) => b.count - a.count)
+    .slice(0, 10);
+
+  const topRequestIds = Array.from(antiAbuseRequests.entries())
+    .map(([requestId, count]) => ({ requestId, count }))
+    .sort((a, b) => b.count - a.count)
+    .slice(0, 10);
+
+  const activeBlocks = listCommentBlocks({
+    siteId,
+    type: 'all',
+    includeExpired: false,
+  }).blocks;
+
+  for (const block of activeBlocks) {
+    const reasonAlias = block.reasonAlias || block.reason || 'manual-block';
+    antiAbuseBlockReasonCounts.set(reasonAlias, (antiAbuseBlockReasonCounts.get(reasonAlias) || 0) + 1);
+  }
+
+  const topBlockReasons = Array.from(antiAbuseBlockReasonCounts.entries())
+    .map(([reasonAlias, count]) => ({ reasonAlias, count }))
+    .sort((a, b) => b.count - a.count)
+    .slice(0, 10);
+
+  const antiAbuseCounter = ensureAntiAbuseCounters(siteId);
+
+  return {
+    siteId,
+    total: records.length,
+    status: statusCounts,
+    byTargetType,
+    threads,
+    replies,
+    totalReports,
+    topReportReasons,
+    antiAbuse: {
+      totalSignals: antiAbuseCounter.totalSignals,
+      antiAbusePolicy: sitePolicy,
+      flags: topFlags,
+      topFlaggedUsers,
+      topRequestIds,
+      topBlockReasons,
+      blockedByIdentity: antiAbuseCounter.blockedByIdentity,
+      blockedByType: {
+        email: antiAbuseCounter.blockedByType.email,
+        ip: antiAbuseCounter.blockedByType.ip,
+        user: antiAbuseCounter.blockedByType.user,
+        request: antiAbuseCounter.blockedByType.request,
+      },
+    },
+  };
+}
+
 export function getCommentsByTarget(
   siteId: string,
   params: {
@@ -2775,6 +3986,7 @@ export function updateCommentStatus(
     blockReason?: string | null;
     actor?: string | null;
     requestId?: string;
+    blockDurationMinutes?: number;
   },
 ): Comment | undefined {
   const comment = commentStore.find((item) => item.id === commentId);
@@ -2794,14 +4006,17 @@ export function updateCommentStatus(
     comment.blockedBy = comment.reviewedBy;
     comment.blockedAt = comment.reviewedAt;
 
-    blockCommentIdentity({
-      siteId: comment.siteId,
-      reason: comment.blockReason || 'manual-block',
-      actor: comment.reviewedBy || undefined,
-      requestId: resolvedRequestId,
-      email: comment.authorEmail,
-      ipHash: comment.ipHash,
-    });
+      blockCommentIdentity({
+        siteId: comment.siteId,
+        reason: comment.blockReason || 'manual-block',
+        actor: comment.reviewedBy || undefined,
+        requestId: resolvedRequestId,
+        blockDurationMinutes: updates.blockDurationMinutes,
+        reasonAlias: 'admin:block',
+        userId: comment.userId,
+        email: comment.authorEmail,
+        ipHash: comment.ipHash,
+      });
   } else if (updates.status !== 'rejected' && updates.status !== 'spam') {
     comment.blockReason = null;
     comment.blockedBy = null;
@@ -2857,6 +4072,7 @@ export function createComment(params: {
   parentId?: string | null;
   requestId?: string;
   ipHash?: string | null;
+  spamFlags?: string[];
 }): Comment {
   const comment: Comment = {
     id: `comment-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`,
@@ -2879,10 +4095,11 @@ export function createComment(params: {
     blockedAt: null,
     reportCount: 0,
     reportReasons: [],
-    requestId: params.requestId || null,
-    ipHash: params.ipHash || null,
-    createdAt: new Date().toISOString(),
-    updatedAt: new Date().toISOString(),
+    spamFlags: Array.isArray(params.spamFlags) ? params.spamFlags : [],
+  requestId: params.requestId || null,
+  ipHash: params.ipHash || null,
+  createdAt: new Date().toISOString(),
+  updatedAt: new Date().toISOString(),
   };
 
   commentStore = [comment, ...commentStore];
@@ -2901,6 +4118,7 @@ export function createComment(params: {
       parentId: comment.parentId,
       hasAuthorEmail: Boolean(comment.authorEmail),
       hasAuthorWebsite: Boolean(comment.authorWebsite),
+      spamFlags: comment.spamFlags,
     },
   });
 
diff --git a/packages/core/src/types/index.ts b/packages/core/src/types/index.ts
index 4aa0590..d95cece 100644
--- a/packages/core/src/types/index.ts
+++ b/packages/core/src/types/index.ts
@@ -789,6 +789,15 @@ export interface FormFieldDefinition {
   /** Validation rules */
   validation?: FormValidationRule[];
 
+  /** Accepted file extensions or MIME patterns for file field types (e.g. ".pdf,.jpg,image/*") */
+  acceptedFileTypes?: string[];
+
+  /** Maximum file size in megabytes for file field types */
+  maxFileSizeMb?: number;
+
+  /** Allow multiple file uploads for file inputs */
+  multiple?: boolean;
+
   /** Whether value is required */
   required?: boolean;
 }
@@ -951,6 +960,7 @@ export interface Comment {
   blockedAt?: string | null;
   reportCount?: number;
   reportReasons?: CommentReportReason[];
+  spamFlags?: string[];
   requestId?: string | null;
   ipHash?: string | null;
 
@@ -995,6 +1005,19 @@ export interface Contact {
 }
 
 /** Commenting policy for page/blog render payload */
+export interface CommentAntiAbusePolicy {
+  rateLimit?: number;
+  rateWindowMs?: number;
+  signatureWindowMs?: number;
+  minFillMs?: number;
+  autoBlockSpamCount?: number;
+  autoBlockDurationMinutes?: number;
+  requestRateLimit?: number;
+  requestRateWindowMs?: number;
+  autoBlockUserThreshold?: number;
+  autoBlockRequestThreshold?: number;
+}
+
 export interface CommentPolicy {
   enabled: boolean;
   allowGuests: boolean;
@@ -1003,6 +1026,7 @@ export interface CommentPolicy {
   allowReplies?: boolean;
   moderationRequired?: boolean;
   maxDepth?: number;
+  antiAbuse?: CommentAntiAbusePolicy;
 }
 
 /**
diff --git a/specs/backy-cms-completion-spec.md b/specs/backy-cms-completion-spec.md
index 5f05ae5..e603f84 100644
--- a/specs/backy-cms-completion-spec.md
+++ b/specs/backy-cms-completion-spec.md
@@ -15,6 +15,31 @@ Backy should be a production-oriented, open-source backend that enables:
 The working implementation roadmap is maintained in:
 - [specs/backy-wix-canva-cms-v1-roadmap.md](specs/backy-wix-canva-cms-v1-roadmap.md)
 
+**Authoritative phase status and roadmap:**
+- [specs/phase-docs/backy-headless-cms-platform-phase-roadmap-v1.md](specs/phase-docs/backy-headless-cms-platform-phase-roadmap-v1.md)
+- [specs/phase-docs/backy-headless-cms-platform-phase-roadmap-v2.md](specs/phase-docs/backy-headless-cms-platform-phase-roadmap-v2.md)
+- [specs/backy-full-parity-roadmap-spec.md](specs/backy-full-parity-roadmap-spec.md)
+- [specs/phase-docs/backy-phase-a-j-completion-spec.md](specs/phase-docs/backy-phase-a-j-completion-spec.md)
+- [specs/phase-docs/backy-alpha-vs-numeric-phase-progress-2026-02-27.md](specs/phase-docs/backy-alpha-vs-numeric-phase-progress-2026-02-27.md)
+
+## 1.2 Phase A/B/C status snapshot (2026-02-27)
+- **Phase A:** partial completion.
+  - Done: contracts hardened for form/comment payloads, comment anti-abuse policy shape added, public auth bridge.
+  - Open: admin/public store boundary hardening, and route-level RBAC migration.
+  - Update: route/session guard now uses selector-backed auth capability gates (`canEdit`, `canAdminister`) and admin-only navigation items are hidden from non-admin roles.
+- **Phase B:** in-progress completion.
+  - Done: selection and interaction improvements, render stability, property panel upgrades.
+  - Done: undo/redo completion, copy/duplicate/delete determinism, save/publish/reload persistence flow hardening, and read-only editor action gating.
+  - Latest close-out: duplicate placement is now deterministic sibling insertion; page save fallback uses editor canvas size instead of stale initial.
+  - Open: nested multi-select command stack cases and full revision graph integration.
+  - In this pass: move/resize history commits now occur on interaction end for deterministic undo/redo while keeping live drags responsive.
+  - Latest pass: read-only editor gating now blocks mutation actions in non-editor roles.
+- **Phase C:** complete for parity-grade comment moderation.
+  - Done: form/comment compatibility, moderation status updates, comment blocklist CRUD, report reason APIs, analytics/report/export parity, and strict anti-abuse policy validation.
+  - In progress: finalize operator-only anti-abuse preset ergonomics and large-scope moderation safety UX.
+  - Progress in this pass: status/thread/request/parent filtering is aligned across list/export/analytics/block views; JSX parser errors in moderation view have been resolved; route-level admin write gates were added for non-edit roles; and policy validation errors now flow to admin UI.
+- **Custom frontend target:** `backy-public` is the contract boundary for replacement UI surfaces; custom frontends should never require admin internals.
+
 The goal is parity with “Wix-like editor + WordPress-like content model” for self-hosted or Vercel-hosted backends.
 
 ---

# --- excluded untracked/new files (not in this diff by design) ---
apps/public/src/app/api/sites/[siteId]/comments/analytics/route.ts
apps/public/src/app/api/sites/[siteId]/comments/blocks/route.ts
apps/public/src/app/api/sites/[siteId]/comments/export/route.ts
apps/public/src/app/api/sites/[siteId]/comments/policy/route.ts
apps/public/src/hooks/useBackyAuthBridge.ts
apps/public/src/lib/backyAuthBridge.ts
refactor.js
specs/backy-full-parity-roadmap-spec.md
specs/implementation-plans/four-day-fast-track-execution-plan.md
specs/implementation-plans/phase-a-contract-persistence-auth-plan.md
specs/implementation-plans/phase-b-editor-action-wiring-plan.md
specs/implementation-plans/phase-b-text-interaction-and-undo-redo-plan.md
specs/implementation-plans/phase-c-form-engine-plan.md
specs/implementation-plans/phase-d-comment-moderation-plan.md
specs/implementation-plans/phase-e-core-cms-composition-plan.md
specs/implementation-plans/phase-f-public-api-first-plan.md
specs/implementation-plans/phase-g-versioning-deploy-plan.md
specs/implementation-plans/phase-h-media-seo-localization-plan.md
specs/implementation-plans/phase-i-analytics-audit-governance-plan.md
specs/implementation-plans/phase-j-extensibility-platform-plan.md
specs/phase-c-completion-plan.md
specs/phase-docs/backy-alpha-vs-numeric-phase-progress-2026-02-27.md
specs/phase-docs/backy-headless-cms-platform-phase-roadmap-v1.md
specs/phase-docs/backy-headless-cms-platform-phase-roadmap-v2.md
specs/phase-docs/backy-phase-a-j-completion-spec.md
specs/stash.md
stash-diff-code.txt
